[runlim] version:		1.10
[runlim] time limit:		311040000 seconds
[runlim] real time limit:	311040000 seconds
[runlim] space limit:		32164 MB
[runlim] argv[0]:		testing-workflow/run-si-tests.sh
[runlim] argv[1]:		cosa/single.txt
[runlim] argv[2]:		testing-workflow/bug-injection-patches/
[runlim] argv[3]:		ridecore-original-src/
[runlim] start:			Mon Apr  8 16:19:10 2019
[runlim] main pid:		21989
Operator name: ADDI
  Bug injection patch file for instruction ADDI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_ADDI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..30dfdb1 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -16,7 +16,7 @@ module alu(
 
    always @(*) begin
       case (op)
-        `ALU_OP_ADD : out = in1 + in2;
+        `ALU_OP_ADD : out = in1 - in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		9.9 time, 10.2 real, 202.8 MB
[runlim] sample:		0.6 time, 20.2 real, 61.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ADDI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		10.6 time, 30.2 real, 459.4 MB
__[runlim] sample:		20.6 time, 40.2 real, 675.6 MB
___[runlim] sample:		30.6 time, 50.2 real, 819.2 MB
__[runlim] sample:		40.6 time, 60.2 real, 1052.3 MB
__[runlim] sample:		50.6 time, 70.2 real, 1338.5 MB
__[runlim] sample:		60.6 time, 80.2 real, 1538.1 MB
__[runlim] sample:		70.6 time, 90.2 real, 1701.8 MB
_[runlim] sample:		80.5 time, 100.2 real, 1874.0 MB
_[runlim] sample:		90.5 time, 110.2 real, 2067.0 MB
__[runlim] sample:		100.5 time, 120.2 real, 2140.8 MB
_[runlim] sample:		110.5 time, 130.2 real, 2221.6 MB
_.[runlim] sample:		120.5 time, 140.2 real, 2315.0 MB
.[runlim] sample:		130.5 time, 150.2 real, 2505.3 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for ADDI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 2147483775_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 262146_32][12_5 := 1048576_32][14_5 := 2147483648_32][1_5 := 16_32][24_5 := 16_32][2_5 := 1073741824_32][4_5 := 2112_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2415923327_32
  S1: state_counter = 1_10

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 134221951_32
  S2: state_counter = 2_10
  S2: val1 = 1073741824_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 33554432_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2164265087_32
  S4: state_counter = 4_10
  S4: val1 = 0_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 285216895_32
  S5: state_counter = 5_10
  S5: val1 = 4194304_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 115674131_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 110_32
  S8: rd_copy = 24_5
  S8: state_counter = 8_10
  S8: val1 = 1074790400_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 262146_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1610612736_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 25165951_32
  S11: state_counter = 11_10
  S11: val1 = 262272_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 1690437247_32
  S12: state_counter = 12_10
  S12: val1 = 262144_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 20971647_32
  S13: state_counter = 13_10
  S13: val1 = 268435456_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 127_32
  S14: state_counter = 14_10
  S14: val1 = 2415919104_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 262144_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1092616319_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 262144_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 563482751_32
  S18: state_counter = 18_10
  S18: val1 = 270532608_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 268439935_32
  S19: state_counter = 19_10
  S19: val1 = 536870912_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 2147488127_32
  S20: state_counter = 20_10
  S20: val1 = 262146_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 2149580927_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 33558655_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 262146_32][12_5 := 1048576_32][14_5 := 2147483648_32][1_5 := 16_32][24_5 := 262036_32][2_5 := 1073741824_32][4_5 := 2112_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for ADDI.vcd
  Test for ADDI using testing-workflow/bug-injection-patches/alu-bug-injected_0_ADDI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction ADDI:  testing-workflow/bug-injection-patches/alu-bug-injected_2_ADDI.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..913efef 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -192,7 +192,7 @@ module decoder(
 
    always @(*) begin
       case (funct3)
-        `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
+        `RV32_FUNCT3_ADD_SUB : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		0.6 time, 160.2 real, 74.6 MB
[runlim] sample:		10.6 time, 170.2 real, 202.5 MB
[runlim] sample:		1.2 time, 180.2 real, 76.5 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ADDI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		11.2 time, 190.2 real, 465.9 MB
___[runlim] sample:		21.2 time, 200.2 real, 678.2 MB
__[runlim] sample:		31.2 time, 210.2 real, 832.9 MB
__[runlim] sample:		41.2 time, 220.2 real, 1086.3 MB
__[runlim] sample:		51.1 time, 230.2 real, 1334.4 MB
__[runlim] sample:		61.1 time, 240.2 real, 1560.6 MB
__[runlim] sample:		71.2 time, 250.2 real, 1725.3 MB
_[runlim] sample:		81.2 time, 260.2 real, 1862.6 MB
__[runlim] sample:		91.1 time, 270.2 real, 2065.6 MB
_[runlim] sample:		101.1 time, 280.2 real, 2104.9 MB
_[runlim] sample:		111.1 time, 290.2 real, 2233.5 MB
_.[runlim] sample:		121.1 time, 300.2 real, 2375.8 MB
.[runlim] sample:		131.1 time, 310.2 real, 2519.0 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for ADDI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 268435583_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2097152_32][11_5 := 69206016_32][12_5 := 4193280_32][15_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2415947903_32
  S1: state_counter = 1_10
  S1: val1 = 2147487744_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147489919_32
  S2: state_counter = 2_10
  S2: val1 = 16777216_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 134223999_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147489919_32
  S4: state_counter = 4_10
  S4: val1 = 3221225474_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 3221227647_32
  S5: state_counter = 5_10
  S5: val1 = 2_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 83198995_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 79_32
  S8: rd_copy = 8_5
  S8: state_counter = 8_10
  S8: val1 = 1207959552_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 69206272_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 69206032_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 19136639_32
  S11: state_counter = 11_10
  S11: val1 = 69206017_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 1084622719_32
  S12: state_counter = 12_10
  S12: val1 = 69206016_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 18874495_32
  S13: state_counter = 13_10
  S13: val1 = 1075838976_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 25428095_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1048703_32
  S15: state_counter = 15_10
  S15: val1 = 69206016_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1073873023_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 805306368_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1217433727_32
  S18: state_counter = 18_10
  S18: val1 = 268435456_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1107300479_32
  S19: state_counter = 19_10
  S19: val1 = 1073741824_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 2147487871_32
  S20: state_counter = 20_10
  S20: val1 = 69206016_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 67108991_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for ADDI.vcd
  Test for ADDI using testing-workflow/bug-injection-patches/alu-bug-injected_2_ADDI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction ADDI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_ADDI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..8288320 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -16,7 +16,7 @@ module alu(
 
    always @(*) begin
       case (op)
-        `ALU_OP_ADD : out = in1 + in2;
+        `ALU_OP_ADD : out = in1 << in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		1.4 time, 320.2 real, 129.1 MB
[runlim] sample:		11.4 time, 330.2 real, 202.5 MB
[runlim] sample:		2.0 time, 340.2 real, 86.8 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ADDI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		12.0 time, 350.2 real, 472.1 MB
___[runlim] sample:		22.0 time, 360.2 real, 679.3 MB
__[runlim] sample:		32.0 time, 370.2 real, 952.6 MB
___[runlim] sample:		42.0 time, 380.2 real, 1116.8 MB
__[runlim] sample:		52.0 time, 390.2 real, 1395.6 MB
__[runlim] sample:		62.0 time, 400.2 real, 1551.7 MB
_[runlim] sample:		72.0 time, 410.2 real, 1816.1 MB
__[runlim] sample:		82.0 time, 420.2 real, 1950.9 MB
_[runlim] sample:		92.0 time, 430.2 real, 2081.6 MB
_[runlim] sample:		101.9 time, 440.2 real, 2207.3 MB
_[runlim] sample:		111.9 time, 450.2 real, 2356.8 MB
_..[runlim] sample:		121.9 time, 460.2 real, 2413.1 MB
[runlim] sample:		131.9 time, 470.2 real, 2520.5 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for ADDI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 2684354687_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1073741824_32][11_5 := 1073741824_32][15_5 := 2097152_32][17_5 := 262144_32][23_5 := 1073741824_32][2_5 := 2147483648_32][3_5 := 2147483648_32][5_5 := 1_32][8_5 := 1_32][9_5 := 65536_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 2147483656_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 268435583_32
  S2: state_counter = 2_10
  S2: val1 = 536870912_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 67113087_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134221951_32
  S4: state_counter = 4_10
  S4: val1 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 142606463_32
  S5: state_counter = 5_10
  S5: val1 = 0_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 183861651_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 268435456_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 175_32
  S8: rd_copy = 3_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1610612736_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073750016_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1048703_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 4271015295_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 149160063_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 2147483775_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4279992447_32
  S16: state_counter = 16_10
  S16: val1 = 1073743872_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 16777343_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 2982015_32
  S18: state_counter = 18_10
  S18: val1 = 1610612736_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1048703_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 134221951_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1073741824_32][11_5 := 1073741824_32][15_5 := 2097152_32][17_5 := 262144_32][23_5 := 1073741824_32][2_5 := 2147483648_32][5_5 := 1_32][8_5 := 1_32][9_5 := 65536_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for ADDI.vcd
  Test for ADDI using testing-workflow/bug-injection-patches/alu-bug-injected_1_ADDI.patch succeeded, CoSA found a counterexample as expected.

Operator name: ANDI
  Bug injection patch file for instruction ANDI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_ANDI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..ee4a54e 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -20,7 +20,7 @@ module alu(
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
-        `ALU_OP_AND : out = in1 & in2;
+        `ALU_OP_AND : out = in1 ^ in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		1.1 time, 480.2 real, 116.6 MB
[runlim] sample:		11.1 time, 490.2 real, 202.3 MB
[runlim] sample:		1.5 time, 500.2 real, 83.6 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ANDI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		11.5 time, 510.2 real, 456.9 MB
__[runlim] sample:		21.5 time, 520.2 real, 680.1 MB
___[runlim] sample:		31.4 time, 530.2 real, 820.7 MB
__[runlim] sample:		41.4 time, 540.2 real, 1077.1 MB
___[runlim] sample:		51.4 time, 550.2 real, 1341.9 MB
__[runlim] sample:		61.4 time, 560.2 real, 1564.7 MB
_[runlim] sample:		71.4 time, 570.2 real, 1811.7 MB
__[runlim] sample:		81.4 time, 580.2 real, 1905.7 MB
_[runlim] sample:		91.4 time, 590.2 real, 2066.1 MB
_[runlim] sample:		101.4 time, 600.2 real, 2177.0 MB
__.[runlim] sample:		111.4 time, 610.2 real, 2297.9 MB
.[runlim] sample:		121.4 time, 620.2 real, 2518.5 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for ANDI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 402657407_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 1_32][24_5 := 8404992_32][28_5 := 8388608_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 268464255_32
  S1: state_counter = 1_10
  S1: val1 = 2147483904_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 67113087_32
  S2: state_counter = 2_10
  S2: val1 = 0_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536875135_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 67113087_32
  S4: state_counter = 4_10
  S4: val1 = 1140850688_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1090519167_32
  S5: state_counter = 5_10
  S5: val1 = 2147483648_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 567047571_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 4194304_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 540_32
  S8: rd_copy = 11_5
  S8: state_counter = 8_10
  S8: val1 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 8405000_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1610612736_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 2114977919_32
  S11: state_counter = 11_10
  S11: val1 = 1073774592_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2115110783_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 268435456_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 1585807487_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 127_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1074331775_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 268439679_32
  S18: state_counter = 18_10
  S18: val1 = 1073741824_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1342181503_32
  S19: state_counter = 19_10
  S19: val1 = 536870912_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 536875135_32
  S20: state_counter = 20_10
  S20: val1 = 8404992_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 28799_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 8405532_32][16_5 := 1_32][24_5 := 8404992_32][28_5 := 8388608_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for ANDI.vcd
  Test for ANDI using testing-workflow/bug-injection-patches/alu-bug-injected_0_ANDI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction ANDI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_ANDI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..ec3f314 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -20,7 +20,7 @@ module alu(
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
-        `ALU_OP_AND : out = in1 & in2;
+        `ALU_OP_AND : out = in1 + in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
[runlim] sample:		0.0 time, 630.2 real, 12.5 MB
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		10.0 time, 640.2 real, 202.2 MB
[runlim] sample:		0.8 time, 650.2 real, 67.6 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ANDI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		10.8 time, 660.2 real, 462.7 MB
__[runlim] sample:		20.8 time, 670.2 real, 678.0 MB
___[runlim] sample:		30.8 time, 680.2 real, 903.1 MB
__[runlim] sample:		40.8 time, 690.2 real, 1079.5 MB
___[runlim] sample:		50.8 time, 700.2 real, 1318.2 MB
_[runlim] sample:		60.8 time, 710.2 real, 1464.6 MB
__[runlim] sample:		70.8 time, 720.2 real, 1800.6 MB
__[runlim] sample:		80.8 time, 730.2 real, 1949.9 MB
_[runlim] sample:		90.8 time, 740.2 real, 2127.3 MB
_[runlim] sample:		100.8 time, 750.2 real, 2171.5 MB
_[runlim] sample:		110.8 time, 760.2 real, 2372.4 MB
_..[runlim] sample:		120.8 time, 770.2 real, 2561.8 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for ANDI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 67113087_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 128_32][17_5 := 4194304_32][1_5 := 1_32][24_5 := 1073741840_32][9_5 := 4194304_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 536887296_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 134221951_32
  S2: state_counter = 2_10
  S2: val1 = 1073741824_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536875135_32
  S3: state_counter = 3_10
  S3: val1 = 16777216_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 671092863_32
  S4: state_counter = 4_10
  S4: val1 = 134217728_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554483_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 4279008275_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 4294967280_32
  S8: rd_copy = 24_5
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1074790400_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1074266112_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1074824319_32
  S11: state_counter = 11_10
  S11: val1 = 1073750016_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 1081983_32
  S12: state_counter = 12_10
  S12: val1 = 0_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073742975_32
  S13: state_counter = 13_10
  S13: val1 = 1073741824_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 4262461567_32
  S14: state_counter = 14_10
  S14: val1 = 0_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1107297407_32
  S15: state_counter = 15_10
  S15: val1 = 1073741840_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4267704447_32
  S16: state_counter = 16_10
  S16: val1 = 1075838976_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1073741832_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 8388735_32
  S18: state_counter = 18_10
  S18: val1 = 0_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 2097168_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 524415_32
  S20: state_counter = 20_10
  S20: val1 = 1073741840_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 28799_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 128_32][17_5 := 4194304_32][1_5 := 1_32][24_5 := 1073741824_32][9_5 := 4194304_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for ANDI.vcd
[runlim] sample:		130.8 time, 780.2 real, 2598.0 MB
  Test for ANDI using testing-workflow/bug-injection-patches/alu-bug-injected_1_ANDI.patch succeeded, CoSA found a counterexample as expected.

Operator name: ORI
  Bug injection patch file for instruction ORI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_ORI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..8b912a8 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -19,7 +19,7 @@ module alu(
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
-        `ALU_OP_OR : out = in1 | in2;
+        `ALU_OP_OR : out = in1 ^ in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		5.6 time, 790.2 real, 202.5 MB
[runlim] sample:		15.6 time, 800.2 real, 202.5 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction For ORI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.4 time, 810.2 real, 356.2 MB
__[runlim] sample:		16.4 time, 820.2 real, 536.7 MB
___[runlim] sample:		26.4 time, 830.2 real, 757.1 MB
__[runlim] sample:		36.4 time, 840.2 real, 1031.3 MB
__[runlim] sample:		46.4 time, 850.2 real, 1153.7 MB
__[runlim] sample:		56.4 time, 860.2 real, 1445.2 MB
__[runlim] sample:		66.3 time, 870.2 real, 1601.2 MB
__[runlim] sample:		76.3 time, 880.2 real, 1883.8 MB
__[runlim] sample:		86.3 time, 890.2 real, 2070.3 MB
_[runlim] sample:		96.3 time, 900.2 real, 2104.9 MB
_[runlim] sample:		106.3 time, 910.2 real, 2234.9 MB
_..[runlim] sample:		116.3 time, 920.2 real, 2432.0 MB
[runlim] sample:		126.3 time, 930.2 real, 2520.5 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction For ORI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 150999167_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 4_32][15_5 := 2147483648_32][1_5 := 2684354560_32][3_5 := 536870912_32][5_5 := 15_32][9_5 := 16_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 268464767_32
  S1: state_counter = 1_10

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875647_32
  S2: state_counter = 2_10
  S2: val1 = 134217728_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 134222463_32
  S3: state_counter = 3_10
  S3: val1 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875647_32
  S4: state_counter = 4_10
  S4: val1 = 268435456_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 134218367_32
  S5: state_counter = 5_10
  S5: val1 = 0_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1090520115_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 83026067_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 79_32
  S8: rd_copy = 1_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 128_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1107296256_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 41943167_32
  S11: state_counter = 11_10
  S11: val1 = 32_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2089847679_32
  S12: state_counter = 12_10
  S12: val1 = 12_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 134217728_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 360575_32
  S14: state_counter = 14_10
  S14: val1 = 2147483648_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 553648255_32
  S15: state_counter = 15_10
  S15: val1 = 1073741824_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1619558527_32
  S16: state_counter = 16_10
  S16: val1 = 0_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 570425471_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 168923263_32
  S18: state_counter = 18_10
  S18: val1 = 285212672_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 33558655_32
  S19: state_counter = 19_10
  S19: val1 = 4194304_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 536875135_32
  S20: state_counter = 20_10
  S20: val1 = 15_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 24703_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 4_32][15_5 := 2147483648_32][1_5 := 64_32][3_5 := 536870912_32][5_5 := 15_32][9_5 := 16_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction For ORI.vcd
[runlim] sample:		136.3 time, 940.2 real, 2023.4 MB
  Test for ORI using testing-workflow/bug-injection-patches/alu-bug-injected_1_ORI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction ORI:  testing-workflow/bug-injection-patches/alu-bug-injected_2_ORI.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..286657b 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -198,7 +198,7 @@ module decoder(
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
-        `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
+        `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_AND;
         default : alu_op_arith = `ALU_OP_ADD;
       endcase // case (funct3)
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		9.0 time, 950.2 real, 202.9 MB
[runlim] sample:		19.0 time, 960.2 real, 265.6 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction For ORI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		9.7 time, 970.2 real, 450.8 MB
___[runlim] sample:		19.7 time, 980.2 real, 623.7 MB
___[runlim] sample:		29.7 time, 990.2 real, 879.1 MB
__[runlim] sample:		39.6 time, 1000.2 real, 1073.3 MB
__[runlim] sample:		49.6 time, 1010.2 real, 1321.1 MB
__[runlim] sample:		59.6 time, 1020.2 real, 1512.6 MB
__[runlim] sample:		69.6 time, 1030.2 real, 1794.5 MB
__[runlim] sample:		79.6 time, 1040.2 real, 1985.2 MB
_[runlim] sample:		89.6 time, 1050.2 real, 2142.5 MB
__[runlim] sample:		99.6 time, 1060.2 real, 2236.0 MB
_.[runlim] sample:		109.6 time, 1070.2 real, 2389.1 MB
.[runlim] sample:		119.6 time, 1080.2 real, 2552.0 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction For ORI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 150999167_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[1_5 := 64_32][24_5 := 512_32][4_5 := 1073743888_32][5_5 := 3221223424_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 268464767_32
  S1: state_counter = 1_10

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 1074266112_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 67113087_32
  S3: state_counter = 3_10
  S3: val1 = 16777216_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134221951_32
  S4: state_counter = 4_10
  S4: val1 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1342177280_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554739_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 2172838419_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1610612736_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 4294965272_32
  S8: rd_copy = 4_5
  S8: state_counter = 8_10
  S8: val1 = 1090519048_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1090519040_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 268435584_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1074824319_32
  S11: state_counter = 11_10
  S11: val1 = 1140850688_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 4228940671_32
  S12: state_counter = 12_10
  S12: val1 = 4261279744_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073743743_32
  S13: state_counter = 13_10
  S13: val1 = 262144_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 4261413759_32
  S14: state_counter = 14_10
  S14: val1 = 2147481604_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 4228908159_32
  S15: state_counter = 15_10
  S15: val1 = 1107296256_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4228907135_32
  S16: state_counter = 16_10
  S16: val1 = 134217728_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1610612736_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 13631615_32
  S18: state_counter = 18_10
  S18: val1 = 3221094400_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 3221225488_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 3221223424_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 536895615_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 67113087_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[1_5 := 64_32][24_5 := 512_32][4_5 := 1073741848_32][5_5 := 3221223424_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction For ORI.vcd
[runlim] sample:		129.6 time, 1090.2 real, 2466.9 MB
  Test for ORI using testing-workflow/bug-injection-patches/alu-bug-injected_2_ORI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction ORI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_ORI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..9893173 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -19,7 +19,7 @@ module alu(
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
-        `ALU_OP_OR : out = in1 | in2;
+        `ALU_OP_OR : out = in1 & in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		7.8 time, 1100.2 real, 202.7 MB
[runlim] sample:		17.8 time, 1110.2 real, 266.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction For ORI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		8.6 time, 1120.2 real, 357.6 MB
___[runlim] sample:		18.6 time, 1130.2 real, 598.6 MB
__[runlim] sample:		28.6 time, 1140.2 real, 800.1 MB
___[runlim] sample:		38.5 time, 1150.2 real, 1039.8 MB
__[runlim] sample:		48.5 time, 1160.2 real, 1252.9 MB
__[runlim] sample:		58.5 time, 1170.2 real, 1490.8 MB
__[runlim] sample:		68.5 time, 1180.2 real, 1724.6 MB
__[runlim] sample:		78.5 time, 1190.2 real, 1903.4 MB
_[runlim] sample:		88.5 time, 1200.2 real, 2087.2 MB
_[runlim] sample:		98.5 time, 1210.2 real, 2151.1 MB
_[runlim] sample:		108.5 time, 1220.2 real, 2321.8 MB
_..[runlim] sample:		118.5 time, 1230.2 real, 2501.7 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction For ORI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 268435583_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 16_32][1_5 := 4_32][30_5 := 2147483648_32][31_5 := 3221225472_32][4_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 402681983_32
  S1: state_counter = 1_10
  S1: val1 = 2147500032_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147516543_32
  S2: state_counter = 2_10
  S2: val1 = 1048576_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536907903_32
  S3: state_counter = 3_10
  S3: val1 = 536870912_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147516543_32
  S4: state_counter = 4_10
  S4: val1 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 134250623_32
  S5: state_counter = 5_10
  S5: val1 = 8388608_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 569533459_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 543_32
  S8: rd_copy = 8_5
  S8: state_counter = 8_10
  S8: val1 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073758208_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 0_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 127_32
  S11: state_counter = 11_10
  S11: val1 = 1073807360_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2126516095_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 9470079_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 127_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1074528383_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 16777343_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 4223_32
  S18: state_counter = 18_10
  S18: val1 = 1342177280_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 33558655_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 2147487871_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 134242431_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 150999167_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction For ORI.vcd
[runlim] sample:		128.5 time, 1240.2 real, 2552.8 MB
  Test for ORI using testing-workflow/bug-injection-patches/alu-bug-injected_0_ORI.patch succeeded, CoSA found a counterexample as expected.

Operator name: XORI
  Bug injection patch file for instruction XORI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_XORI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..b1154a3 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -18,7 +18,7 @@ module alu(
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
-        `ALU_OP_XOR : out = in1 ^ in2;
+        `ALU_OP_XOR : out = in1 | in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		5.2 time, 1250.2 real, 206.2 MB
[runlim] sample:		15.2 time, 1260.2 real, 202.3 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for XORI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		5.9 time, 1270.2 real, 339.6 MB
__[runlim] sample:		15.9 time, 1280.2 real, 535.9 MB
___[runlim] sample:		25.9 time, 1290.2 real, 747.5 MB
__[runlim] sample:		35.9 time, 1300.2 real, 1031.7 MB
__[runlim] sample:		45.9 time, 1310.2 real, 1144.9 MB
__[runlim] sample:		55.8 time, 1320.2 real, 1445.6 MB
__[runlim] sample:		65.8 time, 1330.2 real, 1603.7 MB
__[runlim] sample:		75.8 time, 1340.2 real, 1876.5 MB
_[runlim] sample:		85.8 time, 1350.2 real, 2028.6 MB
_[runlim] sample:		95.8 time, 1360.2 real, 2061.0 MB
_[runlim] sample:		105.8 time, 1370.2 real, 2208.0 MB
_[runlim] sample:		115.8 time, 1380.2 real, 2357.9 MB
_..[runlim] sample:		125.8 time, 1390.2 real, 2501.7 MB
[runlim] sample:		135.8 time, 1400.2 real, 2585.3 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for XORI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 268451967_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 2097152_32][16_5 := 3221225472_32][1_5 := 8388608_32][3_5 := 8388608_32][4_5 := 536870912_32][5_5 := 544_32][6_5 := 536870912_32][7_5 := 16_32][8_5 := 8388608_32][9_5 := 262144_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2415947903_32
  S1: state_counter = 1_10
  S1: val1 = 2147487744_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2148008063_32
  S2: state_counter = 2_10
  S2: val1 = 67108864_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536875135_32
  S3: state_counter = 3_10
  S3: val1 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147487871_32
  S4: state_counter = 4_10
  S4: val1 = 536870912_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 67108991_32
  S5: state_counter = 5_10
  S5: val1 = 134217728_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 3221225472_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 2162311571_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 4294965262_32
  S8: rd_copy = 3_5
  S8: state_counter = 8_10
  S8: val1 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 536903680_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1107296256_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 17956991_32
  S11: state_counter = 11_10
  S11: val1 = 1082130432_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 3700591743_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 2097279_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 15958143_32
  S14: state_counter = 14_10
  S14: val1 = 536870912_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 553648255_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 319029375_32
  S16: state_counter = 16_10
  S16: val1 = 536870912_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 34078847_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 10846335_32
  S18: state_counter = 18_10
  S18: val1 = 536872960_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1610612736_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 536870912_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 8405119_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1073746047_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 2097152_32][16_5 := 3221225472_32][1_5 := 8388608_32][3_5 := 4294965262_32][4_5 := 536870912_32][5_5 := 544_32][6_5 := 536870912_32][7_5 := 16_32][8_5 := 8388608_32][9_5 := 262144_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for XORI.vcd
  Test for XORI using testing-workflow/bug-injection-patches/alu-bug-injected_1_XORI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction XORI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_XORI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..82173e1 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -18,7 +18,7 @@ module alu(
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
-        `ALU_OP_XOR : out = in1 ^ in2;
+        `ALU_OP_XOR : out = in1 + in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		3.5 time, 1410.2 real, 192.6 MB
[runlim] sample:		13.5 time, 1420.2 real, 202.7 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for XORI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		3.9 time, 1430.2 real, 252.2 MB
_[runlim] sample:		13.9 time, 1440.2 real, 519.4 MB
___[runlim] sample:		23.9 time, 1450.2 real, 707.7 MB
___[runlim] sample:		33.9 time, 1460.2 real, 982.0 MB
__[runlim] sample:		43.9 time, 1470.2 real, 1125.5 MB
__[runlim] sample:		53.9 time, 1480.2 real, 1446.9 MB
__[runlim] sample:		63.9 time, 1490.2 real, 1605.2 MB
__[runlim] sample:		73.9 time, 1500.2 real, 1852.9 MB
_[runlim] sample:		83.9 time, 1510.2 real, 1966.0 MB
_[runlim] sample:		93.8 time, 1520.2 real, 2070.6 MB
_[runlim] sample:		103.8 time, 1530.2 real, 2161.3 MB
_[runlim] sample:		113.8 time, 1540.2 real, 2347.5 MB
_..[runlim] sample:		123.8 time, 1550.2 real, 2554.1 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for XORI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 2684371071_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 128_32][1_5 := 1073741824_32][24_5 := 524288_32][28_5 := 1073807232_32][30_5 := 1207959552_32][5_5 := 1073741824_32][8_5 := 536870912_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 2147483656_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 67113087_32
  S2: state_counter = 2_10
  S2: val1 = 4194304_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 1140850688_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268439679_32
  S4: state_counter = 4_10
  S4: val1 = 1073741824_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 134221951_32
  S5: state_counter = 5_10
  S5: val1 = 16777216_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 136204051_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 129_32
  S8: rd_copy = 30_5
  S8: state_counter = 8_10
  S8: val1 = 1075052544_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1074790400_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073807234_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 131199_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 8556415_32
  S12: state_counter = 12_10
  S12: val1 = 1073803328_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 127_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 4186275967_32
  S14: state_counter = 14_10
  S14: val1 = 1073807232_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 4194431_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4263642239_32
  S16: state_counter = 16_10
  S16: val1 = 1073803264_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 32895_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 4270882943_32
  S18: state_counter = 18_10
  S18: val1 = 269484032_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 130958_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 4294967295_32
  S20: state_counter = 20_10
  S20: val1 = 1073807232_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073742975_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 127_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 128_32][1_5 := 1073741824_32][24_5 := 524288_32][28_5 := 1073807232_32][30_5 := 1073807361_32][5_5 := 1073741824_32][8_5 := 536870912_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for XORI.vcd
[runlim] sample:		133.8 time, 1560.2 real, 2486.5 MB
  Test for XORI using testing-workflow/bug-injection-patches/alu-bug-injected_0_XORI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction XORI:  testing-workflow/bug-injection-patches/alu-bug-injected_2_XORI.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..572eac7 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -196,7 +196,7 @@ module decoder(
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
-        `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
+        `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_OR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
         `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
         `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_AND;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		6.0 time, 1570.2 real, 202.9 MB
[runlim] sample:		16.0 time, 1580.2 real, 202.9 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for XORI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.5 time, 1590.2 real, 357.1 MB
__[runlim] sample:		16.5 time, 1600.2 real, 534.4 MB
___[runlim] sample:		26.5 time, 1610.2 real, 758.3 MB
___[runlim] sample:		36.5 time, 1620.2 real, 1065.3 MB
__[runlim] sample:		46.5 time, 1630.2 real, 1266.0 MB
__[runlim] sample:		56.5 time, 1640.2 real, 1463.2 MB
_[runlim] sample:		66.5 time, 1650.2 real, 1649.5 MB
__[runlim] sample:		76.5 time, 1660.2 real, 1832.7 MB
_[runlim] sample:		86.5 time, 1670.2 real, 1992.3 MB
__[runlim] sample:		96.5 time, 1680.2 real, 2177.0 MB
_[runlim] sample:		106.5 time, 1690.2 real, 2252.3 MB
_..[runlim] sample:		116.5 time, 1700.2 real, 2484.1 MB
[runlim] sample:		126.5 time, 1710.2 real, 2595.3 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for XORI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 2147500159_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 4194304_32][17_5 := 8192_32][30_5 := 1073750032_32][9_5 := 4194336_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 67137663_32
  S1: state_counter = 1_10
  S1: val1 = 1073758208_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147487871_32
  S2: state_counter = 2_10
  S2: val1 = 524288_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 134221951_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554483_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 17779731_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 16_32
  S8: rd_copy = 24_5
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073741824_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 0_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1075086463_32
  S11: state_counter = 11_10
  S11: val1 = 1073741824_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2081721983_32
  S12: state_counter = 12_10
  S12: val1 = 0_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073742975_32
  S13: state_counter = 13_10
  S13: val1 = 1073741824_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2147483775_32
  S14: state_counter = 14_10
  S14: val1 = 0_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073742975_32
  S15: state_counter = 15_10
  S15: val1 = 1073741824_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262461567_32
  S16: state_counter = 16_10
  S16: val1 = 0_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1075838976_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 127_32
  S18: state_counter = 18_10
  S18: val1 = 1073807360_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1074798592_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 8388735_32
  S20: state_counter = 20_10
  S20: val1 = 1073750032_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 16511_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 4194304_32][17_5 := 8192_32][24_5 := 1073750032_32][30_5 := 1073750032_32][9_5 := 4194336_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for XORI.vcd
  Test for XORI using testing-workflow/bug-injection-patches/alu-bug-injected_2_XORI.patch succeeded, CoSA found a counterexample as expected.

Operator name: SLLI
  Bug injection patch file for instruction SLLI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SLLI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..65dc0d2 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -17,7 +17,7 @@ module alu(
    always @(*) begin
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
-        `ALU_OP_SLL : out = in1 << shamt;
+        `ALU_OP_SLL : out = in1 + shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		2.4 time, 1720.2 real, 194.1 MB
[runlim] sample:		12.3 time, 1730.2 real, 202.7 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLLI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		3.0 time, 1740.2 real, 143.3 MB
_[runlim] sample:		12.9 time, 1750.2 real, 473.1 MB
___[runlim] sample:		22.9 time, 1760.2 real, 693.9 MB
__[runlim] sample:		32.9 time, 1770.2 real, 855.9 MB
___[runlim] sample:		42.9 time, 1780.2 real, 1106.4 MB
__[runlim] sample:		52.9 time, 1790.2 real, 1358.0 MB
__[runlim] sample:		62.9 time, 1800.2 real, 1551.4 MB
_[runlim] sample:		72.9 time, 1810.2 real, 1819.7 MB
_[runlim] sample:		82.9 time, 1820.2 real, 1862.4 MB
__[runlim] sample:		92.9 time, 1830.2 real, 2079.3 MB
_[runlim] sample:		102.9 time, 1840.2 real, 2170.9 MB
_[runlim] sample:		112.9 time, 1850.2 real, 2280.1 MB
_..[runlim] sample:		122.9 time, 1860.2 real, 2429.4 MB
[runlim] sample:		132.9 time, 1870.2 real, 2569.1 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLLI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2147487871_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2097153_32][14_5 := 58719239_32][16_5 := 58196076_32][24_5 := 58196094_32][8_5 := 1075838977_32][9_5 := 16777216_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 1073746047_32
  S1: state_counter = 1_10

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147487871_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 67113087_32
  S3: state_counter = 3_10
  S3: val1 = 268435456_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134221951_32
  S4: state_counter = 4_10
  S4: val1 = 0_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 2147487871_32
  S5: state_counter = 5_10
  S5: val1 = 536870912_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 15473683_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 24_5
  S8: shimm_copy = 14_32
  S8: state_counter = 8_10
  S8: val1 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 58195970_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 26673279_32
  S11: state_counter = 11_10
  S11: val1 = 56623104_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 1083640703_32
  S12: state_counter = 12_10
  S12: val1 = 1207959552_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1048831_32
  S13: state_counter = 13_10
  S13: val1 = 134217728_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2024539263_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16778495_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1082392703_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 2147487999_32
  S18: state_counter = 18_10
  S18: val1 = 2147483649_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 3221229695_32
  S19: state_counter = 19_10
  S19: val1 = 2147483648_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 285216895_32
  S20: state_counter = 20_10
  S20: val1 = 58196094_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 268439679_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 269488255_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2097153_32][14_5 := 58719239_32][16_5 := 58196076_32][24_5 := 58196108_32][8_5 := 1075838977_32][9_5 := 16777216_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLLI.vcd
  Test for SLLI using testing-workflow/bug-injection-patches/alu-bug-injected_0_SLLI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLLI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SLLI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..c887d05 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -17,7 +17,7 @@ module alu(
    always @(*) begin
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
-        `ALU_OP_SLL : out = in1 << shamt;
+        `ALU_OP_SLL : out = in1 ^ shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		3.7 time, 1880.2 real, 191.8 MB
[runlim] sample:		13.7 time, 1890.2 real, 201.9 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLLI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		4.4 time, 1900.2 real, 248.8 MB
_[runlim] sample:		14.4 time, 1910.2 real, 523.3 MB
___[runlim] sample:		24.4 time, 1920.2 real, 698.3 MB
___[runlim] sample:		34.4 time, 1930.2 real, 973.2 MB
__[runlim] sample:		44.4 time, 1940.2 real, 1086.3 MB
__[runlim] sample:		54.4 time, 1950.2 real, 1399.2 MB
__[runlim] sample:		64.3 time, 1960.2 real, 1530.5 MB
_[runlim] sample:		74.3 time, 1970.2 real, 1815.7 MB
__[runlim] sample:		84.3 time, 1980.2 real, 1997.8 MB
__[runlim] sample:		94.3 time, 1990.2 real, 2213.6 MB
_[runlim] sample:		104.3 time, 2000.2 real, 2236.1 MB
_.[runlim] sample:		114.3 time, 2010.2 real, 2421.1 MB
.[runlim] sample:		124.3 time, 2020.2 real, 2516.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLLI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 536871039_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 1048639_32][17_5 := 1048639_32][18_5 := 1048635_32][1_5 := 1048576_32][24_5 := 1048632_32][26_5 := 2147483648_32][28_5 := 1073741824_32][8_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 603983999_32
  S1: state_counter = 1_10
  S1: val1 = 2147483648_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 138936447_32
  S2: state_counter = 2_10
  S2: val1 = 1610612736_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 147329151_32
  S3: state_counter = 3_10
  S3: val1 = 3222274048_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1077937279_32
  S4: state_counter = 4_10
  S4: val1 = 0_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 3221225472_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 639_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 17571347_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 3221225472_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 28_5
  S8: shimm_copy = 16_32
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3221225472_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 17825792_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1073742975_32
  S11: state_counter = 11_10
  S11: val1 = 1073741880_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2122320255_32
  S12: state_counter = 12_10
  S12: val1 = 0_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073742975_32
  S13: state_counter = 13_10
  S13: val1 = 1048632_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 127_32
  S14: state_counter = 14_10
  S14: val1 = 536870912_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073742975_32
  S15: state_counter = 15_10
  S15: val1 = 1048576_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4279042175_32
  S16: state_counter = 16_10
  S16: val1 = 2147483648_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1048632_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 18776191_32
  S18: state_counter = 18_10
  S18: val1 = 268435456_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 536870928_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1048632_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 2147487871_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 134230143_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 1048639_32][17_5 := 1048639_32][18_5 := 1048635_32][1_5 := 1048576_32][24_5 := 1048632_32][26_5 := 2147483648_32][28_5 := 1048616_32][8_5 := 2147483648_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLLI.vcd
[runlim] sample:		134.3 time, 2030.2 real, 2455.7 MB
  Test for SLLI using testing-workflow/bug-injection-patches/alu-bug-injected_1_SLLI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLLI:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SLLI.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..84297bb 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -193,7 +193,7 @@ module decoder(
    always @(*) begin
       case (funct3)
         `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
-        `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
+        `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		6.7 time, 2040.2 real, 202.7 MB
[runlim] sample:		16.6 time, 2050.2 real, 202.7 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLLI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		7.2 time, 2060.2 real, 357.5 MB
__[runlim] sample:		17.2 time, 2070.2 real, 542.2 MB
___[runlim] sample:		27.2 time, 2080.2 real, 743.9 MB
__[runlim] sample:		37.2 time, 2090.2 real, 998.3 MB
__[runlim] sample:		47.2 time, 2100.2 real, 1151.6 MB
___[runlim] sample:		57.2 time, 2110.2 real, 1462.6 MB
_[runlim] sample:		67.2 time, 2120.2 real, 1605.0 MB
__[runlim] sample:		77.2 time, 2130.2 real, 1839.8 MB
__[runlim] sample:		87.2 time, 2140.2 real, 2067.6 MB
_[runlim] sample:		97.2 time, 2150.2 real, 2104.0 MB
_[runlim] sample:		107.2 time, 2160.2 real, 2308.7 MB
_..[runlim] sample:		117.2 time, 2170.2 real, 2409.0 MB
[runlim] sample:		127.2 time, 2180.2 real, 2536.8 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLLI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 537399423_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 16384_32][2_5 := 2147483648_32][4_5 := 1073741838_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 536875135_32
  S1: state_counter = 1_10
  S1: val1 = 134217728_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 268439679_32
  S2: state_counter = 2_10
  S2: val1 = 67108864_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 1342177280_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1075840127_32
  S4: state_counter = 4_10
  S4: val1 = 32768_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1090520191_32
  S5: state_counter = 5_10
  S5: val1 = 1610612736_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 14818579_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 536870912_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 26_5
  S8: shimm_copy = 14_32
  S8: state_counter = 8_10
  S8: val1 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1074003968_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741836_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 8388735_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2126515327_32
  S12: state_counter = 12_10
  S12: val1 = 1073741838_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 17301631_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 12583039_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 127_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 2097279_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 4194431_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1074005119_32
  S18: state_counter = 18_10
  S18: val1 = 1073741836_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 127_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 1073746047_32
  S20: state_counter = 20_10
  S20: val1 = 1073741838_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 4223_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 16384_32][26_5 := 1073741824_32][2_5 := 2147483648_32][4_5 := 1073741838_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLLI.vcd
  Test for SLLI using testing-workflow/bug-injection-patches/alu-bug-injected_2_SLLI.patch succeeded, CoSA found a counterexample as expected.

Operator name: SRLI
  Bug injection patch file for instruction SRLI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SRLI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..e8e3c76 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -21,7 +21,7 @@ module alu(
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
-        `ALU_OP_SRL : out = in1 >> shamt;
+        `ALU_OP_SRL : out = in1 << shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		2.1 time, 2190.2 real, 169.6 MB
[runlim] sample:		12.1 time, 2200.2 real, 202.2 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRLI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		2.8 time, 2210.2 real, 127.9 MB
_[runlim] sample:		12.8 time, 2220.2 real, 484.1 MB
___[runlim] sample:		22.8 time, 2230.2 real, 684.2 MB
__[runlim] sample:		32.8 time, 2240.2 real, 978.4 MB
___[runlim] sample:		42.8 time, 2250.2 real, 1099.2 MB
__[runlim] sample:		52.8 time, 2260.2 real, 1399.7 MB
__[runlim] sample:		62.8 time, 2270.2 real, 1521.5 MB
__[runlim] sample:		72.8 time, 2280.2 real, 1828.1 MB
_[runlim] sample:		82.8 time, 2290.2 real, 1989.9 MB
_[runlim] sample:		92.8 time, 2300.2 real, 2120.3 MB
__[runlim] sample:		102.8 time, 2310.2 real, 2222.1 MB
_.[runlim] sample:		112.8 time, 2320.2 real, 2414.3 MB
.[runlim] sample:		122.7 time, 2330.2 real, 2551.5 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRLI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2164281471_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 1073741824_32][16_5 := 16_32][1_5 := 549453825_32][4_5 := 17825792_32][9_5 := 817889280_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 1073750016_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2214596735_32
  S2: state_counter = 2_10
  S2: val1 = 0_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2148532351_32
  S3: state_counter = 3_10
  S3: val1 = 1075838976_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 3221226623_32
  S4: state_counter = 4_10
  S4: val1 = 0_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 2147484799_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1342177280_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1200659_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 4_5
  S8: shimm_copy = 1_32
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1342177280_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 3221225472_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1073742975_32
  S11: state_counter = 11_10
  S11: val1 = 1073745920_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 3711_32
  S12: state_counter = 12_10
  S12: val1 = 131072_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073742975_32
  S13: state_counter = 13_10
  S13: val1 = 3221225472_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 1573759_32
  S14: state_counter = 14_10
  S14: val1 = 17829888_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073743743_32
  S15: state_counter = 15_10
  S15: val1 = 1209008128_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262461567_32
  S16: state_counter = 16_10
  S16: val1 = 1207960064_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 268436735_32
  S17: state_counter = 17_10
  S17: val1 = 1207959553_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1074135167_32
  S18: state_counter = 18_10
  S18: val1 = 1073741825_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1073741824_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 16777343_32
  S20: state_counter = 20_10
  S20: val1 = 17825792_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 20607_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1073746047_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 1073741824_32][16_5 := 16_32][1_5 := 549453825_32][4_5 := 35651584_32][9_5 := 817889280_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRLI.vcd
[runlim] sample:		132.7 time, 2340.2 real, 2484.7 MB
  Test for SRLI using testing-workflow/bug-injection-patches/alu-bug-injected_0_SRLI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SRLI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SRLI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..0f3e333 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -21,7 +21,7 @@ module alu(
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
-        `ALU_OP_SRL : out = in1 >> shamt;
+        `ALU_OP_SRL : out = in1 | shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		7.6 time, 2350.2 real, 202.6 MB
[runlim] sample:		17.6 time, 2360.2 real, 264.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRLI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		8.4 time, 2370.2 real, 357.6 MB
___[runlim] sample:		18.4 time, 2380.2 real, 596.9 MB
__[runlim] sample:		28.4 time, 2390.2 real, 785.0 MB
___[runlim] sample:		38.4 time, 2400.2 real, 1017.7 MB
__[runlim] sample:		48.4 time, 2410.2 real, 1243.6 MB
__[runlim] sample:		58.4 time, 2420.2 real, 1480.0 MB
__[runlim] sample:		68.3 time, 2430.2 real, 1634.4 MB
_[runlim] sample:		78.3 time, 2440.2 real, 1887.1 MB
__[runlim] sample:		88.3 time, 2450.2 real, 2092.5 MB
_[runlim] sample:		98.3 time, 2460.2 real, 2166.4 MB
_[runlim] sample:		108.3 time, 2470.2 real, 2282.4 MB
_..[runlim] sample:		118.3 time, 2480.2 real, 2502.5 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRLI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 537415807_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 32_32][14_5 := 288_32][1_5 := 131104_32][4_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 536875135_32
  S1: state_counter = 1_10
  S1: val1 = 2147483648_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 134221951_32
  S2: state_counter = 2_10
  S2: val1 = 134217728_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 268435456_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 270537087_32
  S5: state_counter = 5_10
  S5: val1 = 2164260864_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 14834963_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 26_5
  S8: shimm_copy = 14_32
  S8: state_counter = 8_10
  S8: val1 = 1207959552_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073774592_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 16810111_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 616599167_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2122350719_32
  S14: state_counter = 14_10
  S14: val1 = 4194304_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1101856895_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 5248383_32
  S18: state_counter = 18_10
  S18: val1 = 268435456_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 33558655_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 268439807_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 20607_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1107300479_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 32_32][14_5 := 288_32][1_5 := 131104_32][26_5 := 1073741838_32][4_5 := 1073741824_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRLI.vcd
[runlim] sample:		128.3 time, 2490.2 real, 2433.5 MB
  Test for SRLI using testing-workflow/bug-injection-patches/alu-bug-injected_1_SRLI.patch succeeded, CoSA found a counterexample as expected.

Operator name: SRAI
  Bug injection patch file for instruction SRAI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SRAI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..75c5655 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -25,7 +25,7 @@ module alu(
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
-        `ALU_OP_SRA : out = $signed(in1) >>> shamt;
+        `ALU_OP_SRA : out = $signed(in1) << shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		7.8 time, 2500.2 real, 202.2 MB
[runlim] sample:		17.8 time, 2510.2 real, 267.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRAI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		8.6 time, 2520.2 real, 357.3 MB
___[runlim] sample:		18.6 time, 2530.2 real, 624.8 MB
__[runlim] sample:		28.6 time, 2540.2 real, 808.4 MB
___[runlim] sample:		38.6 time, 2550.2 real, 1017.9 MB
__[runlim] sample:		48.6 time, 2560.2 real, 1261.0 MB
__[runlim] sample:		58.6 time, 2570.2 real, 1539.8 MB
__[runlim] sample:		68.6 time, 2580.2 real, 1633.4 MB
__[runlim] sample:		78.6 time, 2590.2 real, 1901.6 MB
_[runlim] sample:		88.5 time, 2600.2 real, 2076.4 MB
_[runlim] sample:		98.5 time, 2610.2 real, 2233.7 MB
_[runlim] sample:		108.5 time, 2620.2 real, 2313.7 MB
_.[runlim] sample:		118.5 time, 2630.2 real, 2396.7 MB
.[runlim] sample:		128.5 time, 2640.2 real, 2528.8 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRAI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 1073762431_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[15_5 := 2147483648_32][16_5 := 1073741824_32][18_5 := 1073741825_32][24_5 := 536870912_32][2_5 := 1_32][4_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 536875135_32
  S1: state_counter = 1_10

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 134221951_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 2181038080_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268439679_32
  S4: state_counter = 4_10
  S4: val1 = 2214592512_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 285214847_32
  S5: state_counter = 5_10
  S5: val1 = 0_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1090520115_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1078483347_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 19_5
  S8: shimm_copy = 4_32
  S8: state_counter = 8_10
  S8: val1 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1077936128_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073774592_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 22184063_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2119664639_32
  S12: state_counter = 12_10
  S12: val1 = 1073807360_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 18874495_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 11075711_32
  S14: state_counter = 14_10
  S14: val1 = 1073742080_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 524415_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 3014783_32
  S16: state_counter = 16_10
  S16: val1 = 1073807360_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 16777343_32
  S17: state_counter = 17_10
  S17: val1 = 1073742336_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1101431935_32
  S18: state_counter = 18_10
  S18: val1 = 1073741824_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 127_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 536875135_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073762431_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 268439679_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRAI.vcd
  Test for SRAI using testing-workflow/bug-injection-patches/alu-bug-injected_1_SRAI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SRAI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SRAI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..75c5655 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -25,7 +25,7 @@ module alu(
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
-        `ALU_OP_SRA : out = $signed(in1) >>> shamt;
+        `ALU_OP_SRA : out = $signed(in1) << shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		2.0 time, 2650.2 real, 164.2 MB
[runlim] sample:		12.1 time, 2660.2 real, 202.6 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRAI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		2.7 time, 2670.2 real, 96.2 MB
_[runlim] sample:		12.7 time, 2680.2 real, 472.8 MB
___[runlim] sample:		22.7 time, 2690.2 real, 686.1 MB
__[runlim] sample:		32.7 time, 2700.2 real, 841.0 MB
___[runlim] sample:		42.7 time, 2710.2 real, 1119.6 MB
__[runlim] sample:		52.7 time, 2720.2 real, 1396.7 MB
__[runlim] sample:		62.7 time, 2730.2 real, 1579.7 MB
_[runlim] sample:		72.7 time, 2740.2 real, 1833.9 MB
__[runlim] sample:		82.7 time, 2750.2 real, 1895.8 MB
_[runlim] sample:		92.7 time, 2760.2 real, 2079.0 MB
_[runlim] sample:		102.7 time, 2770.2 real, 2149.2 MB
_[runlim] sample:		112.6 time, 2780.2 real, 2308.8 MB
_..[runlim] sample:		122.6 time, 2790.2 real, 2514.9 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRAI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 1073762431_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1073741856_32][13_5 := 1073741824_32][3_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 2147745792_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 67113087_32
  S2: state_counter = 2_10
  S2: val1 = 1073741824_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536871039_32
  S3: state_counter = 3_10
  S3: val1 = 1140850688_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147487871_32
  S4: state_counter = 4_10
  S4: val1 = 16777216_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1077937279_32
  S5: state_counter = 5_10
  S5: val1 = 1610612736_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1084676115_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 16_5
  S8: shimm_copy = 10_32
  S8: state_counter = 8_10
  S8: val1 = 3221225472_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1074266112_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1179775_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 383_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 17039487_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 8913023_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 3221225599_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 537003135_32
  S16: state_counter = 16_10
  S16: val1 = 67108864_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 570691711_32
  S18: state_counter = 18_10
  S18: val1 = 67108864_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 33558655_32
  S19: state_counter = 19_10
  S19: val1 = 1073745920_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 1082134655_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073762431_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 67113087_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRAI.vcd
[runlim] sample:		132.6 time, 2800.2 real, 2138.2 MB
  Test for SRAI using testing-workflow/bug-injection-patches/alu-bug-injected_0_SRAI.patch succeeded, CoSA found a counterexample as expected.

Operator name: SLTIU
  Bug injection patch file for instruction SLTIU:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SLTIU.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..3d6e5bd 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -28,7 +28,7 @@ module alu(
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
-        `ALU_OP_SLTU : out = {31'b0, in1 < in2};
+        `ALU_OP_SLTU : out = {31'b0, in1 > in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
         default : out = 0;
       endcase // case op
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		8.0 time, 2810.2 real, 202.8 MB
[runlim] sample:		18.0 time, 2820.2 real, 269.9 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTIU" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		8.4 time, 2830.2 real, 357.5 MB
___[runlim] sample:		18.4 time, 2840.2 real, 595.7 MB
__[runlim] sample:		28.4 time, 2850.2 real, 796.8 MB
___[runlim] sample:		38.4 time, 2860.2 real, 1076.0 MB
__[runlim] sample:		48.4 time, 2870.2 real, 1315.6 MB
__[runlim] sample:		58.4 time, 2880.2 real, 1557.3 MB
__[runlim] sample:		68.4 time, 2890.2 real, 1838.2 MB
_[runlim] sample:		78.4 time, 2900.2 real, 1945.5 MB
__[runlim] sample:		88.4 time, 2910.2 real, 2036.5 MB
_[runlim] sample:		98.3 time, 2920.2 real, 2170.1 MB
_[runlim] sample:		108.3 time, 2930.2 real, 2350.0 MB
_..[runlim] sample:		118.3 time, 2940.2 real, 2680.4 MB
[runlim] sample:		128.3 time, 2950.2 real, 2541.3 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTIU **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 33583231_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 1073741824_32][1_5 := 1073741856_32][24_5 := 2147483648_32][28_5 := 1073741824_32][4_5 := 2_32][5_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 536875391_32
  S1: state_counter = 1_10
  S1: val1 = 143654913_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147487871_32
  S2: state_counter = 2_10
  S2: val1 = 268435456_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2164265087_32
  S3: state_counter = 3_10
  S3: val1 = 16777216_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1082131583_32
  S4: state_counter = 4_10
  S4: val1 = 1207959552_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 4202531_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 2172827667_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 4294965272_32
  S8: rd_copy = 16_5
  S8: state_counter = 8_10
  S8: val1 = 536870912_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 0_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1082130432_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1082131583_32
  S11: state_counter = 11_10
  S11: val1 = 1073774592_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 1015058047_32
  S12: state_counter = 12_10
  S12: val1 = 0_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073743487_32
  S13: state_counter = 13_10
  S13: val1 = 1073741824_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 4265640831_32
  S14: state_counter = 14_10
  S14: val1 = 0_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1407_32
  S15: state_counter = 15_10
  S15: val1 = 1073741824_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4290773119_32
  S16: state_counter = 16_10
  S16: val1 = 8388608_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1049727_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 262271_32
  S18: state_counter = 18_10
  S18: val1 = 1209008128_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1207959552_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 16777343_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 12415_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1073746047_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[1_5 := 1073741856_32][24_5 := 2147483648_32][28_5 := 1073741824_32][4_5 := 2_32][5_5 := 1073741824_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTIU.vcd
  Test for SLTIU using testing-workflow/bug-injection-patches/alu-bug-injected_0_SLTIU.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLTIU:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SLTIU.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..0b6c2e8 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -195,7 +195,7 @@ module decoder(
         `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
-        `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
+        `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
         `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		2.1 time, 2960.2 real, 169.9 MB
[runlim] sample:		12.1 time, 2970.2 real, 202.7 MB
[runlim] sample:		2.5 time, 2980.2 real, 98.2 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTIU" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		12.5 time, 2990.2 real, 472.4 MB
___[runlim] sample:		22.5 time, 3000.2 real, 695.5 MB
__[runlim] sample:		32.5 time, 3010.2 real, 962.8 MB
___[runlim] sample:		42.5 time, 3020.2 real, 1122.6 MB
__[runlim] sample:		52.5 time, 3030.2 real, 1441.3 MB
__[runlim] sample:		62.5 time, 3040.2 real, 1577.1 MB
_[runlim] sample:		72.4 time, 3050.2 real, 1819.8 MB
__[runlim] sample:		82.4 time, 3060.2 real, 1917.3 MB
_[runlim] sample:		92.4 time, 3070.2 real, 2063.5 MB
_[runlim] sample:		102.4 time, 3080.2 real, 2147.4 MB
_[runlim] sample:		112.4 time, 3090.2 real, 2351.4 MB
_..[runlim] sample:		122.4 time, 3100.2 real, 2542.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTIU **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 335564927_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 3221747839_32][1_5 := 1073217536_32][31_5 := 2147483648_32][5_5 := 2147483648_32][8_5 := 536870912_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 268439679_32
  S1: state_counter = 1_10
  S1: val1 = 536875008_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147487871_32
  S2: state_counter = 2_10
  S2: val1 = 268435456_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 3221225472_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147487871_32
  S4: state_counter = 4_10
  S4: val1 = 134217728_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 536871039_32
  S5: state_counter = 5_10
  S5: val1 = 2147483648_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 2281025683_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 4294965375_32
  S8: rd_copy = 1_5
  S8: state_counter = 8_10
  S8: val1 = 1677721600_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3221618688_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 0_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 9601151_32
  S11: state_counter = 11_10
  S11: val1 = 3221747836_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 8554495_32
  S12: state_counter = 12_10
  S12: val1 = 3221747838_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 25165951_32
  S13: state_counter = 13_10
  S13: val1 = 67108864_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 1048703_32
  S14: state_counter = 14_10
  S14: val1 = 1107296256_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 1074790400_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262264959_32
  S16: state_counter = 16_10
  S16: val1 = 1074264186_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 134217855_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 143687807_32
  S18: state_counter = 18_10
  S18: val1 = 536870912_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 143688831_32
  S19: state_counter = 19_10
  S19: val1 = 126_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 3221747839_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 2147496063_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 3221229695_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTIU.vcd
[runlim] sample:		132.4 time, 3110.2 real, 2594.3 MB
  Test for SLTIU using testing-workflow/bug-injection-patches/alu-bug-injected_2_SLTIU.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLTIU:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SLTIU.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..06606f2 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -28,7 +28,7 @@ module alu(
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
-        `ALU_OP_SLTU : out = {31'b0, in1 < in2};
+        `ALU_OP_SLTU : out = {31'b0, in1 == in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
         default : out = 0;
       endcase // case op
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		5.4 time, 3120.2 real, 215.0 MB
[runlim] sample:		15.4 time, 3130.2 real, 202.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTIU" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.3 time, 3140.2 real, 355.9 MB
__[runlim] sample:		16.3 time, 3150.2 real, 537.3 MB
___[runlim] sample:		26.3 time, 3160.2 real, 759.4 MB
__[runlim] sample:		36.3 time, 3170.2 real, 1016.5 MB
___[runlim] sample:		46.3 time, 3180.2 real, 1251.5 MB
__[runlim] sample:		56.3 time, 3190.2 real, 1458.3 MB
_[runlim] sample:		66.3 time, 3200.2 real, 1563.7 MB
__[runlim] sample:		76.3 time, 3210.2 real, 1925.8 MB
__[runlim] sample:		86.3 time, 3220.2 real, 2087.4 MB
_[runlim] sample:		96.3 time, 3230.2 real, 2134.1 MB
_[runlim] sample:		106.3 time, 3240.2 real, 2352.5 MB
_..[runlim] sample:		116.2 time, 3250.2 real, 2492.7 MB
[runlim] sample:		126.2 time, 3260.2 real, 2576.7 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTIU **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 268447871_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 16_32][1_5 := 16777216_32][26_5 := 537001984_32][2_5 := 2147483648_32][4_5 := 4294965298_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2415947903_32
  S1: state_counter = 1_10
  S1: val1 = 2147487744_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 67108991_32
  S2: state_counter = 2_10
  S2: val1 = 1074790400_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536875135_32
  S3: state_counter = 3_10
  S3: val1 = 524288_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 67113087_32
  S4: state_counter = 4_10
  S4: val1 = 1073741824_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 2148008063_32
  S5: state_counter = 5_10
  S5: val1 = 1207959552_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 2208447763_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 4294965306_32
  S8: rd_copy = 26_5
  S8: state_counter = 8_10
  S8: val1 = 3238002688_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 4294836224_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1342177280_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1441919_32
  S11: state_counter = 11_10
  S11: val1 = 4294959104_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 462463_32
  S12: state_counter = 12_10
  S12: val1 = 4294965248_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 262271_32
  S13: state_counter = 13_10
  S13: val1 = 1090519040_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 3292561535_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 127_32
  S15: state_counter = 15_10
  S15: val1 = 4294963712_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262264959_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 18874495_32
  S17: state_counter = 17_10
  S17: val1 = 4294963200_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: state_counter = 18_10
  S18: val1 = 536870912_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 3221223598_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 4294965298_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073754239_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1082134655_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 16_32][1_5 := 16777216_32][2_5 := 2147483648_32][4_5 := 4294965298_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTIU.vcd
  Test for SLTIU using testing-workflow/bug-injection-patches/alu-bug-injected_1_SLTIU.patch succeeded, CoSA found a counterexample as expected.

Operator name: SLTI
  Bug injection patch file for instruction SLTI:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SLTI.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..388d8ff 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -194,7 +194,7 @@ module decoder(
       case (funct3)
         `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
-        `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
+        `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		3.7 time, 3270.2 real, 192.4 MB
[runlim] sample:		13.7 time, 3280.2 real, 202.7 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		3.4 time, 3290.2 real, 152.5 MB
_[runlim] sample:		13.4 time, 3300.2 real, 471.4 MB
___[runlim] sample:		23.4 time, 3310.2 real, 669.8 MB
__[runlim] sample:		33.4 time, 3320.2 real, 877.6 MB
__[runlim] sample:		43.4 time, 3330.2 real, 1065.0 MB
___[runlim] sample:		53.4 time, 3340.2 real, 1314.9 MB
_[runlim] sample:		63.4 time, 3350.2 real, 1525.7 MB
__[runlim] sample:		73.4 time, 3360.2 real, 1793.8 MB
__[runlim] sample:		83.4 time, 3370.2 real, 2004.0 MB
_[runlim] sample:		93.4 time, 3380.2 real, 2165.9 MB
_[runlim] sample:		103.4 time, 3390.2 real, 2192.0 MB
__.[runlim] sample:		113.4 time, 3400.2 real, 2367.8 MB
.[runlim] sample:		123.4 time, 3410.2 real, 2538.0 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 135266431_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 4352_32][1_5 := 2147485061_32][24_5 := 496_32][8_5 := 268435456_32][9_5 := 128_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 134221951_32
  S1: state_counter = 1_10
  S1: val1 = 8192_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147487871_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 67113087_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 75501695_32
  S4: state_counter = 4_10
  S4: val1 = 16777216_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554611_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1326196755_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 1264_32
  S8: rd_copy = 16_5
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3221225472_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073743872_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1082131583_32
  S11: state_counter = 11_10
  S11: val1 = 1073741824_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2794489215_32
  S12: state_counter = 12_10
  S12: val1 = 512_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073742975_32
  S13: state_counter = 13_10
  S13: val1 = 16_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 4262461567_32
  S14: state_counter = 14_10
  S14: val1 = 268435456_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 2147484799_32
  S15: state_counter = 15_10
  S15: val1 = 1073741824_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4236247167_32
  S16: state_counter = 16_10
  S16: val1 = 67108864_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1090520703_32
  S17: state_counter = 17_10
  S17: val1 = 2147483648_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 20974335_32
  S18: state_counter = 18_10
  S18: val1 = 3221225472_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073745535_32
  S19: state_counter = 19_10
  S19: val1 = 1090519056_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 4223_32
  S20: state_counter = 20_10
  S20: val1 = 496_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 8319_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1107300479_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 1280_32][1_5 := 2147485061_32][24_5 := 496_32][8_5 := 268435456_32][9_5 := 128_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTI.vcd
[runlim] sample:		133.4 time, 3420.2 real, 2479.4 MB
  Test for SLTI using testing-workflow/bug-injection-patches/alu-bug-injected_2_SLTI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLTI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SLTI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..74aeaef 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -26,7 +26,7 @@ module alu(
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
-        `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
+        `ALU_OP_SLT : out = {31'b0, $signed(in1) > $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		6.4 time, 3430.2 real, 202.2 MB
[runlim] sample:		16.4 time, 3440.2 real, 202.2 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.4 time, 3450.2 real, 353.7 MB
__[runlim] sample:		16.4 time, 3460.2 real, 534.2 MB
___[runlim] sample:		26.4 time, 3470.2 real, 749.1 MB
__[runlim] sample:		36.4 time, 3480.2 real, 991.3 MB
__[runlim] sample:		46.4 time, 3490.2 real, 1102.6 MB
__[runlim] sample:		56.4 time, 3500.2 real, 1440.3 MB
__[runlim] sample:		66.4 time, 3510.2 real, 1586.3 MB
_[runlim] sample:		76.4 time, 3520.2 real, 1816.5 MB
__[runlim] sample:		86.4 time, 3530.2 real, 1898.0 MB
_[runlim] sample:		96.4 time, 3540.2 real, 2054.6 MB
_[runlim] sample:		106.4 time, 3550.2 real, 2140.1 MB
_[runlim] sample:		116.3 time, 3560.2 real, 2234.8 MB
_.[runlim] sample:		126.3 time, 3570.2 real, 2455.6 MB
.[runlim] sample:		136.3 time, 3580.2 real, 2549.9 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 2147491967_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 3221225472_32][14_5 := 1048576_32][16_5 := 2147483649_32][17_5 := 2147483648_32][1_5 := 536870912_32][4_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 3221229695_32
  S1: state_counter = 1_10
  S1: val1 = 2281709569_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 553648255_32
  S2: state_counter = 2_10
  S2: val1 = 3221225472_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 134217728_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 138416255_32
  S4: state_counter = 4_10
  S4: val1 = 2097152_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1090520191_32
  S5: state_counter = 5_10
  S5: val1 = 8388608_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 2296720403_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 4294965390_32
  S8: rd_copy = 24_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3221225476_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1207959552_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1704063_32
  S11: state_counter = 11_10
  S11: val1 = 3221356544_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 1183615_32
  S12: state_counter = 12_10
  S12: val1 = 3221225472_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 2147483648_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2164293759_32
  S14: state_counter = 14_10
  S14: val1 = 2684354560_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 8388735_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4278452351_32
  S16: state_counter = 16_10
  S16: val1 = 3221225472_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1048703_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 589951_32
  S18: state_counter = 18_10
  S18: val1 = 1140850688_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 3221225472_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 16785535_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2164265087_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTI.vcd
  Test for SLTI using testing-workflow/bug-injection-patches/alu-bug-injected_0_SLTI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLTI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SLTI.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..5991408 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -26,7 +26,7 @@ module alu(
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
-        `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
+        `ALU_OP_SLT : out = {31'b0, $signed(in1) == $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		1.1 time, 3590.2 real, 116.4 MB
[runlim] sample:		11.1 time, 3600.2 real, 202.0 MB
[runlim] sample:		1.5 time, 3610.2 real, 83.9 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		11.5 time, 3620.2 real, 458.3 MB
__[runlim] sample:		21.4 time, 3630.2 real, 625.0 MB
___[runlim] sample:		31.4 time, 3640.2 real, 812.9 MB
__[runlim] sample:		41.4 time, 3650.2 real, 1017.3 MB
__[runlim] sample:		51.4 time, 3660.2 real, 1322.4 MB
__[runlim] sample:		61.4 time, 3670.2 real, 1554.0 MB
__[runlim] sample:		71.4 time, 3680.2 real, 1634.7 MB
_[runlim] sample:		81.4 time, 3690.2 real, 1866.4 MB
__[runlim] sample:		91.4 time, 3700.2 real, 2072.1 MB
_[runlim] sample:		101.4 time, 3710.2 real, 2102.9 MB
_[runlim] sample:		111.4 time, 3720.2 real, 2286.0 MB
_.[runlim] sample:		121.4 time, 3730.2 real, 2362.7 MB
.[runlim] sample:		131.4 time, 3740.2 real, 2500.0 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 268464255_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2147483648_32][11_5 := 3221225472_32][15_5 := 262144_32][16_5 := 1024_32][1_5 := 1_32][3_5 := 1073741824_32][5_5 := 2147483648_32][8_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 2147483680_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 134221951_32
  S2: state_counter = 2_10
  S2: val1 = 1082130432_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 268435456_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134217855_32
  S4: state_counter = 4_10
  S4: val1 = 2097152_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 2148532351_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 2147483648_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 2432016531_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 4294965519_32
  S8: rd_copy = 1_5
  S8: state_counter = 8_10
  S8: val1 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3221225536_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 3221225504_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 12583039_32
  S11: state_counter = 11_10
  S11: val1 = 3221233664_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2122482047_32
  S12: state_counter = 12_10
  S12: val1 = 3221225536_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 268435456_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 11927679_32
  S14: state_counter = 14_10
  S14: val1 = 1342177280_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 18874495_32
  S15: state_counter = 15_10
  S15: val1 = 3221225474_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 10780799_32
  S16: state_counter = 16_10
  S16: val1 = 1207959552_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 3221291008_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1090618495_32
  S18: state_counter = 18_10
  S18: val1 = 1073741824_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 127_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 1073746047_32
  S20: state_counter = 20_10
  S20: val1 = 3221225472_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073750143_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 4223_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2147483648_32][11_5 := 3221225472_32][15_5 := 262144_32][16_5 := 1024_32][3_5 := 1073741824_32][5_5 := 2147483648_32][8_5 := 2147483648_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTI.vcd
  Test for SLTI using testing-workflow/bug-injection-patches/alu-bug-injected_1_SLTI.patch succeeded, CoSA found a counterexample as expected.

Operator name: ADD
  Bug injection patch file for instruction ADD:  testing-workflow/bug-injection-patches/alu-bug-injected_2_ADD.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..913efef 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -192,7 +192,7 @@ module decoder(
 
    always @(*) begin
       case (funct3)
-        `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
+        `RV32_FUNCT3_ADD_SUB : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		0.7 time, 3750.2 real, 74.0 MB
[runlim] sample:		10.7 time, 3760.2 real, 202.0 MB
[runlim] sample:		1.4 time, 3770.2 real, 83.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ADD" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		11.4 time, 3780.2 real, 470.7 MB
___[runlim] sample:		21.4 time, 3790.2 real, 684.8 MB
__[runlim] sample:		31.4 time, 3800.2 real, 839.3 MB
___[runlim] sample:		41.4 time, 3810.2 real, 1104.5 MB
__[runlim] sample:		51.4 time, 3820.2 real, 1360.7 MB
__[runlim] sample:		61.4 time, 3830.2 real, 1562.5 MB
_[runlim] sample:		71.4 time, 3840.2 real, 1818.7 MB
__[runlim] sample:		81.4 time, 3850.2 real, 1901.8 MB
_[runlim] sample:		91.4 time, 3860.2 real, 2084.6 MB
_[runlim] sample:		101.4 time, 3870.2 real, 2155.8 MB
_[runlim] sample:		111.4 time, 3880.2 real, 2296.3 MB
_..[runlim] sample:		121.4 time, 3890.2 real, 2450.4 MB
[runlim] sample:		131.4 time, 3900.2 real, 2572.3 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for ADD **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2147483775_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 1073742848_32][16_5 := 2147483648_32][17_5 := 2_32][1_5 := 8194_32][29_5 := 1073742875_32][5_5 := 2147482624_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2282762367_32
  S1: state_counter = 1_10
  S1: val1 = 2147483649_32
  S1: val2 = 2147483649_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536873087_32
  S2: state_counter = 2_10
  S2: val1 = 536870912_32
  S2: val2 = 268435456_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 67115135_32
  S3: state_counter = 3_10
  S3: val1 = 805306368_32
  S3: val2 = 524289_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268441855_32
  S4: state_counter = 4_10
  S4: val1 = 536870912_32
  S4: val2 = 536870912_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 536877311_32
  S5: state_counter = 5_10
  S5: val1 = 2147483648_32
  S5: val2 = 4194304_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742995_32
  S6: state_counter = 6_10
  S6: val1 = 2281701376_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 30772403_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 25_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32
  S8: val2 = 1090519040_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1082130432_32
  S9: val2 = 1073742864_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073742848_32
  S10: val2 = 1140850688_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 25330047_32
  S11: state_counter = 11_10
  S11: val1 = 0_32
  S11: val2 = 3221225472_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 1124240255_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32
  S12: val2 = 1073742864_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 0_32
  S13: val2 = 1024_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 18874495_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 127_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1103102079_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 2164265087_32
  S18: state_counter = 18_10
  S18: val1 = 2147483648_32
  S18: val2 = 268435456_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 2164330623_32
  S19: state_counter = 19_10
  S19: val1 = 0_32
  S19: val2 = 536870912_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 1627394175_32
  S20: state_counter = 20_10
  S20: val1 = 1073742848_32
  S20: val2 = 1073742875_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 268435583_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 268439679_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for ADD.vcd
  Test for ADD using testing-workflow/bug-injection-patches/alu-bug-injected_2_ADD.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction ADD:  testing-workflow/bug-injection-patches/alu-bug-injected_1_ADD.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..9131742 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -16,7 +16,7 @@ module alu(
 
    always @(*) begin
       case (op)
-        `ALU_OP_ADD : out = in1 + in2;
+        `ALU_OP_ADD : out = in1 ^ in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		3.1 time, 3910.2 real, 192.2 MB
[runlim] sample:		13.1 time, 3920.2 real, 202.5 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ADD" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		3.4 time, 3930.2 real, 245.6 MB
_[runlim] sample:		13.4 time, 3940.2 real, 521.6 MB
___[runlim] sample:		23.4 time, 3950.2 real, 699.2 MB
___[runlim] sample:		33.4 time, 3960.2 real, 971.7 MB
__[runlim] sample:		43.4 time, 3970.2 real, 1106.4 MB
__[runlim] sample:		53.4 time, 3980.2 real, 1440.1 MB
__[runlim] sample:		63.4 time, 3990.2 real, 1551.8 MB
_[runlim] sample:		73.4 time, 4000.2 real, 1823.5 MB
__[runlim] sample:		83.4 time, 4010.2 real, 1916.9 MB
_[runlim] sample:		93.4 time, 4020.2 real, 2072.2 MB
_[runlim] sample:		103.4 time, 4030.2 real, 2171.6 MB
_[runlim] sample:		113.4 time, 4040.2 real, 2382.1 MB
_..[runlim] sample:		123.4 time, 4050.2 real, 2412.6 MB
[runlim] sample:		133.3 time, 4060.2 real, 2564.7 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for ADD **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2147483775_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 1073741824_32][1_5 := 65536_32][22_5 := 8388608_32][29_5 := 1073774596_32][5_5 := 1073741828_32][8_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 134217855_32
  S1: state_counter = 1_10
  S1: val1 = 32777_32
  S1: val2 = 536870913_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 134742143_32
  S2: state_counter = 2_10
  S2: val1 = 536870912_32
  S2: val2 = 268435456_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 150999167_32
  S3: state_counter = 3_10
  S3: val1 = 2097152_32
  S3: val2 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1207963775_32
  S4: state_counter = 4_10
  S4: val1 = 1073741824_32
  S4: val2 = 1073741824_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 67141759_32
  S5: state_counter = 5_10
  S5: val1 = 2147483648_32
  S5: val2 = 33554432_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073758208_32
  S6: val2 = 1073741825_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 30574643_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 16_5
  S8: state_counter = 8_10
  S8: val1 = 1077936128_32
  S8: val2 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1107296256_32
  S9: val2 = 1073774600_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741828_32
  S10: val2 = 1073774596_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 6848639_32
  S11: state_counter = 11_10
  S11: val1 = 0_32
  S11: val2 = 1073775104_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2137558911_32
  S12: state_counter = 12_10
  S12: val1 = 1073741840_32
  S12: val2 = 1610612736_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 2097279_32
  S13: state_counter = 13_10
  S13: val1 = 0_32
  S13: val2 = 1073774596_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2131099775_32
  S14: state_counter = 14_10
  S14: val1 = 1073758208_32
  S14: val2 = 1342177280_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 32895_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 268435456_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4271374463_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 3221225472_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 16777343_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 262144_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 917631_32
  S18: state_counter = 18_10
  S18: val1 = 4194304_32
  S18: val2 = 1140850688_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 4_32
  S19: val2 = 32772_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073741828_32
  S20: val2 = 1073774596_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 4194431_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 67113087_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 32768_32][1_5 := 65536_32][22_5 := 8388608_32][29_5 := 1073774596_32][5_5 := 1073741828_32][8_5 := 1073741824_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for ADD.vcd
  Test for ADD using testing-workflow/bug-injection-patches/alu-bug-injected_1_ADD.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction ADD:  testing-workflow/bug-injection-patches/alu-bug-injected_0_ADD.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..30dfdb1 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -16,7 +16,7 @@ module alu(
 
    always @(*) begin
       case (op)
-        `ALU_OP_ADD : out = in1 + in2;
+        `ALU_OP_ADD : out = in1 - in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		1.8 time, 4070.2 real, 130.1 MB
[runlim] sample:		11.8 time, 4080.2 real, 202.5 MB
[runlim] sample:		2.4 time, 4090.2 real, 97.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ADD" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		12.4 time, 4100.2 real, 484.3 MB
___[runlim] sample:		22.4 time, 4110.2 real, 699.4 MB
__[runlim] sample:		32.3 time, 4120.2 real, 966.5 MB
___[runlim] sample:		42.3 time, 4130.2 real, 1121.5 MB
__[runlim] sample:		52.3 time, 4140.2 real, 1404.6 MB
__[runlim] sample:		62.3 time, 4150.2 real, 1580.9 MB
__[runlim] sample:		72.3 time, 4160.2 real, 1869.5 MB
_[runlim] sample:		82.3 time, 4170.2 real, 2044.6 MB
_[runlim] sample:		92.3 time, 4180.2 real, 2085.8 MB
__[runlim] sample:		102.3 time, 4190.2 real, 2215.8 MB
_.[runlim] sample:		112.3 time, 4200.2 real, 2389.6 MB
.[runlim] sample:		122.3 time, 4210.2 real, 2506.5 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for ADD **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268435583_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 2048_32][16_5 := 2147483680_32][17_5 := 1073741856_32][24_5 := 2147483680_32][2_5 := 1073741824_32][8_5 := 1073741824_32][9_5 := 268435456_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 67113087_32
  S1: state_counter = 1_10
  S1: val2 = 536870920_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147487871_32
  S2: state_counter = 2_10
  S2: val1 = 536870912_32
  S2: val2 = 2097152_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2148536447_32
  S3: state_counter = 3_10
  S3: val1 = 268435456_32
  S3: val2 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268439679_32
  S4: state_counter = 4_10
  S4: val1 = 134217728_32
  S4: val2 = 268435456_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 2147487871_32
  S5: state_counter = 5_10
  S5: val1 = 1141899264_32
  S5: val2 = 2147483648_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 17564723_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 8_5
  S8: state_counter = 8_10
  S8: val1 = 1024_32
  S8: val2 = 3221241856_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3489660928_32
  S9: val2 = 3221225472_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 2147483648_32
  S10: val2 = 1073741824_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1507967_32
  S11: state_counter = 11_10
  S11: val1 = 268435456_32
  S11: val2 = 134217728_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 1888944767_32
  S12: state_counter = 12_10
  S12: val1 = 2147483648_32
  S12: val2 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 4194431_32
  S13: state_counter = 13_10
  S13: val1 = 1073741824_32
  S13: val2 = 2147483680_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2654335_32
  S14: state_counter = 14_10
  S14: val1 = 2147483680_32
  S14: val2 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 4194431_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 2147483680_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1082130559_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 10485887_32
  S17: state_counter = 17_10
  S17: val1 = 2147483648_32
  S17: val2 = 2149580800_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 10883199_32
  S18: state_counter = 18_10
  S18: val1 = 1073741824_32
  S18: val2 = 67108864_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 33558655_32
  S19: state_counter = 19_10
  S19: val1 = 1107296256_32
  S19: val2 = 536870912_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 2147487871_32
  S20: state_counter = 20_10
  S20: val1 = 2147483680_32
  S20: val2 = 2147483680_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 134217855_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 2048_32][16_5 := 2147483680_32][17_5 := 1073741856_32][24_5 := 2147483680_32][2_5 := 1073741824_32][9_5 := 268435456_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for ADD.vcd
  Test for ADD using testing-workflow/bug-injection-patches/alu-bug-injected_0_ADD.patch succeeded, CoSA found a counterexample as expected.

Operator name: SUB
  Bug injection patch file for instruction SUB:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SUB.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..71d9d6e 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -24,7 +24,7 @@ module alu(
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
-        `ALU_OP_SUB : out = in1 - in2;
+        `ALU_OP_SUB : out = in1 & in2;
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
[runlim] sample:		0.3 time, 4220.2 real, 41.2 MB
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		10.2 time, 4230.2 real, 202.2 MB
[runlim] sample:		1.0 time, 4240.2 real, 70.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SUB" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		11.0 time, 4250.2 real, 472.4 MB
__[runlim] sample:		21.0 time, 4260.2 real, 681.1 MB
___[runlim] sample:		30.9 time, 4270.2 real, 882.6 MB
__[runlim] sample:		40.9 time, 4280.2 real, 1082.6 MB
___[runlim] sample:		50.9 time, 4290.2 real, 1328.3 MB
__[runlim] sample:		60.9 time, 4300.2 real, 1537.5 MB
_[runlim] sample:		71.0 time, 4310.2 real, 1794.2 MB
__[runlim] sample:		80.9 time, 4320.2 real, 1961.5 MB
__[runlim] sample:		90.9 time, 4330.2 real, 2159.2 MB
_[runlim] sample:		100.9 time, 4340.2 real, 2225.4 MB
_.[runlim] sample:		110.9 time, 4350.2 real, 2343.7 MB
.[runlim] sample:		120.9 time, 4360.2 real, 2513.1 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SUB **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 536871039_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[19_5 := 1073741824_32][1_5 := 128_32][24_5 := 2147483648_32][26_5 := 1073741822_32][2_5 := 2_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 268435583_32
  S1: state_counter = 1_10
  S1: val1 = 1107296256_32
  S1: val2 = 536870928_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 1073746047_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32
  S2: val2 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 536870912_32
  S3: val2 = 33554432_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134221951_32
  S4: state_counter = 4_10
  S4: val1 = 33554432_32
  S4: val2 = 536870912_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32
  S5: val2 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554483_32
  S6: state_counter = 6_10
  S6: val1 = 2_32
  S6: val2 = 262144_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1094454579_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 32768_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 26_5
  S8: state_counter = 8_10
  S8: val1 = 1610612736_32
  S8: val2 = 1074003968_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073741824_32
  S9: val2 = 1073742976_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 2147483652_32
  S10: val2 = 2147483648_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1075578495_32
  S11: state_counter = 11_10
  S11: val1 = 1073741824_32
  S11: val2 = 32_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2115800703_32
  S12: state_counter = 12_10
  S12: val1 = 2147483656_32
  S12: val2 = 536870912_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1342178431_32
  S13: state_counter = 13_10
  S13: val1 = 1073741824_32
  S13: val2 = 1073741824_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 4262461567_32
  S14: state_counter = 14_10
  S14: val1 = 2147483648_32
  S14: val2 = 0_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073742975_32
  S15: state_counter = 15_10
  S15: val1 = 1073741824_32
  S15: val2 = 1073741826_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4269965439_32
  S16: state_counter = 16_10
  S16: val1 = 0_32
  S16: val2 = 1077936128_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32
  S17: val2 = 1073741832_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 127_32
  S18: state_counter = 18_10
  S18: val1 = 0_32
  S18: val2 = 0_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 3221225472_32
  S19: val2 = 16777220_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 2147483648_32
  S20: val2 = 1073741824_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073741951_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[19_5 := 1073741824_32][1_5 := 128_32][24_5 := 2147483648_32][2_5 := 2_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SUB.vcd
[runlim] sample:		130.9 time, 4370.2 real, 2008.6 MB
  Test for SUB using testing-workflow/bug-injection-patches/alu-bug-injected_1_SUB.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SUB:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SUB.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..913efef 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -192,7 +192,7 @@ module decoder(
 
    always @(*) begin
       case (funct3)
-        `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
+        `RV32_FUNCT3_ADD_SUB : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		8.9 time, 4380.2 real, 202.5 MB
[runlim] sample:		18.9 time, 4390.2 real, 265.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SUB" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		9.8 time, 4400.2 real, 506.4 MB
___[runlim] sample:		19.8 time, 4410.2 real, 626.3 MB
___[runlim] sample:		29.7 time, 4420.2 real, 817.6 MB
__[runlim] sample:		39.7 time, 4430.2 real, 1089.2 MB
___[runlim] sample:		49.7 time, 4440.2 real, 1340.6 MB
__[runlim] sample:		59.7 time, 4450.2 real, 1566.5 MB
_[runlim] sample:		69.7 time, 4460.2 real, 1822.8 MB
__[runlim] sample:		79.7 time, 4470.2 real, 1915.1 MB
_[runlim] sample:		89.7 time, 4480.2 real, 2071.2 MB
_[runlim] sample:		99.7 time, 4490.2 real, 2158.3 MB
_[runlim] sample:		109.7 time, 4500.2 real, 2364.9 MB
_..[runlim] sample:		119.7 time, 4510.2 real, 2555.0 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SUB **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 1073741951_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 134217728_32][15_5 := 2147483668_32][16_5 := 1073741824_32][17_5 := 536870912_32][2_5 := 524288_32][5_5 := 128_32][9_5 := 32_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147496063_32
  S1: state_counter = 1_10
  S1: val1 = 2147483649_32
  S1: val2 = 2147483649_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 1610612736_32
  S2: val2 = 16384_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32
  S3: val2 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 67113087_32
  S4: state_counter = 4_10
  S4: val1 = 536870912_32
  S4: val2 = 1082130432_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1090520191_32
  S5: state_counter = 5_10
  S5: val1 = 1024_32
  S5: val2 = 4_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1077937171_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1089537075_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 8_5
  S8: state_counter = 8_10
  S8: val1 = 3489660928_32
  S8: val2 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 524418_32
  S9: val2 = 1342177281_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 524290_32
  S10: val2 = 1342177280_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 11567231_32
  S11: state_counter = 11_10
  S11: val1 = 2147483648_32
  S11: val2 = 2147483668_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 11700351_32
  S12: state_counter = 12_10
  S12: val1 = 3221225472_32
  S12: val2 = 1610612736_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 268435456_32
  S13: val2 = 2147487744_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 4489343_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1610613760_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 524296_32
  S15: val2 = 2147484672_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4261937279_32
  S16: state_counter = 16_10
  S16: val1 = 1610612736_32
  S16: val2 = 2147483904_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 255_32
  S17: state_counter = 17_10
  S17: val1 = 524288_32
  S17: val2 = 3221225472_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1074270335_32
  S18: state_counter = 18_10
  S18: val1 = 16777216_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1074266112_32
  S19: val2 = 1073743888_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 524288_32
  S20: val2 = 2147483668_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073741951_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SUB.vcd
[runlim] sample:		129.7 time, 4520.2 real, 2599.5 MB
  Test for SUB using testing-workflow/bug-injection-patches/alu-bug-injected_2_SUB.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SUB:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SUB.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..e0b03b5 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -24,7 +24,7 @@ module alu(
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
-        `ALU_OP_SUB : out = in1 - in2;
+        `ALU_OP_SUB : out = in1 + in2;
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		4.8 time, 4530.2 real, 192.2 MB
[runlim] sample:		14.8 time, 4540.2 real, 202.3 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SUB" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		5.6 time, 4550.2 real, 315.6 MB
__[runlim] sample:		15.6 time, 4560.2 real, 534.4 MB
___[runlim] sample:		25.6 time, 4570.2 real, 748.5 MB
__[runlim] sample:		35.6 time, 4580.2 real, 994.3 MB
__[runlim] sample:		45.6 time, 4590.2 real, 1144.5 MB
__[runlim] sample:		55.5 time, 4600.2 real, 1437.2 MB
__[runlim] sample:		65.5 time, 4610.2 real, 1607.6 MB
__[runlim] sample:		75.5 time, 4620.2 real, 1875.3 MB
__[runlim] sample:		85.5 time, 4630.2 real, 2090.6 MB
_[runlim] sample:		95.5 time, 4640.2 real, 2106.9 MB
_[runlim] sample:		105.5 time, 4650.2 real, 2246.2 MB
_..[runlim] sample:		115.5 time, 4660.2 real, 2470.8 MB
[runlim] sample:		125.5 time, 4670.2 real, 2592.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SUB **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 1073741951_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[1_5 := 2147483648_32][26_5 := 65569_32][2_5 := 1073807423_32][30_5 := 1073807423_32][4_5 := 16_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 268439679_32
  S1: state_counter = 1_10
  S1: val2 = 536870920_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 1073741824_32
  S2: val2 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 67108864_32
  S3: val2 = 65536_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 1074266112_32
  S4: val2 = 1610612736_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1140851839_32
  S5: state_counter = 5_10
  S5: val1 = 3221225472_32
  S5: val2 = 1342177280_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1077937171_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1101532467_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 26_5
  S8: state_counter = 8_10
  S8: val1 = 1207959552_32
  S8: val2 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 64_32
  S9: val2 = 65602_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1_32
  S10: val2 = 1073741824_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 2097279_32
  S11: state_counter = 11_10
  S11: val1 = 536870912_32
  S11: val2 = 65568_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 4246867071_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32
  S12: val2 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 4194431_32
  S13: state_counter = 13_10
  S13: val1 = 0_32
  S13: val2 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2097279_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 41943167_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262002815_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 17825919_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 884863_32
  S18: state_counter = 18_10
  S18: val1 = 1073741824_32
  S18: val2 = 3221225472_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 33554432_32
  S19: val2 = 1073807393_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 0_32
  S20: val2 = 65569_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073741951_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 268439679_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SUB.vcd
  Test for SUB using testing-workflow/bug-injection-patches/alu-bug-injected_0_SUB.patch succeeded, CoSA found a counterexample as expected.

Operator name: AND
  Bug injection patch file for instruction AND:  testing-workflow/bug-injection-patches/alu-bug-injected_0_AND.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..ee4a54e 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -20,7 +20,7 @@ module alu(
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
-        `ALU_OP_AND : out = in1 & in2;
+        `ALU_OP_AND : out = in1 ^ in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		2.2 time, 4680.2 real, 173.3 MB
[runlim] sample:		12.2 time, 4690.2 real, 202.5 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for AND" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		3.0 time, 4700.2 real, 153.0 MB
_[runlim] sample:		13.0 time, 4710.2 real, 475.9 MB
___[runlim] sample:		23.0 time, 4720.2 real, 690.1 MB
___[runlim] sample:		33.0 time, 4730.2 real, 980.7 MB
__[runlim] sample:		43.0 time, 4740.2 real, 1125.4 MB
__[runlim] sample:		53.0 time, 4750.2 real, 1397.1 MB
__[runlim] sample:		63.0 time, 4760.2 real, 1654.2 MB
__[runlim] sample:		73.0 time, 4770.2 real, 1879.0 MB
_[runlim] sample:		82.9 time, 4780.2 real, 1901.9 MB
_[runlim] sample:		93.0 time, 4790.2 real, 2066.0 MB
_[runlim] sample:		102.9 time, 4800.2 real, 2218.7 MB
_[runlim] sample:		112.9 time, 4810.2 real, 2405.0 MB
_..[runlim] sample:		122.9 time, 4820.2 real, 2556.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for AND **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2147512447_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[29_5 := 1073743944_32][4_5 := 1073744704_32][5_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2214596735_32
  S1: state_counter = 1_10
  S1: val1 = 1_32
  S1: val2 = 2147484160_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 134221951_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32
  S2: val2 = 536870912_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 67108864_32
  S3: val2 = 1073741824_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147487871_32
  S4: state_counter = 4_10
  S4: val1 = 134217728_32
  S4: val2 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 536875135_32
  S5: state_counter = 5_10
  S5: val1 = 1342177280_32
  S5: val2 = 16_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 30571827_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 26_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32
  S8: val2 = 1207959552_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1342177280_32
  S9: val2 = 1073743969_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073744704_32
  S10: val2 = 1610612736_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 2228351_32
  S11: state_counter = 11_10
  S11: val1 = 0_32
  S11: val2 = 1342177280_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2114096255_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32
  S12: val2 = 1073743944_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 25165951_32
  S13: state_counter = 13_10
  S13: val1 = 0_32
  S13: val2 = 2048_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 12746879_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1610612736_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4261937279_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 16777343_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 8388735_32
  S18: state_counter = 18_10
  S18: val1 = 1073774592_32
  S18: val2 = 1073774592_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1075874624_32
  S19: val2 = 1342179400_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073744704_32
  S20: val2 = 1073743944_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 16806015_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[26_5 := 776_32][29_5 := 1073743944_32][4_5 := 1073744704_32][5_5 := 2147483648_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for AND.vcd
[runlim] sample:		132.9 time, 4830.2 real, 2489.8 MB
  Test for AND using testing-workflow/bug-injection-patches/alu-bug-injected_0_AND.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction AND:  testing-workflow/bug-injection-patches/alu-bug-injected_2_AND.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..7b21326 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -199,7 +199,7 @@ module decoder(
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
         `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
-        `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_AND;
+        `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_XOR;
         default : alu_op_arith = `ALU_OP_ADD;
       endcase // case (funct3)
    end // always @ begin
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		7.8 time, 4840.2 real, 202.7 MB
[runlim] sample:		17.8 time, 4850.2 real, 276.5 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for AND" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		8.9 time, 4860.2 real, 357.6 MB
___[runlim] sample:		18.8 time, 4870.2 real, 623.7 MB
__[runlim] sample:		28.8 time, 4880.2 real, 801.4 MB
___[runlim] sample:		38.8 time, 4890.2 real, 1015.9 MB
__[runlim] sample:		48.8 time, 4900.2 real, 1300.6 MB
__[runlim] sample:		58.8 time, 4910.2 real, 1523.2 MB
__[runlim] sample:		68.8 time, 4920.2 real, 1758.5 MB
_[runlim] sample:		78.8 time, 4930.2 real, 1867.0 MB
__[runlim] sample:		88.8 time, 4940.2 real, 2096.6 MB
_[runlim] sample:		98.8 time, 4950.2 real, 2240.0 MB
_[runlim] sample:		108.8 time, 4960.2 real, 2234.1 MB
_..[runlim] sample:		118.8 time, 4970.2 real, 2430.1 MB
[runlim] sample:		128.8 time, 4980.2 real, 2507.5 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for AND **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 302010495_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1077677446_32][11_5 := 536870912_32][15_5 := 268435456_32][1_5 := 2147483648_32][27_5 := 1073741824_32][29_5 := 1077677446_32][2_5 := 1073741824_32][3_5 := 536870912_32][9_5 := 5_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147483775_32
  S1: state_counter = 1_10
  S1: val1 = 4194304_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 268439679_32
  S2: state_counter = 2_10
  S2: val1 = 1073741824_32
  S2: val2 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 134221951_32
  S3: state_counter = 3_10
  S3: val1 = 67108864_32
  S3: val2 = 16777216_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1073742975_32
  S4: state_counter = 4_10
  S4: val1 = 1073741824_32
  S4: val2 = 1073741824_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 127_32
  S5: state_counter = 5_10
  S5: val1 = 0_32
  S5: val2 = 0_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 30765491_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 3_5
  S8: state_counter = 8_10
  S8: val1 = 3221225472_32
  S8: val2 = 1207959552_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1077674000_32
  S9: val2 = 4096_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1077673984_32
  S10: val2 = 0_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1409151_32
  S11: state_counter = 11_10
  S11: val1 = 0_32
  S11: val2 = 1077677441_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2125955583_32
  S12: state_counter = 12_10
  S12: val1 = 268435456_32
  S12: val2 = 1077677440_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 2097279_32
  S13: state_counter = 13_10
  S13: val1 = 0_32
  S13: val2 = 2097152_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 14975103_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 4194431_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 52265087_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1074857087_32
  S18: state_counter = 18_10
  S18: val1 = 1073741824_32
  S18: val2 = 1073741824_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 127_32
  S19: state_counter = 19_10
  S19: val1 = 0_32
  S19: val2 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 553652351_32
  S20: state_counter = 20_10
  S20: val1 = 1077677446_32
  S20: val2 = 1077677446_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 536899711_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1077677446_32][11_5 := 536870912_32][15_5 := 268435456_32][1_5 := 2147483648_32][27_5 := 1073741824_32][29_5 := 1077677446_32][2_5 := 1073741824_32][9_5 := 5_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for AND.vcd
  Test for AND using testing-workflow/bug-injection-patches/alu-bug-injected_2_AND.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction AND:  testing-workflow/bug-injection-patches/alu-bug-injected_1_AND.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..ae1b07a 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -20,7 +20,7 @@ module alu(
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
-        `ALU_OP_AND : out = in1 & in2;
+        `ALU_OP_AND : out = in1 << in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		0.8 time, 4990.2 real, 74.5 MB
[runlim] sample:		10.8 time, 5000.2 real, 202.5 MB
[runlim] sample:		1.5 time, 5010.2 real, 85.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for AND" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		11.5 time, 5020.2 real, 474.1 MB
___[runlim] sample:		21.5 time, 5030.2 real, 685.0 MB
__[runlim] sample:		31.5 time, 5040.2 real, 832.4 MB
___[runlim] sample:		41.5 time, 5050.2 real, 1091.9 MB
__[runlim] sample:		51.5 time, 5060.2 real, 1351.7 MB
__[runlim] sample:		61.5 time, 5070.2 real, 1561.4 MB
__[runlim] sample:		71.5 time, 5080.2 real, 1835.6 MB
_[runlim] sample:		81.5 time, 5090.2 real, 1908.4 MB
_[runlim] sample:		91.5 time, 5100.2 real, 2083.2 MB
_[runlim] sample:		101.5 time, 5110.2 real, 2193.1 MB
__.[runlim] sample:		111.5 time, 5120.2 real, 2300.6 MB
.[runlim] sample:		121.5 time, 5130.2 real, 2504.9 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for AND **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268451967_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 8388608_32][12_5 := 1073741824_32][14_5 := 3840_32][16_5 := 2684354560_32][1_5 := 1073741824_32][24_5 := 1610612736_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 1077936128_32
  S1: val2 = 8388608_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 268439679_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32
  S2: val2 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147483775_32
  S3: state_counter = 3_10
  S3: val1 = 8388608_32
  S3: val2 = 33554432_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2164265087_32
  S4: state_counter = 4_10
  S4: val1 = 536870912_32
  S4: val2 = 268435456_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 3221229695_32
  S5: state_counter = 5_10
  S5: val1 = 1090519040_32
  S5: val2 = 2149580800_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1342177280_32
  S6: val2 = 1610612736_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25722163_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 26_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32
  S8: val2 = 1075838976_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 2684354560_32
  S9: val2 = 1073741826_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 1073741824_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 27721855_32
  S11: state_counter = 11_10
  S11: val1 = 2684354560_32
  S11: val2 = 1610612736_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 279380607_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 20971647_32
  S13: state_counter = 13_10
  S13: val1 = 2684354560_32
  S13: val2 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 1073774719_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 3221225472_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 2684354560_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1086357631_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1611661312_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 565612671_32
  S18: state_counter = 18_10
  S18: val1 = 1207959552_32
  S18: val2 = 268435456_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073746047_32
  S19: state_counter = 19_10
  S19: val1 = 134217728_32
  S19: val2 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 536875135_32
  S20: state_counter = 20_10
  S20: val1 = 2684354560_32
  S20: val2 = 1610612736_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 67137663_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 134221951_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for AND.vcd
[runlim] sample:		131.5 time, 5140.2 real, 2039.1 MB
  Test for AND using testing-workflow/bug-injection-patches/alu-bug-injected_1_AND.patch succeeded, CoSA found a counterexample as expected.

Operator name: OR
  Bug injection patch file for instruction OR:  testing-workflow/bug-injection-patches/alu-bug-injected_1_OR.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..8b912a8 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -19,7 +19,7 @@ module alu(
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
-        `ALU_OP_OR : out = in1 | in2;
+        `ALU_OP_OR : out = in1 ^ in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		8.3 time, 5150.2 real, 202.1 MB
[runlim] sample:		18.3 time, 5160.2 real, 275.8 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction For OR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		9.2 time, 5170.2 real, 384.5 MB
___[runlim] sample:		19.1 time, 5180.2 real, 626.4 MB
__[runlim] sample:		29.1 time, 5190.2 real, 792.8 MB
___[runlim] sample:		39.1 time, 5200.2 real, 1011.0 MB
__[runlim] sample:		49.1 time, 5210.2 real, 1242.8 MB
__[runlim] sample:		59.1 time, 5220.2 real, 1471.1 MB
__[runlim] sample:		69.1 time, 5230.2 real, 1635.6 MB
_[runlim] sample:		79.1 time, 5240.2 real, 1864.3 MB
__[runlim] sample:		89.1 time, 5250.2 real, 2091.9 MB
_[runlim] sample:		99.1 time, 5260.2 real, 2118.5 MB
_[runlim] sample:		109.1 time, 5270.2 real, 2348.4 MB
_..[runlim] sample:		119.1 time, 5280.2 real, 2429.0 MB
[runlim] sample:		129.1 time, 5290.2 real, 2587.1 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction For OR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268460159_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[15_5 := 262147_32][2_5 := 1073741825_32][4_5 := 1_32][9_5 := 16_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 335548543_32
  S1: state_counter = 1_10
  S1: val1 = 2147483712_32
  S1: val2 = 1140850704_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 1610612736_32
  S2: val2 = 67108864_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 2147483648_32
  S3: val2 = 536870912_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147487871_32
  S4: state_counter = 4_10
  S4: val1 = 134217728_32
  S4: val2 = 1073872896_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1077937279_32
  S5: state_counter = 5_10
  S5: val1 = 1048576_32
  S5: val2 = 128_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 15820851_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 16_5
  S8: state_counter = 8_10
  S8: val1 = 3221225472_32
  S8: val2 = 1207959552_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1077936160_32
  S9: val2 = 262145_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1077936128_32
  S10: val2 = 1140850688_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 26345599_32
  S11: state_counter = 11_10
  S11: val1 = 1073741832_32
  S11: val2 = 1073872896_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2123500415_32
  S12: state_counter = 12_10
  S12: val1 = 0_32
  S12: val2 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 4194431_32
  S13: state_counter = 13_10
  S13: val1 = 1073745920_32
  S13: val2 = 16777216_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 524415_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 262147_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4261412991_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 16777471_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 557183_32
  S18: state_counter = 18_10
  S18: val1 = 268435456_32
  S18: val2 = 1073741825_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 25_32
  S19: val2 = 1073741827_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073741825_32
  S20: val2 = 262147_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 24703_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1073746047_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[15_5 := 262147_32][16_5 := 1074003970_32][2_5 := 1073741825_32][4_5 := 1_32][9_5 := 16_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction For OR.vcd
  Test for OR using testing-workflow/bug-injection-patches/alu-bug-injected_1_OR.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction OR:  testing-workflow/bug-injection-patches/alu-bug-injected_0_OR.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..9893173 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -19,7 +19,7 @@ module alu(
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
-        `ALU_OP_OR : out = in1 | in2;
+        `ALU_OP_OR : out = in1 & in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		4.1 time, 5300.2 real, 192.4 MB
[runlim] sample:		14.1 time, 5310.2 real, 202.5 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction For OR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		4.8 time, 5320.2 real, 268.1 MB
__[runlim] sample:		14.8 time, 5330.2 real, 527.3 MB
__[runlim] sample:		24.8 time, 5340.2 real, 745.0 MB
___[runlim] sample:		34.8 time, 5350.2 real, 988.3 MB
__[runlim] sample:		44.8 time, 5360.2 real, 1145.9 MB
__[runlim] sample:		54.8 time, 5370.2 real, 1446.2 MB
__[runlim] sample:		64.8 time, 5380.2 real, 1608.7 MB
__[runlim] sample:		74.8 time, 5390.2 real, 1862.5 MB
__[runlim] sample:		84.8 time, 5400.2 real, 2053.7 MB
_[runlim] sample:		94.8 time, 5410.2 real, 2247.8 MB
_[runlim] sample:		104.8 time, 5420.2 real, 2309.3 MB
_..[runlim] sample:		114.8 time, 5430.2 real, 2476.9 MB
[runlim] sample:		124.8 time, 5440.2 real, 2581.5 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction For OR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 134242943_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 16_32][15_5 := 8_32][1_5 := 2147483648_32][24_5 := 3221225504_32][25_5 := 2147483680_32][8_5 := 16777248_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 201326719_32
  S1: state_counter = 1_10
  S1: val1 = 1073741825_32
  S1: val2 = 1610612737_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147484031_32
  S2: state_counter = 2_10
  S2: val1 = 268435456_32
  S2: val2 = 1073741824_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 3221229951_32
  S3: state_counter = 3_10
  S3: val1 = 134217728_32
  S3: val2 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268435583_32
  S4: state_counter = 4_10
  S4: val1 = 1207959552_32
  S4: val2 = 134217728_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 2147487871_32
  S5: state_counter = 5_10
  S5: val1 = 16777216_32
  S5: val2 = 1107296256_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25455923_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 26_5
  S8: state_counter = 8_10
  S8: val1 = 1207959552_32
  S8: val2 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1074003968_32
  S9: val2 = 3221225488_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 3221225480_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 14680191_32
  S11: state_counter = 11_10
  S11: val1 = 0_32
  S11: val2 = 3225419776_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2128907519_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32
  S12: val2 = 3221225504_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 4194431_32
  S13: state_counter = 13_10
  S13: val1 = 16777248_32
  S13: val2 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 491647_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 3221225504_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 16777248_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 3267952767_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 3221225472_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 75497599_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 77594751_32
  S18: state_counter = 18_10
  S18: val1 = 1073741824_32
  S18: val2 = 3221226496_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1107297407_32
  S19: state_counter = 19_10
  S19: val1 = 1358954528_32
  S19: val2 = 1073741856_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 16777248_32
  S20: val2 = 3221225504_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 16801919_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 16_32][15_5 := 8_32][1_5 := 2147483648_32][24_5 := 3221225504_32][25_5 := 2147483680_32][26_5 := 32_32][8_5 := 16777248_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction For OR.vcd
  Test for OR using testing-workflow/bug-injection-patches/alu-bug-injected_0_OR.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction OR:  testing-workflow/bug-injection-patches/alu-bug-injected_2_OR.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..286657b 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -198,7 +198,7 @@ module decoder(
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
-        `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
+        `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_AND;
         default : alu_op_arith = `ALU_OP_ADD;
       endcase // case (funct3)
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		2.8 time, 5450.2 real, 191.5 MB
[runlim] sample:		12.7 time, 5460.2 real, 202.7 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction For OR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		3.5 time, 5470.2 real, 246.4 MB
_[runlim] sample:		13.5 time, 5480.2 real, 519.8 MB
___[runlim] sample:		23.5 time, 5490.2 real, 696.9 MB
___[runlim] sample:		33.5 time, 5500.2 real, 981.4 MB
__[runlim] sample:		43.5 time, 5510.2 real, 1153.0 MB
__[runlim] sample:		53.5 time, 5520.2 real, 1436.2 MB
__[runlim] sample:		63.5 time, 5530.2 real, 1607.2 MB
__[runlim] sample:		73.5 time, 5540.2 real, 1849.1 MB
__[runlim] sample:		83.5 time, 5550.2 real, 2079.5 MB
_[runlim] sample:		93.5 time, 5560.2 real, 2160.7 MB
_[runlim] sample:		103.5 time, 5570.2 real, 2362.2 MB
_..[runlim] sample:		113.5 time, 5580.2 real, 2477.2 MB
[runlim] sample:		123.5 time, 5590.2 real, 2623.8 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction For OR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 536895615_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 8_32][14_5 := 16_32][16_5 := 2097185_32][18_5 := 2048_32][24_5 := 1073741825_32][25_5 := 1_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 671088767_32
  S1: state_counter = 1_10
  S1: val1 = 262144_32
  S1: val2 = 2151678081_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 268439679_32
  S2: state_counter = 2_10
  S2: val1 = 1073741824_32
  S2: val2 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 536870912_32
  S3: val2 = 3221225472_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134218879_32
  S4: state_counter = 4_10
  S4: val1 = 1610612736_32
  S4: val2 = 1073741824_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1082131583_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32
  S5: val2 = 268435456_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 2147483648_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25718067_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 26_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32
  S8: val2 = 1082130432_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 2147483648_32
  S9: val2 = 8388608_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 0_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 19169407_32
  S11: state_counter = 11_10
  S11: val1 = 2097154_32
  S11: val2 = 1074790400_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2128907519_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32
  S12: val2 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 2097192_32
  S13: val2 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 393343_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 2097200_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262002815_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1610612736_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 6291583_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 884863_32
  S18: state_counter = 18_10
  S18: val1 = 1090519040_32
  S18: val2 = 1074003968_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1075839009_32
  S19: val2 = 1073758209_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 2097185_32
  S20: val2 = 1073741825_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 134242431_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 67113087_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 8_32][14_5 := 16_32][16_5 := 2097185_32][18_5 := 2048_32][24_5 := 1073741825_32][25_5 := 1_32][26_5 := 1075839008_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction For OR.vcd
  Test for OR using testing-workflow/bug-injection-patches/alu-bug-injected_2_OR.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction OR:  testing-workflow/bug-injection-patches/alu-bug-injected_00_OR.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..9893173 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -19,7 +19,7 @@ module alu(
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
-        `ALU_OP_OR : out = in1 | in2;
+        `ALU_OP_OR : out = in1 & in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		3.2 time, 5600.2 real, 191.7 MB
[runlim] sample:		13.2 time, 5610.2 real, 202.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction For OR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		4.1 time, 5620.2 real, 261.0 MB
_[runlim] sample:		14.0 time, 5630.2 real, 521.1 MB
___[runlim] sample:		24.0 time, 5640.2 real, 752.4 MB
___[runlim] sample:		34.0 time, 5650.2 real, 997.2 MB
__[runlim] sample:		44.0 time, 5660.2 real, 1114.1 MB
__[runlim] sample:		54.0 time, 5670.2 real, 1449.2 MB
__[runlim] sample:		64.0 time, 5680.2 real, 1608.8 MB
__[runlim] sample:		74.0 time, 5690.2 real, 1871.5 MB
_[runlim] sample:		84.0 time, 5700.2 real, 2066.1 MB
__[runlim] sample:		94.0 time, 5710.2 real, 2124.0 MB
[runlim] sample:		104.0 time, 5720.2 real, 2198.8 MB
__.[runlim] sample:		114.0 time, 5730.2 real, 2305.6 MB
.[runlim] sample:		124.0 time, 5740.2 real, 2519.0 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction For OR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 134242943_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1073741824_32][16_5 := 4_32][19_5 := 268435456_32][1_5 := 1073741824_32][24_5 := 1342193710_32][25_5 := 1342193708_32][5_5 := 1048576_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 201330815_32
  S1: state_counter = 1_10
  S1: val1 = 1073741824_32
  S1: val2 = 1073741888_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 67108864_32
  S2: val2 = 16384_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147488127_32
  S3: state_counter = 3_10
  S3: val1 = 75497472_32
  S3: val2 = 536870912_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 268435712_32
  S4: val2 = 32_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1090520191_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32
  S5: val2 = 1342177280_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 536870912_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25715891_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 9_5
  S8: state_counter = 8_10
  S8: val1 = 3221225472_32
  S8: val2 = 1140850688_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 4_32
  S9: val2 = 1073758224_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 1073741828_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 9306239_32
  S11: state_counter = 11_10
  S11: val1 = 2_32
  S11: val2 = 1074790400_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2120155263_32
  S12: state_counter = 12_10
  S12: val1 = 0_32
  S12: val2 = 1073758208_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 8454271_32
  S13: state_counter = 13_10
  S13: val1 = 1090519040_32
  S13: val2 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 26837119_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1342178304_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 127_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1084227711_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1342177280_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 2148569215_32
  S18: state_counter = 18_10
  S18: val1 = 268435456_32
  S18: val2 = 536870912_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 536875135_32
  S19: state_counter = 19_10
  S19: val1 = 2147483648_32
  S19: val2 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 2147487871_32
  S20: state_counter = 20_10
  S20: val1 = 4_32
  S20: val2 = 1342193710_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 24703_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1073741824_32][16_5 := 4_32][19_5 := 268435456_32][1_5 := 1073741824_32][24_5 := 1342193710_32][25_5 := 1342193708_32][5_5 := 1048576_32][9_5 := 4_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction For OR.vcd
[runlim] sample:		134.0 time, 5750.2 real, 2438.9 MB
  Test for OR using testing-workflow/bug-injection-patches/alu-bug-injected_00_OR.patch succeeded, CoSA found a counterexample as expected.

Operator name: XOR
  Bug injection patch file for instruction XOR:  testing-workflow/bug-injection-patches/alu-bug-injected_2_XOR.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..572eac7 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -196,7 +196,7 @@ module decoder(
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
-        `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
+        `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_OR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
         `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
         `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_AND;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		7.2 time, 5760.2 real, 202.8 MB
[runlim] sample:		17.2 time, 5770.2 real, 214.2 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for XOR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		8.0 time, 5780.2 real, 357.9 MB
___[runlim] sample:		18.0 time, 5790.2 real, 590.9 MB
__[runlim] sample:		28.0 time, 5800.2 real, 777.5 MB
___[runlim] sample:		38.0 time, 5810.2 real, 1019.3 MB
__[runlim] sample:		48.0 time, 5820.2 real, 1217.7 MB
__[runlim] sample:		58.0 time, 5830.2 real, 1470.6 MB
__[runlim] sample:		68.0 time, 5840.2 real, 1656.7 MB
_[runlim] sample:		78.0 time, 5850.2 real, 1869.0 MB
__[runlim] sample:		88.0 time, 5860.2 real, 2092.5 MB
_[runlim] sample:		98.0 time, 5870.2 real, 2108.5 MB
_[runlim] sample:		108.0 time, 5880.2 real, 2269.6 MB
_.[runlim] sample:		118.0 time, 5890.2 real, 2271.3 MB
.[runlim] sample:		128.0 time, 5900.2 real, 2536.0 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for XOR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 134226047_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1073741824_32][13_5 := 64_32][17_5 := 2147483648_32][1_5 := 1073741824_32][24_5 := 64_32][25_5 := 524288_32][4_5 := 4016044003_32][9_5 := 524288_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 67108991_32
  S1: state_counter = 1_10
  S1: val1 = 2147483680_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 134217855_32
  S2: state_counter = 2_10
  S2: val1 = 536870912_32
  S2: val2 = 553648128_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536875135_32
  S3: state_counter = 3_10
  S3: val1 = 8388608_32
  S3: val2 = 536870912_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134221951_32
  S4: state_counter = 4_10
  S4: val1 = 268435456_32
  S4: val2 = 1610612736_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073746047_32
  S5: state_counter = 5_10
  S5: val1 = 8_32
  S5: val2 = 67108864_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 4508723_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 24_5
  S8: state_counter = 8_10
  S8: val1 = 1074266112_32
  S8: val2 = 3221225472_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 524292_32
  S9: val2 = 1342177538_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 1342177280_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 8421503_32
  S11: state_counter = 11_10
  S11: val1 = 532480_32
  S11: val2 = 1207960608_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2057732351_32
  S12: state_counter = 12_10
  S12: val1 = 0_32
  S12: val2 = 1207959552_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 18874495_32
  S13: state_counter = 13_10
  S13: val1 = 1073741824_32
  S13: val2 = 4016041984_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 12583039_32
  S14: state_counter = 14_10
  S14: val1 = 1073750016_32
  S14: val2 = 1610612736_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 524289_32
  S15: val2 = 4016044004_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262494335_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 4016044000_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 524288_32
  S17: val2 = 2147483648_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 17334655_32
  S18: state_counter = 18_10
  S18: val1 = 1610612736_32
  S18: val2 = 4016043908_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1073741824_32
  S19: val2 = 536870912_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 524288_32
  S20: val2 = 4016044003_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 16511_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 4223_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1073741824_32][13_5 := 64_32][17_5 := 2147483648_32][1_5 := 1073741824_32][24_5 := 4016044003_32][25_5 := 524288_32][4_5 := 4016044003_32][9_5 := 524288_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for XOR.vcd
[runlim] sample:		138.0 time, 5910.2 real, 2057.3 MB
  Test for XOR using testing-workflow/bug-injection-patches/alu-bug-injected_2_XOR.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction XOR:  testing-workflow/bug-injection-patches/alu-bug-injected_00_XOR.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..b1154a3 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -18,7 +18,7 @@ module alu(
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
-        `ALU_OP_XOR : out = in1 ^ in2;
+        `ALU_OP_XOR : out = in1 | in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		8.8 time, 5920.2 real, 202.1 MB
[runlim] sample:		18.8 time, 5930.2 real, 281.2 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for XOR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		9.5 time, 5940.2 real, 444.8 MB
___[runlim] sample:		19.6 time, 5950.2 real, 625.5 MB
___[runlim] sample:		29.5 time, 5960.2 real, 821.0 MB
__[runlim] sample:		39.5 time, 5970.2 real, 1036.4 MB
__[runlim] sample:		49.5 time, 5980.2 real, 1313.8 MB
__[runlim] sample:		59.5 time, 5990.2 real, 1568.3 MB
__[runlim] sample:		69.5 time, 6000.2 real, 1820.9 MB
__[runlim] sample:		79.5 time, 6010.2 real, 1895.4 MB
_[runlim] sample:		89.5 time, 6020.2 real, 2070.6 MB
__[runlim] sample:		99.5 time, 6030.2 real, 2200.7 MB
_[runlim] sample:		109.5 time, 6040.2 real, 2281.8 MB
..[runlim] sample:		119.5 time, 6050.2 real, 2508.1 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for XOR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 134234751_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 16_32][14_5 := 1073741856_32][15_5 := 32_32][3_5 := 2147483648_32][5_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 201330815_32
  S1: state_counter = 1_10
  S1: val1 = 1073741825_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 1073746047_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32
  S2: val2 = 3221225472_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 33554432_32
  S3: val2 = 4194304_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 2147483648_32
  S4: val2 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1090520191_32
  S5: state_counter = 5_10
  S5: val1 = 1610612736_32
  S5: val2 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 134217728_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 5360947_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 26_5
  S8: state_counter = 8_10
  S8: val1 = 1342177280_32
  S8: val2 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 2147483652_32
  S9: val2 = 2147483649_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 1610612736_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 10518655_32
  S11: state_counter = 11_10
  S11: val1 = 0_32
  S11: val2 = 2147483649_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 4238837631_32
  S12: state_counter = 12_10
  S12: val1 = 3221225472_32
  S12: val2 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 262271_32
  S13: state_counter = 13_10
  S13: val1 = 0_32
  S13: val2 = 2147483648_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 3539071_32
  S14: state_counter = 14_10
  S14: val1 = 2181038080_32
  S14: val2 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 2147483648_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4266459263_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1048703_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 2148007936_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 65663_32
  S18: state_counter = 18_10
  S18: val1 = 538968064_32
  S18: val2 = 1074266112_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 3221225472_32
  S19: val2 = 1075838976_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 2147483648_32
  S20: val2 = 2147483648_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 4210815_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 134221951_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 16_32][14_5 := 1073741856_32][15_5 := 32_32][26_5 := 2147483648_32][3_5 := 2147483648_32][5_5 := 2147483648_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for XOR.vcd
[runlim] sample:		129.5 time, 6060.2 real, 2038.9 MB
  Test for XOR using testing-workflow/bug-injection-patches/alu-bug-injected_00_XOR.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction XOR:  testing-workflow/bug-injection-patches/alu-bug-injected_1_XOR.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..b92b56c 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -18,7 +18,7 @@ module alu(
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
-        `ALU_OP_XOR : out = in1 ^ in2;
+        `ALU_OP_XOR : out = in1 & in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		9.0 time, 6070.2 real, 202.3 MB
[runlim] sample:		19.0 time, 6080.2 real, 265.0 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for XOR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		9.8 time, 6090.2 real, 485.1 MB
___[runlim] sample:		19.8 time, 6100.2 real, 624.9 MB
___[runlim] sample:		29.8 time, 6110.2 real, 870.9 MB
__[runlim] sample:		39.8 time, 6120.2 real, 1070.5 MB
__[runlim] sample:		49.8 time, 6130.2 real, 1302.6 MB
__[runlim] sample:		59.8 time, 6140.2 real, 1514.0 MB
__[runlim] sample:		69.8 time, 6150.2 real, 1794.0 MB
__[runlim] sample:		79.8 time, 6160.2 real, 1963.0 MB
_[runlim] sample:		89.7 time, 6170.2 real, 2168.3 MB
__[runlim] sample:		99.7 time, 6180.2 real, 2231.3 MB
_.[runlim] sample:		109.7 time, 6190.2 real, 2402.9 MB
.[runlim] sample:		119.7 time, 6200.2 real, 2529.7 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for XOR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268451967_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 4194304_32][16_5 := 1075838980_32][1_5 := 2_32][24_5 := 2097156_32][2_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 335544447_32
  S1: state_counter = 1_10
  S1: val1 = 2147483712_32
  S1: val2 = 1073741840_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147487871_32
  S2: state_counter = 2_10
  S2: val1 = 1073741824_32
  S2: val2 = 67108864_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 3221229695_32
  S3: state_counter = 3_10
  S3: val1 = 1207959552_32
  S3: val2 = 570425344_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147487871_32
  S4: state_counter = 4_10
  S4: val1 = 1342177280_32
  S4: val2 = 41943040_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 2684355711_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32
  S5: val2 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554483_32
  S6: state_counter = 6_10
  S6: val1 = 0_32
  S6: val2 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 17580339_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32
  S7: val2 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 2_5
  S8: state_counter = 8_10
  S8: val1 = 0_32
  S8: val2 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3221225472_32
  S9: val2 = 1075838980_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 4194304_32
  S10: val2 = 0_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1085277311_32
  S11: state_counter = 11_10
  S11: val1 = 1342177280_32
  S11: val2 = 1140850688_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 11536511_32
  S12: state_counter = 12_10
  S12: val1 = 2147483648_32
  S12: val2 = 0_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073742975_32
  S13: state_counter = 13_10
  S13: val1 = 1342177280_32
  S13: val2 = 1075838980_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2114977919_32
  S14: state_counter = 14_10
  S14: val1 = 0_32
  S14: val2 = 0_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073742975_32
  S15: state_counter = 15_10
  S15: val1 = 524288_32
  S15: val2 = 1075838980_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262494335_32
  S16: state_counter = 16_10
  S16: val1 = 1140850688_32
  S16: val2 = 0_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32
  S17: val2 = 1075838980_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 10485887_32
  S18: state_counter = 18_10
  S18: val1 = 67108864_32
  S18: val2 = 134217728_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 3223322624_32
  S19: val2 = 4_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 2097156_32
  S20: val2 = 1075838980_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 16511_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 4194304_32][16_5 := 1075838980_32][1_5 := 2_32][24_5 := 2097156_32][2_5 := 2097156_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for XOR.vcd
[runlim] sample:		129.7 time, 6210.2 real, 1655.3 MB
  Test for XOR using testing-workflow/bug-injection-patches/alu-bug-injected_1_XOR.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction XOR:  testing-workflow/bug-injection-patches/alu-bug-injected_0_XOR.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..82173e1 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -18,7 +18,7 @@ module alu(
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
-        `ALU_OP_XOR : out = in1 ^ in2;
+        `ALU_OP_XOR : out = in1 + in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		9.9 time, 6220.2 real, 202.2 MB
[runlim] sample:		0.7 time, 6230.2 real, 61.6 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for XOR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		10.7 time, 6240.2 real, 462.2 MB
__[runlim] sample:		20.7 time, 6250.2 real, 681.8 MB
___[runlim] sample:		30.7 time, 6260.2 real, 833.6 MB
___[runlim] sample:		40.7 time, 6270.2 real, 1110.1 MB
__[runlim] sample:		50.7 time, 6280.2 real, 1350.1 MB
__[runlim] sample:		60.7 time, 6290.2 real, 1590.1 MB
__[runlim] sample:		70.7 time, 6300.2 real, 1852.3 MB
_[runlim] sample:		80.7 time, 6310.2 real, 1900.3 MB
_[runlim] sample:		90.6 time, 6320.2 real, 2068.4 MB
__[runlim] sample:		100.6 time, 6330.2 real, 2208.4 MB
_.[runlim] sample:		110.6 time, 6340.2 real, 2390.5 MB
.[runlim] sample:		120.6 time, 6350.2 real, 2512.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for XOR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 134226047_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 1088_32][1_5 := 15392_32][24_5 := 1073741824_32][8_5 := 131096_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 67108991_32
  S1: state_counter = 1_10
  S1: val1 = 2147516425_32
  S1: val2 = 2148532227_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 272629887_32
  S2: state_counter = 2_10
  S2: val1 = 268435456_32
  S2: val2 = 2717908992_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 138416255_32
  S3: state_counter = 3_10
  S3: val1 = 2684354560_32
  S3: val2 = 2149580800_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2151682175_32
  S4: state_counter = 4_10
  S4: val1 = 536870912_32
  S4: val2 = 1073741824_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 541065343_32
  S5: state_counter = 5_10
  S5: val1 = 268435456_32
  S5: val2 = 1107296256_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 33554432_32
  S6: val2 = 538968064_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 14729523_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 2_5
  S8: state_counter = 8_10
  S8: val1 = 3355443200_32
  S8: val2 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 8388608_32
  S9: val2 = 67108864_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 1073741824_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 262271_32
  S11: state_counter = 11_10
  S11: val1 = 15392_32
  S11: val2 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2089027711_32
  S12: state_counter = 12_10
  S12: val1 = 1207959552_32
  S12: val2 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 4194431_32
  S13: state_counter = 13_10
  S13: val1 = 15392_32
  S13: val2 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2490495_32
  S14: state_counter = 14_10
  S14: val1 = 3221225472_32
  S14: val2 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 4194431_32
  S15: state_counter = 15_10
  S15: val1 = 15400_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262199423_32
  S16: state_counter = 16_10
  S16: val1 = 1342177280_32
  S16: val2 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 16777343_32
  S17: state_counter = 17_10
  S17: val1 = 268435456_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 127_32
  S18: state_counter = 18_10
  S18: val1 = 1107296256_32
  S18: val2 = 67108864_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 3221240864_32
  S19: val2 = 1073742912_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 15392_32
  S20: val2 = 1088_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 536887423_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 1088_32][1_5 := 15392_32][24_5 := 1073741824_32][2_5 := 16480_32][8_5 := 131096_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for XOR.vcd
[runlim] sample:		130.6 time, 6360.2 real, 1710.5 MB
  Test for XOR using testing-workflow/bug-injection-patches/alu-bug-injected_0_XOR.patch succeeded, CoSA found a counterexample as expected.

Operator name: SLL
  Bug injection patch file for instruction SLL:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SLL.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..65dc0d2 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -17,7 +17,7 @@ module alu(
    always @(*) begin
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
-        `ALU_OP_SLL : out = in1 << shamt;
+        `ALU_OP_SLL : out = in1 + shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		9.9 time, 6370.2 real, 202.7 MB
[runlim] sample:		0.7 time, 6380.2 real, 62.3 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLL" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		10.7 time, 6390.2 real, 458.4 MB
__[runlim] sample:		20.7 time, 6400.2 real, 677.4 MB
___[runlim] sample:		30.7 time, 6410.2 real, 832.2 MB
___[runlim] sample:		40.7 time, 6420.2 real, 1104.6 MB
__[runlim] sample:		50.7 time, 6430.2 real, 1346.4 MB
__[runlim] sample:		60.7 time, 6440.2 real, 1569.3 MB
_[runlim] sample:		70.7 time, 6450.2 real, 1830.8 MB
__[runlim] sample:		80.7 time, 6460.2 real, 1921.5 MB
_[runlim] sample:		90.7 time, 6470.2 real, 2074.5 MB
_[runlim] sample:		100.7 time, 6480.2 real, 2227.0 MB
__.[runlim] sample:		110.7 time, 6490.2 real, 2353.4 MB
.[runlim] sample:		120.7 time, 6500.2 real, 2550.3 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLL **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268451967_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 32_32][12_5 := 32_32][17_5 := 2684354560_32][1_5 := 1073741824_32][24_5 := 2147483688_32][8_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 3225419776_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536871039_32
  S2: state_counter = 2_10
  S2: val1 = 1207959552_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 134217728_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134221951_32
  S4: state_counter = 4_10
  S4: val1 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 536875263_32
  S5: state_counter = 5_10
  S5: val1 = 32768_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073741971_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25432371_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 2_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 16777216_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1207959552_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 27885695_32
  S11: state_counter = 11_10
  S11: val1 = 2147483652_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2141750783_32
  S12: state_counter = 12_10
  S12: val1 = 3254779904_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 127_32
  S13: state_counter = 13_10
  S13: val1 = 2147483672_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 12910719_32
  S14: state_counter = 14_10
  S14: val1 = 3221225984_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 134217855_32
  S15: state_counter = 15_10
  S15: val1 = 2147484192_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 3725262975_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 10485887_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 17696127_32
  S18: state_counter = 18_10
  S18: val1 = 1342177280_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1074003968_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 2147483648_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 4223_32
  S21: shimm2_copy = 8_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 32_32][12_5 := 32_32][17_5 := 2684354560_32][1_5 := 1073741824_32][24_5 := 2147483688_32][2_5 := 2147483656_32][8_5 := 2147483648_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLL.vcd
[runlim] sample:		130.7 time, 6510.2 real, 2051.5 MB
  Test for SLL using testing-workflow/bug-injection-patches/alu-bug-injected_0_SLL.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLL:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SLL.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..84297bb 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -193,7 +193,7 @@ module decoder(
    always @(*) begin
       case (funct3)
         `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
-        `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
+        `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		9.3 time, 6520.2 real, 202.5 MB
[runlim] sample:		19.3 time, 6530.2 real, 284.0 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLL" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		10.1 time, 6540.2 real, 455.0 MB
___[runlim] sample:		20.1 time, 6550.2 real, 621.6 MB
___[runlim] sample:		30.1 time, 6560.2 real, 815.6 MB
__[runlim] sample:		40.1 time, 6570.2 real, 1030.0 MB
__[runlim] sample:		50.1 time, 6580.2 real, 1314.8 MB
___[runlim] sample:		60.1 time, 6590.2 real, 1563.4 MB
_[runlim] sample:		70.1 time, 6600.2 real, 1819.2 MB
__[runlim] sample:		80.1 time, 6610.2 real, 1928.7 MB
_[runlim] sample:		90.1 time, 6620.2 real, 2066.9 MB
_[runlim] sample:		100.1 time, 6630.2 real, 2180.8 MB
_[runlim] sample:		110.1 time, 6640.2 real, 2359.6 MB
_..[runlim] sample:		120.1 time, 6650.2 real, 2459.1 MB
[runlim] sample:		130.1 time, 6660.2 real, 2620.9 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLL **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 536871039_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 4194304_32][16_5 := 1073741824_32][1_5 := 1073741824_32][24_5 := 32768_32][8_5 := 32768_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 1610621055_32
  S1: state_counter = 1_10
  S1: val1 = 1073741825_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 67113087_32
  S2: state_counter = 2_10
  S2: val1 = 134217728_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 1073741824_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1077940351_32
  S5: state_counter = 5_10
  S5: val1 = 1207959552_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 2147483648_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 17568819_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 8_5
  S8: state_counter = 8_10
  S8: val1 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 32769_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1342177288_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 15990911_32
  S11: state_counter = 11_10
  S11: val1 = 1610612744_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2128939263_32
  S12: state_counter = 12_10
  S12: val1 = 1610612736_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 2097279_32
  S13: state_counter = 13_10
  S13: val1 = 536870912_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 12615807_32
  S14: state_counter = 14_10
  S14: val1 = 1610612736_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 4194431_32
  S15: state_counter = 15_10
  S15: val1 = 1107296256_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4278780031_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 8421503_32
  S18: state_counter = 18_10
  S18: val1 = 1074266112_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1073774592_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 32768_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 536875135_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 538972287_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 4194304_32][16_5 := 1073741824_32][1_5 := 1073741824_32][24_5 := 32768_32][8_5 := 1073774592_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLL.vcd
  Test for SLL using testing-workflow/bug-injection-patches/alu-bug-injected_2_SLL.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLL:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SLL.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..656cf18 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -17,7 +17,7 @@ module alu(
    always @(*) begin
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
-        `ALU_OP_SLL : out = in1 << shamt;
+        `ALU_OP_SLL : out = in1 | shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		3.2 time, 6670.2 real, 192.4 MB
[runlim] sample:		13.2 time, 6680.2 real, 202.8 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLL" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		4.0 time, 6690.2 real, 256.7 MB
_[runlim] sample:		14.0 time, 6700.2 real, 521.0 MB
___[runlim] sample:		24.0 time, 6710.2 real, 751.0 MB
___[runlim] sample:		34.0 time, 6720.2 real, 968.7 MB
__[runlim] sample:		44.0 time, 6730.2 real, 1081.8 MB
__[runlim] sample:		54.0 time, 6740.2 real, 1446.6 MB
__[runlim] sample:		64.0 time, 6750.2 real, 1642.6 MB
__[runlim] sample:		74.0 time, 6760.2 real, 1813.3 MB
_[runlim] sample:		84.0 time, 6770.2 real, 1988.4 MB
__[runlim] sample:		94.0 time, 6780.2 real, 2200.3 MB
_[runlim] sample:		104.0 time, 6790.2 real, 2234.1 MB
_..[runlim] sample:		114.0 time, 6800.2 real, 2479.7 MB
[runlim] sample:		124.0 time, 6810.2 real, 2556.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLL **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268451967_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 2_32][17_5 := 1073741840_32][18_5 := 1073741824_32][1_5 := 262144_32][28_5 := 2148761619_32][3_5 := 16_32][4_5 := 2148761619_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 1077936128_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 134221951_32
  S2: state_counter = 2_10
  S2: val1 = 536870912_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 3221225472_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1082131583_32
  S4: state_counter = 4_10
  S4: val1 = 1082130432_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 3221225472_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554483_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 17964595_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1342177280_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 28_5
  S8: state_counter = 8_10
  S8: val1 = 2_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1140850688_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 3221228560_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1073808511_32
  S11: state_counter = 11_10
  S11: val1 = 3221227536_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2081525375_32
  S12: state_counter = 12_10
  S12: val1 = 2064_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073742975_32
  S13: state_counter = 13_10
  S13: val1 = 2148761619_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2160100223_32
  S14: state_counter = 14_10
  S14: val1 = 2148696066_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073747071_32
  S15: state_counter = 15_10
  S15: val1 = 1073940496_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262461567_32
  S16: state_counter = 16_10
  S16: val1 = 1073807360_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1073743872_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 262271_32
  S18: state_counter = 18_10
  S18: val1 = 1611661312_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 32895_32
  S20: state_counter = 20_10
  S20: val1 = 2148761619_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 4223_32
  S21: shimm2_copy = 16_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1073746047_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLL.vcd
[runlim] sample:		134.0 time, 6820.2 real, 2051.7 MB
  Test for SLL using testing-workflow/bug-injection-patches/alu-bug-injected_1_SLL.patch succeeded, CoSA found a counterexample as expected.

Operator name: SRL
  Bug injection patch file for instruction SRL:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SRL.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..e8e3c76 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -21,7 +21,7 @@ module alu(
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
-        `ALU_OP_SRL : out = in1 >> shamt;
+        `ALU_OP_SRL : out = in1 << shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		9.4 time, 6830.2 real, 202.5 MB
[runlim] sample:		19.3 time, 6840.2 real, 268.8 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRL" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		9.9 time, 6850.2 real, 488.9 MB
___[runlim] sample:		19.9 time, 6860.2 real, 633.1 MB
___[runlim] sample:		29.9 time, 6870.2 real, 813.1 MB
__[runlim] sample:		39.9 time, 6880.2 real, 1069.2 MB
___[runlim] sample:		49.9 time, 6890.2 real, 1326.4 MB
__[runlim] sample:		59.9 time, 6900.2 real, 1571.5 MB
_[runlim] sample:		69.9 time, 6910.2 real, 1817.9 MB
__[runlim] sample:		79.9 time, 6920.2 real, 1899.6 MB
_[runlim] sample:		89.9 time, 6930.2 real, 2101.6 MB
__[runlim] sample:		99.9 time, 6940.2 real, 2326.2 MB
[runlim] sample:		109.9 time, 6950.2 real, 2349.7 MB
_..[runlim] sample:		119.9 time, 6960.2 real, 2512.0 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRL **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268456063_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 16_32][16_5 := 128_32][17_5 := 8_32][1_5 := 528_32][4_5 := 1_32][8_5 := 2147483648_32][9_5 := 8_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 339742847_32
  S1: state_counter = 1_10
  S1: val1 = 2147483712_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536871039_32
  S2: state_counter = 2_10
  S2: val1 = 536870912_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 67113087_32
  S3: state_counter = 3_10
  S3: val1 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268436095_32
  S4: state_counter = 4_10
  S4: val1 = 16777216_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1082131583_32
  S5: state_counter = 5_10
  S5: val1 = 1207959552_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1200691_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 4_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1342177280_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073774592_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 4325503_32
  S11: state_counter = 11_10
  S11: val1 = 16384_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 14812287_32
  S12: state_counter = 12_10
  S12: val1 = 131072_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1048703_32
  S13: state_counter = 13_10
  S13: val1 = 268435456_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 12583039_32
  S14: state_counter = 14_10
  S14: val1 = 67108864_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1082131583_32
  S15: state_counter = 15_10
  S15: val1 = 100663296_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 524415_32
  S16: state_counter = 16_10
  S16: val1 = 1048576_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 16777343_32
  S17: state_counter = 17_10
  S17: val1 = 2147483648_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1073742975_32
  S18: state_counter = 18_10
  S18: val1 = 512_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 127_32
  S19: state_counter = 19_10
  S19: val1 = 1073741824_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 1207963775_32
  S20: state_counter = 20_10
  S20: val1 = 1_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 134238335_32
  S21: shimm2_copy = 16_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 16_32][16_5 := 128_32][17_5 := 8_32][1_5 := 528_32][4_5 := 65536_32][8_5 := 2147483648_32][9_5 := 8_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRL.vcd
[runlim] sample:		129.9 time, 6970.2 real, 2555.5 MB
  Test for SRL using testing-workflow/bug-injection-patches/alu-bug-injected_0_SRL.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SRL:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SRL.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..6c69a31 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -197,7 +197,7 @@ module decoder(
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
-        `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
+        `RV32_FUNCT3_SRA_SRL : alu_op_arith = add_or_sub;
         `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
         `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_AND;
         default : alu_op_arith = `ALU_OP_ADD;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		6.0 time, 6980.2 real, 202.7 MB
[runlim] sample:		16.0 time, 6990.2 real, 202.7 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRL" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.8 time, 7000.2 real, 357.6 MB
__[runlim] sample:		16.7 time, 7010.2 real, 585.1 MB
___[runlim] sample:		26.7 time, 7020.2 real, 765.3 MB
__[runlim] sample:		36.7 time, 7030.2 real, 1002.2 MB
___[runlim] sample:		46.7 time, 7040.2 real, 1250.4 MB
__[runlim] sample:		56.7 time, 7050.2 real, 1470.5 MB
__[runlim] sample:		66.7 time, 7060.2 real, 1634.8 MB
_[runlim] sample:		76.7 time, 7070.2 real, 1866.9 MB
__[runlim] sample:		86.7 time, 7080.2 real, 2082.5 MB
_[runlim] sample:		96.7 time, 7090.2 real, 2109.5 MB
_[runlim] sample:		106.7 time, 7100.2 real, 2234.6 MB
_.[runlim] sample:		116.7 time, 7110.2 real, 2384.9 MB
.[runlim] sample:		126.7 time, 7120.2 real, 2522.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRL **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2147504255_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 8_32][15_5 := 16_32][16_5 := 24_32][20_5 := 536870920_32][24_5 := 8_32][8_5 := 32768_32][9_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2281713791_32
  S1: state_counter = 1_10

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 150995071_32
  S2: state_counter = 2_10
  S2: val1 = 33554432_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2164265087_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 285216895_32
  S4: state_counter = 4_10
  S4: val1 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1082131583_32
  S5: state_counter = 5_10
  S5: val1 = 1342177280_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 17453235_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 1_5
  S8: state_counter = 8_10
  S8: val1 = 536870912_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073741824_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1207959552_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 24511103_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2130054783_32
  S12: state_counter = 12_10
  S12: val1 = 536870928_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 41943167_32
  S13: state_counter = 13_10
  S13: val1 = 268435456_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 8716415_32
  S14: state_counter = 14_10
  S14: val1 = 536870912_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1091896447_32
  S16: state_counter = 16_10
  S16: val1 = 536870912_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 538452095_32
  S18: state_counter = 18_10
  S18: val1 = 134217728_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 541065343_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 2147487871_32
  S20: state_counter = 20_10
  S20: val1 = 536870920_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 20607_32
  S21: shimm2_copy = 24_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 8_32][15_5 := 16_32][16_5 := 24_32][1_5 := 536870944_32][20_5 := 536870920_32][24_5 := 8_32][8_5 := 32768_32][9_5 := 1073741824_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRL.vcd
  Test for SRL using testing-workflow/bug-injection-patches/alu-bug-injected_2_SRL.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SRL:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SRL.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..5e1bbef 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -21,7 +21,7 @@ module alu(
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
-        `ALU_OP_SRL : out = in1 >> shamt;
+        `ALU_OP_SRL : out = in1 & shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
[runlim] sample:		0.2 time, 7130.2 real, 23.5 MB
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		10.1 time, 7140.2 real, 202.5 MB
[runlim] sample:		1.0 time, 7150.2 real, 70.7 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRL" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		11.0 time, 7160.2 real, 461.3 MB
__[runlim] sample:		21.0 time, 7170.2 real, 680.4 MB
___[runlim] sample:		31.0 time, 7180.2 real, 855.2 MB
__[runlim] sample:		41.0 time, 7190.2 real, 1088.6 MB
___[runlim] sample:		51.0 time, 7200.2 real, 1350.1 MB
__[runlim] sample:		61.0 time, 7210.2 real, 1585.5 MB
__[runlim] sample:		71.0 time, 7220.2 real, 1870.7 MB
_[runlim] sample:		81.0 time, 7230.2 real, 1935.6 MB
_[runlim] sample:		91.0 time, 7240.2 real, 2079.1 MB
__[runlim] sample:		101.0 time, 7250.2 real, 2205.1 MB
_.[runlim] sample:		111.0 time, 7260.2 real, 2394.5 MB
.[runlim] sample:		121.0 time, 7270.2 real, 2562.7 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRL **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2147496063_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[15_5 := 16777216_32][16_5 := 1073741824_32][28_5 := 1024_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2415919231_32
  S1: state_counter = 1_10
  S1: val1 = 2214592512_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536871039_32
  S2: state_counter = 2_10
  S2: val1 = 33554432_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 134221951_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268439679_32
  S4: state_counter = 4_10
  S4: val1 = 536870912_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1090520191_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 536870912_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 29907379_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 19_5
  S8: state_counter = 8_10

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1346371584_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 12091519_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 4277767551_32
  S12: state_counter = 12_10
  S12: val1 = 1090519040_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 8388735_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 131199_32
  S14: state_counter = 14_10
  S14: val1 = 1610612736_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 4194431_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4265968767_32
  S16: state_counter = 16_10
  S16: val1 = 1140850688_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1048703_32
  S17: state_counter = 17_10
  S17: val1 = 4194304_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 8388735_32
  S18: state_counter = 18_10
  S18: val1 = 2147483648_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 268456063_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 270536831_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRL.vcd
[runlim] sample:		131.0 time, 7280.2 real, 2096.5 MB
  Test for SRL using testing-workflow/bug-injection-patches/alu-bug-injected_1_SRL.patch succeeded, CoSA found a counterexample as expected.

Operator name: SRA
  Bug injection patch file for instruction SRA:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SRA.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..75c5655 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -25,7 +25,7 @@ module alu(
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
-        `ALU_OP_SRA : out = $signed(in1) >>> shamt;
+        `ALU_OP_SRA : out = $signed(in1) << shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		8.9 time, 7290.2 real, 202.0 MB
[runlim] sample:		18.9 time, 7300.2 real, 264.7 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRA" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		9.8 time, 7310.2 real, 445.2 MB
___[runlim] sample:		19.8 time, 7320.2 real, 623.2 MB
___[runlim] sample:		29.7 time, 7330.2 real, 797.2 MB
__[runlim] sample:		39.7 time, 7340.2 real, 1018.4 MB
__[runlim] sample:		49.7 time, 7350.2 real, 1314.6 MB
__[runlim] sample:		59.7 time, 7360.2 real, 1542.2 MB
__[runlim] sample:		69.7 time, 7370.2 real, 1818.1 MB
__[runlim] sample:		79.7 time, 7380.2 real, 1941.0 MB
_[runlim] sample:		89.7 time, 7390.2 real, 2056.8 MB
_[runlim] sample:		99.7 time, 7400.2 real, 2150.4 MB
_[runlim] sample:		109.7 time, 7410.2 real, 2327.1 MB
_..[runlim] sample:		119.7 time, 7420.2 real, 2503.1 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRA **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 1073754239_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 3221225472_32][1_5 := 1073741824_32][20_5 := 16_32][24_5 := 2147483664_32][3_5 := 2147483648_32][8_5 := 16_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147483775_32
  S1: state_counter = 1_10
  S1: val1 = 2155872256_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 268439679_32
  S2: state_counter = 2_10
  S2: val1 = 67108864_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 16777216_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268439679_32
  S4: state_counter = 4_10
  S4: val1 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1090520191_32
  S5: state_counter = 5_10
  S5: val1 = 0_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1099454515_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 16_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3221225488_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 3221225474_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 2101346431_32
  S11: state_counter = 11_10
  S11: val1 = 3355443200_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2101611391_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 32895_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1082654847_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 134221951_32
  S18: state_counter = 18_10
  S18: val1 = 536870912_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 67113087_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 2147487871_32
  S20: state_counter = 20_10
  S20: val1 = 3221225472_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073762431_32
  S21: shimm2_copy = 16_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[1_5 := 1073741824_32][20_5 := 16_32][24_5 := 2147483664_32][3_5 := 2147483648_32][8_5 := 16_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRA.vcd
[runlim] sample:		129.7 time, 7430.2 real, 2430.8 MB
  Test for SRA using testing-workflow/bug-injection-patches/alu-bug-injected_1_SRA.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SRA:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SRA.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..75c5655 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -25,7 +25,7 @@ module alu(
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
-        `ALU_OP_SRA : out = $signed(in1) >>> shamt;
+        `ALU_OP_SRA : out = $signed(in1) << shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		7.8 time, 7440.2 real, 202.2 MB
[runlim] sample:		17.8 time, 7450.2 real, 267.6 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRA" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		8.7 time, 7460.2 real, 357.2 MB
___[runlim] sample:		18.7 time, 7470.2 real, 617.6 MB
__[runlim] sample:		28.7 time, 7480.2 real, 811.5 MB
___[runlim] sample:		38.7 time, 7490.2 real, 1021.6 MB
__[runlim] sample:		48.6 time, 7500.2 real, 1234.3 MB
__[runlim] sample:		58.6 time, 7510.2 real, 1502.6 MB
__[runlim] sample:		68.6 time, 7520.2 real, 1634.0 MB
_[runlim] sample:		78.6 time, 7530.2 real, 1867.7 MB
__[runlim] sample:		88.6 time, 7540.2 real, 2088.4 MB
_[runlim] sample:		98.6 time, 7550.2 real, 2155.5 MB
_[runlim] sample:		108.6 time, 7560.2 real, 2233.9 MB
_.[runlim] sample:		118.6 time, 7570.2 real, 2425.3 MB
.[runlim] sample:		128.6 time, 7580.2 real, 2532.1 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRA **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 1073754239_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 1073741824_32][13_5 := 1610612745_32][14_5 := 1074790400_32][15_5 := 536870912_32][1_5 := 536870912_32][9_5 := 16_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 134217855_32
  S1: state_counter = 1_10
  S1: val1 = 2147483657_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 1073750143_32
  S2: state_counter = 2_10
  S2: val1 = 134217728_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 2147483649_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147487871_32
  S4: state_counter = 4_10
  S4: val1 = 9_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1074005119_32
  S5: state_counter = 5_10
  S5: val1 = 0_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1082131475_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1087852723_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 1_5
  S8: state_counter = 8_10
  S8: val1 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1074790416_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1074790400_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 10944639_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2125957247_32
  S12: state_counter = 12_10
  S12: val1 = 268435456_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 4194431_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 10780799_32
  S14: state_counter = 14_10
  S14: val1 = 1074790400_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1048703_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4261675135_32
  S16: state_counter = 16_10
  S16: val1 = 1074790402_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 4194431_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 32895_32
  S18: state_counter = 18_10
  S18: val1 = 1074790400_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1094844416_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1074790400_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073762431_32
  S21: shimm2_copy = 9_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1077940351_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRA.vcd
  Test for SRA using testing-workflow/bug-injection-patches/alu-bug-injected_0_SRA.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SRA:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SRA.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..6c69a31 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -197,7 +197,7 @@ module decoder(
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
-        `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
+        `RV32_FUNCT3_SRA_SRL : alu_op_arith = add_or_sub;
         `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
         `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_AND;
         default : alu_op_arith = `ALU_OP_ADD;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		2.0 time, 7590.2 real, 139.8 MB
[runlim] sample:		11.9 time, 7600.2 real, 202.5 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRA" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		2.8 time, 7610.2 real, 107.2 MB
_[runlim] sample:		12.8 time, 7620.2 real, 474.5 MB
___[runlim] sample:		22.8 time, 7630.2 real, 698.2 MB
___[runlim] sample:		32.8 time, 7640.2 real, 967.1 MB
__[runlim] sample:		42.8 time, 7650.2 real, 1119.5 MB
__[runlim] sample:		52.8 time, 7660.2 real, 1429.0 MB
__[runlim] sample:		62.8 time, 7670.2 real, 1545.5 MB
__[runlim] sample:		72.8 time, 7680.2 real, 1855.3 MB
_[runlim] sample:		82.8 time, 7690.2 real, 1970.1 MB
_[runlim] sample:		92.8 time, 7700.2 real, 2069.0 MB
_[runlim] sample:		102.8 time, 7710.2 real, 2197.1 MB
_[runlim] sample:		112.8 time, 7720.2 real, 2313.9 MB
_..[runlim] sample:		122.8 time, 7730.2 real, 2535.4 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRA **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 1073758335_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2097152_32][11_5 := 1107300192_32][12_5 := 33558528_32][14_5 := 1107300380_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147492479_32
  S1: state_counter = 1_10
  S1: val1 = 268451843_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 1073746559_32
  S2: state_counter = 2_10
  S2: val1 = 2684354560_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 67113599_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 75502207_32
  S4: state_counter = 4_10
  S4: val1 = 2097152_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 276828799_32
  S5: state_counter = 5_10
  S5: val1 = 2147483648_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1074005011_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1085758771_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 26_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1107300352_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 0_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 17170559_32
  S11: state_counter = 11_10
  S11: val1 = 4194304_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 10882431_32
  S12: state_counter = 12_10
  S12: val1 = 3221225472_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 1107300380_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2228351_32
  S14: state_counter = 14_10
  S14: val1 = 1342177280_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1114239_32
  S15: state_counter = 15_10
  S15: val1 = 1107300352_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4286578815_32
  S16: state_counter = 16_10
  S16: val1 = 0_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1118335_32
  S17: state_counter = 17_10
  S17: val1 = 1107296256_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 303231_32
  S18: state_counter = 18_10
  S18: val1 = 268435456_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 3221229596_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1107300380_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073762431_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2097152_32][11_5 := 1107300192_32][12_5 := 33558528_32][14_5 := 1107300380_32][26_5 := 188_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRA.vcd
[runlim] sample:		132.8 time, 7740.2 real, 2554.0 MB
  Test for SRA using testing-workflow/bug-injection-patches/alu-bug-injected_2_SRA.patch succeeded, CoSA found a counterexample as expected.

Operator name: SLTU
  Bug injection patch file for instruction SLTU:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SLTU.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..3d6e5bd 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -28,7 +28,7 @@ module alu(
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
-        `ALU_OP_SLTU : out = {31'b0, in1 < in2};
+        `ALU_OP_SLTU : out = {31'b0, in1 > in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
         default : out = 0;
       endcase // case op
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		6.1 time, 7750.2 real, 202.2 MB
[runlim] sample:		16.1 time, 7760.2 real, 202.2 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTU" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.9 time, 7770.2 real, 357.5 MB
__[runlim] sample:		16.9 time, 7780.2 real, 539.1 MB
___[runlim] sample:		26.9 time, 7790.2 real, 757.1 MB
__[runlim] sample:		36.9 time, 7800.2 real, 990.0 MB
___[runlim] sample:		46.9 time, 7810.2 real, 1297.4 MB
__[runlim] sample:		56.9 time, 7820.2 real, 1476.7 MB
__[runlim] sample:		66.9 time, 7830.2 real, 1679.9 MB
_[runlim] sample:		76.9 time, 7840.2 real, 1916.7 MB
__[runlim] sample:		86.9 time, 7850.2 real, 2007.7 MB
_[runlim] sample:		96.9 time, 7860.2 real, 2169.5 MB
_[runlim] sample:		106.9 time, 7870.2 real, 2352.0 MB
_..[runlim] sample:		116.9 time, 7880.2 real, 2480.3 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTU **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268439679_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 1073741824_32][24_5 := 3716424383_32][25_5 := 3716424367_32][8_5 := 33554432_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147483775_32
  S1: state_counter = 1_10
  S1: val1 = 1073741825_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 67113087_32
  S2: state_counter = 2_10
  S2: val1 = 67108864_32
  S2: val2 = 1073741824_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536871039_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32
  S3: val2 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 67113087_32
  S4: state_counter = 4_10
  S4: val1 = 16777216_32
  S4: val2 = 1077936128_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32
  S5: val2 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554483_32
  S6: state_counter = 6_10
  S6: val1 = 4_32
  S6: val2 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25998899_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 2147483648_32
  S7: val2 = 32_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 12_5
  S8: state_counter = 8_10
  S8: val1 = 1073741832_32
  S8: val2 = 2281701376_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3582400528_32
  S9: val2 = 0_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 3716424356_32
  S10: val2 = 3716424383_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1073775743_32
  S11: state_counter = 11_10
  S11: val1 = 1090519040_32
  S11: val2 = 1610612736_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 8425087_32
  S12: state_counter = 12_10
  S12: val1 = 2097152_32
  S12: val2 = 536870912_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073742975_32
  S13: state_counter = 13_10
  S13: val1 = 1073741824_32
  S13: val2 = 1073741824_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 127_32
  S14: state_counter = 14_10
  S14: val1 = 0_32
  S14: val2 = 0_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073742975_32
  S15: state_counter = 15_10
  S15: val1 = 3221225472_32
  S15: val2 = 1073741824_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262723711_32
  S16: state_counter = 16_10
  S16: val1 = 0_32
  S16: val2 = 0_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32
  S17: val2 = 1073741824_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 127_32
  S18: state_counter = 18_10
  S18: val1 = 0_32
  S18: val2 = 0_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 3288325951_32
  S19: val2 = 3288325951_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 3716424367_32
  S20: val2 = 3716424383_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 134230143_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 138416255_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTU.vcd
[runlim] sample:		126.9 time, 7890.2 real, 2555.2 MB
  Test for SLTU using testing-workflow/bug-injection-patches/alu-bug-injected_0_SLTU.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLTU:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SLTU.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..66e351f 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -28,7 +28,7 @@ module alu(
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
-        `ALU_OP_SLTU : out = {31'b0, in1 < in2};
+        `ALU_OP_SLTU : out = {31'b0, in1 != in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
         default : out = 0;
       endcase // case op
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		5.8 time, 7900.2 real, 202.6 MB
[runlim] sample:		15.8 time, 7910.2 real, 202.6 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTU" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.6 time, 7920.2 real, 357.5 MB
__[runlim] sample:		16.7 time, 7930.2 real, 539.2 MB
___[runlim] sample:		26.7 time, 7940.2 real, 761.6 MB
__[runlim] sample:		36.6 time, 7950.2 real, 999.1 MB
___[runlim] sample:		46.6 time, 7960.2 real, 1205.0 MB
__[runlim] sample:		56.6 time, 7970.2 real, 1455.0 MB
_[runlim] sample:		66.6 time, 7980.2 real, 1622.8 MB
__[runlim] sample:		76.6 time, 7990.2 real, 1853.6 MB
__[runlim] sample:		86.6 time, 8000.2 real, 2072.8 MB
_[runlim] sample:		96.6 time, 8010.2 real, 2156.6 MB
_[runlim] sample:		106.6 time, 8020.2 real, 2231.7 MB
_..[runlim] sample:		116.6 time, 8030.2 real, 2471.9 MB
..[runlim] sample:		126.6 time, 8040.2 real, 2675.4 MB
.. UNKNOWN

*** SUMMARY ***

** Problem Single Instruction for SLTU **
Description: "Check for Single Instruction"
Result: UNKNOWN
BMC depth: 25
[runlim] sample:		136.6 time, 8050.2 real, 2914.0 MB
  Test for SLTU using testing-workflow/bug-injection-patches/alu-bug-injected_1_SLTU.patch failed, CoSA proved the property unexpectedly.
  Bug injection patch file for instruction SLTU:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SLTU.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..0b6c2e8 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -195,7 +195,7 @@ module decoder(
         `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
-        `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
+        `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
         `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		5.6 time, 8060.2 real, 213.9 MB
[runlim] sample:		15.6 time, 8070.2 real, 202.7 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTU" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.4 time, 8080.2 real, 356.5 MB
__[runlim] sample:		16.4 time, 8090.2 real, 536.9 MB
___[runlim] sample:		26.4 time, 8100.2 real, 760.4 MB
__[runlim] sample:		36.4 time, 8110.2 real, 1015.7 MB
___[runlim] sample:		46.4 time, 8120.2 real, 1246.4 MB
__[runlim] sample:		56.4 time, 8130.2 real, 1474.5 MB
__[runlim] sample:		66.4 time, 8140.2 real, 1639.2 MB
_[runlim] sample:		76.4 time, 8150.2 real, 1862.3 MB
__[runlim] sample:		86.4 time, 8160.2 real, 2066.3 MB
_[runlim] sample:		96.4 time, 8170.2 real, 2188.1 MB
_[runlim] sample:		106.4 time, 8180.2 real, 2351.2 MB
_..[runlim] sample:		116.4 time, 8190.2 real, 2555.3 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTU **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 536879231_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 32_32][16_5 := 524320_32][24_5 := 1342238720_32][25_5 := 268496896_32][2_5 := 2147483648_32][30_5 := 16_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 1073750143_32
  S1: state_counter = 1_10
  S1: val2 = 268574721_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 270536831_32
  S2: state_counter = 2_10
  S2: val1 = 16777216_32
  S2: val2 = 2_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2149585023_32
  S3: state_counter = 3_10
  S3: val1 = 67108865_32
  S3: val2 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134221951_32
  S4: state_counter = 4_10
  S4: val1 = 1_32
  S4: val2 = 0_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 2147487871_32
  S5: state_counter = 5_10
  S5: val1 = 1207959552_32
  S5: val2 = 2148532224_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25704243_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 14_5
  S8: state_counter = 8_10
  S8: val1 = 1073807360_32
  S8: val2 = 1207959552_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 524290_32
  S9: val2 = 1073807297_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 0_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 4522111_32
  S11: state_counter = 11_10
  S11: val1 = 524322_32
  S11: val2 = 1073872896_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 4259646719_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32
  S12: val2 = 1073807296_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 524320_32
  S13: val2 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 14713727_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1342238720_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 142606975_32
  S15: state_counter = 15_10
  S15: val1 = 524320_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262068351_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1342242688_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 16777343_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 1073803264_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 8388735_32
  S18: state_counter = 18_10
  S18: val1 = 8388608_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1074266148_32
  S19: val2 = 268496900_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 524320_32
  S20: val2 = 1342238720_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1060991_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 32_32][14_5 := 1342763040_32][16_5 := 524320_32][24_5 := 1342238720_32][25_5 := 268496896_32][2_5 := 2147483648_32][30_5 := 16_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTU.vcd
[runlim] sample:		126.4 time, 8200.2 real, 2599.4 MB
  Test for SLTU using testing-workflow/bug-injection-patches/alu-bug-injected_2_SLTU.patch succeeded, CoSA found a counterexample as expected.

Operator name: SLT
  Bug injection patch file for instruction SLT:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SLT.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..e51ec81 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -26,7 +26,7 @@ module alu(
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
-        `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
+        `ALU_OP_SLT : out = {31'b0, $signed(in1) != $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		5.5 time, 8210.2 real, 214.8 MB
[runlim] sample:		15.4 time, 8220.2 real, 202.2 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLT" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.2 time, 8230.2 real, 345.9 MB
__[runlim] sample:		16.2 time, 8240.2 real, 534.0 MB
___[runlim] sample:		26.2 time, 8250.2 real, 751.9 MB
__[runlim] sample:		36.1 time, 8260.2 real, 1050.5 MB
__[runlim] sample:		46.1 time, 8270.2 real, 1144.4 MB
___[runlim] sample:		56.1 time, 8280.2 real, 1461.6 MB
_[runlim] sample:		66.1 time, 8290.2 real, 1606.6 MB
__[runlim] sample:		76.1 time, 8300.2 real, 1836.6 MB
_[runlim] sample:		86.1 time, 8310.2 real, 2028.5 MB
__[runlim] sample:		96.1 time, 8320.2 real, 2105.9 MB
_[runlim] sample:		106.1 time, 8330.2 real, 2265.2 MB
_.[runlim] sample:		116.1 time, 8340.2 real, 2386.8 MB
..[runlim] sample:		126.1 time, 8350.2 real, 2681.6 MB
... UNKNOWN

*** SUMMARY ***

** Problem Single Instruction for SLT **
Description: "Check for Single Instruction"
Result: UNKNOWN
BMC depth: 25
[runlim] sample:		136.1 time, 8360.2 real, 3123.2 MB
  Test for SLT using testing-workflow/bug-injection-patches/alu-bug-injected_1_SLT.patch failed, CoSA proved the property unexpectedly.
  Bug injection patch file for instruction SLT:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SLT.patch
  Original Verilog file name: alu.v
HEAD is now at 4a8e862 added logfile
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..74aeaef 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -26,7 +26,7 @@ module alu(
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
-        `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
+        `ALU_OP_SLT : out = {31'b0, $signed(in1) > $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		4.2 time, 8370.2 real, 192.3 MB
[runlim] sample:		14.2 time, 8380.2 real, 202.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLT" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		4.9 time, 8390.2 real, 271.8 MB
__[runlim] sample:		14.9 time, 8400.2 real, 534.1 MB
__[runlim] sample:		24.9 time, 8410.2 real, 746.0 MB
___[runlim] sample:		34.9 time, 8420.2 real, 986.8 MB
__[runlim] sample:		44.9 time, 8430.2 real, 1142.4 MB
__[runlim] sample:		54.9 time, 8440.2 real, 1435.6 MB
__[runlim] sample:		64.9 time, 8450.2 real, 1564.4 MB
__[runlim] sample:		74.9 time, 8460.2 real, 1864.5 MB
__[runlim] sample:		84.9 time, 8470.2 real, 2081.9 MB
_[runlim] sample:		94.9 time, 8480.2 real, 2146.6 MB
_[runlim] sample:		104.9 time, 8490.2 real, 2336.1 MB
_..[runlim] sample:		114.9 time, 8500.2 real, 2514.9 MB
[runlim] sample:		124.9 time, 8510.2 real, 2574.8 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLT **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268456063_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 1082130432_32][19_5 := 67108880_32][24_5 := 1610612752_32][4_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 1077936128_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 536870912_32
  S2: val2 = 301989888_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32
  S3: val2 = 8388608_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147487871_32
  S4: state_counter = 4_10
  S4: val1 = 262144_32
  S4: val2 = 67108864_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1090520191_32
  S5: state_counter = 5_10
  S5: val1 = 1610612736_32
  S5: val2 = 1074003968_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25698867_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 4_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32
  S8: val2 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 8388608_32
  S9: val2 = 134217728_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 1207959552_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 20250751_32
  S11: state_counter = 11_10
  S11: val1 = 1082130432_32
  S11: val2 = 1610612756_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 20254335_32
  S12: state_counter = 12_10
  S12: val1 = 4194304_32
  S12: val2 = 1610612736_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 524415_32
  S13: state_counter = 13_10
  S13: val1 = 69206032_32
  S13: val2 = 67108864_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 4325503_32
  S14: state_counter = 14_10
  S14: val1 = 0_32
  S14: val2 = 1610612816_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 1082130432_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262068351_32
  S16: state_counter = 16_10
  S16: val1 = 1610612736_32
  S16: val2 = 1207959552_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 8519807_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 65663_32
  S18: state_counter = 18_10
  S18: val1 = 1610612736_32
  S18: val2 = 536870912_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 0_32
  S19: val2 = 16_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 16777343_32
  S20: state_counter = 20_10
  S20: val1 = 1082130432_32
  S20: val2 = 1610612752_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 8319_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 134221951_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 1082130432_32][19_5 := 67108880_32][24_5 := 1610612752_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLT.vcd
  Test for SLT using testing-workflow/bug-injection-patches/alu-bug-injected_0_SLT.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLT:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SLT.patch
  Original Verilog file name: decoder.v
HEAD is now at 4a8e862 added logfile
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..388d8ff 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -194,7 +194,7 @@ module decoder(
       case (funct3)
         `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
-        `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
+        `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-21989.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		3.6 time, 8520.2 real, 192.1 MB
[runlim] sample:		13.5 time, 8530.2 real, 202.3 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLT" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		4.3 time, 8540.2 real, 262.2 MB
__[runlim] sample:		14.3 time, 8550.2 real, 524.5 MB
__[runlim] sample:		24.3 time, 8560.2 real, 755.3 MB
___[runlim] sample:		34.3 time, 8570.2 real, 995.6 MB
__[runlim] sample:		44.3 time, 8580.2 real, 1143.5 MB
__[runlim] sample:		54.3 time, 8590.2 real, 1446.6 MB
__[runlim] sample:		64.2 time, 8600.2 real, 1607.4 MB
__[runlim] sample:		74.2 time, 8610.2 real, 1863.6 MB
_[runlim] sample:		84.2 time, 8620.2 real, 2028.2 MB
__[runlim] sample:		94.2 time, 8630.2 real, 2111.8 MB
_[runlim] sample:		104.2 time, 8640.2 real, 2231.4 MB
_..[runlim] sample:		114.2 time, 8650.2 real, 2422.6 MB
[runlim] sample:		124.2 time, 8660.2 real, 2502.8 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLT **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2149589119_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 16_32][15_5 := 16793600_32][8_5 := 1073741824_32][9_5 := 278528_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147496063_32
  S1: state_counter = 1_10
  S1: val2 = 1082130432_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 268435456_32
  S2: val2 = 134217728_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32
  S3: val2 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 2147483648_32
  S4: val2 = 3221225472_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1140851839_32
  S5: state_counter = 5_10
  S5: val1 = 1610612736_32
  S5: val2 = 1107296256_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 16033715_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 15_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32
  S8: val2 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 2155872256_32
  S9: val2 = 67108864_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 3221225472_32
  S10: val2 = 4194304_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 14942335_32
  S11: state_counter = 11_10
  S11: val1 = 2097152_32
  S11: val2 = 16793608_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 14683007_32
  S12: state_counter = 12_10
  S12: val1 = 1074003968_32
  S12: val2 = 1074135040_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 278528_32
  S13: val2 = 17170432_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 127_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 8388735_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 16793600_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1074856063_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 268435456_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 268439679_32
  S18: state_counter = 18_10
  S18: val1 = 536870912_32
  S18: val2 = 1073741824_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073746047_32
  S19: state_counter = 19_10
  S19: val1 = 67108864_32
  S19: val2 = 536870912_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 67113087_32
  S20: state_counter = 20_10
  S20: val1 = 278528_32
  S20: val2 = 16793600_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 8319_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[14_5 := 16_32][15_5 := 17039360_32][8_5 := 1073741824_32][9_5 := 278528_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLT.vcd
  Test for SLT using testing-workflow/bug-injection-patches/alu-bug-injected_2_SLT.patch succeeded, CoSA found a counterexample as expected.

Operator name: LW
  No bug injection patches found for instruction LW, skipping tests.
Operator name: SW
  No bug injection patches found for instruction SW, skipping tests.
Operator name: MUL_V1
  No bug injection patches found for instruction MUL_V1, skipping tests.
Operator name: MUL_V2
  No bug injection patches found for instruction MUL_V2, skipping tests.
Operator name: MUL_V3
  No bug injection patches found for instruction MUL_V3, skipping tests.
Operator name: MUL_V4
  No bug injection patches found for instruction MUL_V4, skipping tests.
Cleaning up temporary files.
  cleanup: resetting any local changes
HEAD is now at 4a8e862 added logfile
[runlim] end:			Mon Apr  8 18:43:38 2019
[runlim] status:		ok
[runlim] result:		0
[runlim] children:		194971
[runlim] real:			8668.55 seconds
[runlim] time:			145.22 seconds
[runlim] space:			3123.2 MB
[runlim] samples:		86683
