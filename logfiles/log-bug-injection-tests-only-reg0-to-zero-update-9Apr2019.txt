[runlim] version:		1.10
[runlim] time limit:		311040000 seconds
[runlim] real time limit:	311040000 seconds
[runlim] space limit:		32164 MB
[runlim] argv[0]:		testing-workflow/run-si-tests.sh
[runlim] argv[1]:		cosa/single.txt
[runlim] argv[2]:		testing-workflow/bug-injection-patches
[runlim] argv[3]:		ridecore-original-src/
[runlim] start:			Tue Apr  9 13:15:31 2019
[runlim] main pid:		9370
Operator name: ADDI
  Bug injection patch file for instruction ADDI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_ADDI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..30dfdb1 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -16,7 +16,7 @@ module alu(
 
    always @(*) begin
       case (op)
-        `ALU_OP_ADD : out = in1 + in2;
+        `ALU_OP_ADD : out = in1 - in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		9.9 time, 10.1 real, 202.2 MB
[runlim] sample:		0.5 time, 20.1 real, 57.8 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ADDI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		10.5 time, 30.1 real, 467.3 MB
__[runlim] sample:		20.5 time, 40.1 real, 676.9 MB
___[runlim] sample:		30.5 time, 50.1 real, 821.7 MB
__[runlim] sample:		40.5 time, 60.1 real, 1089.1 MB
___[runlim] sample:		50.5 time, 70.1 real, 1332.1 MB
_[runlim] sample:		60.5 time, 80.1 real, 1539.5 MB
__[runlim] sample:		70.5 time, 90.1 real, 1708.7 MB
_[runlim] sample:		80.5 time, 100.1 real, 1868.8 MB
__[runlim] sample:		90.5 time, 110.1 real, 2083.0 MB
_[runlim] sample:		100.5 time, 120.1 real, 2106.9 MB
_[runlim] sample:		110.5 time, 130.1 real, 2263.2 MB
_..[runlim] sample:		120.4 time, 140.1 real, 2424.2 MB
[runlim] sample:		130.4 time, 150.1 real, 2498.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for ADDI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 67133567_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 131072_32][13_5 := 16777216_32][15_5 := 2147483648_32][17_5 := 2_32][1_5 := 1024_32][25_5 := 2048_32][5_5 := 1984_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 268464255_32
  S1: state_counter = 1_10
  S1: val1 = 2214608897_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 134221951_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268435583_32
  S3: state_counter = 3_10
  S3: val1 = 268435456_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147487871_32
  S4: state_counter = 4_10
  S4: val1 = 402653184_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 268435583_32
  S5: state_counter = 5_10
  S5: val1 = 134217728_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1207959552_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 586514579_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 559_32
  S8: rd_copy = 1_5
  S8: state_counter = 8_10
  S8: val1 = 1107820544_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 131104_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1140850688_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 22151295_32
  S11: state_counter = 11_10
  S11: val1 = 131074_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2027061375_32
  S12: state_counter = 12_10
  S12: val1 = 131072_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 262271_32
  S13: state_counter = 13_10
  S13: val1 = 134217728_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2131263615_32
  S14: state_counter = 14_10
  S14: val1 = 67108864_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 127_32
  S15: state_counter = 15_10
  S15: val1 = 131072_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1099956351_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 131072_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 546345087_32
  S18: state_counter = 18_10
  S18: val1 = 2147483648_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 33558655_32
  S19: state_counter = 19_10
  S19: val1 = 131328_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 134221951_32
  S20: state_counter = 20_10
  S20: val1 = 131072_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 127_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 131072_32][13_5 := 16777216_32][15_5 := 2147483648_32][17_5 := 2_32][1_5 := 130513_32][25_5 := 2048_32][5_5 := 1984_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for ADDI.vcd
  Test for ADDI using testing-workflow/bug-injection-patches/alu-bug-injected_0_ADDI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction ADDI:  testing-workflow/bug-injection-patches/alu-bug-injected_2_ADDI.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..913efef 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -192,7 +192,7 @@ module decoder(
 
    always @(*) begin
       case (funct3)
-        `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
+        `RV32_FUNCT3_ADD_SUB : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		1.3 time, 160.1 real, 127.3 MB
[runlim] sample:		11.3 time, 170.1 real, 202.4 MB
[runlim] sample:		1.8 time, 180.1 real, 84.9 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ADDI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		11.8 time, 190.1 real, 469.0 MB
___[runlim] sample:		21.8 time, 200.1 real, 686.2 MB
__[runlim] sample:		31.8 time, 210.1 real, 837.7 MB
___[runlim] sample:		41.8 time, 220.1 real, 1108.5 MB
__[runlim] sample:		51.8 time, 230.1 real, 1336.1 MB
_[runlim] sample:		61.8 time, 240.1 real, 1543.8 MB
__[runlim] sample:		71.8 time, 250.1 real, 1624.7 MB
_[runlim] sample:		81.8 time, 260.1 real, 1863.7 MB
__[runlim] sample:		91.8 time, 270.1 real, 2056.2 MB
_[runlim] sample:		101.8 time, 280.1 real, 2151.6 MB
_[runlim] sample:		111.8 time, 290.1 real, 2264.4 MB
_..[runlim] sample:		121.7 time, 300.1 real, 2486.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for ADDI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 136343679_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[13_5 := 16_32][15_5 := 1073741840_32][1_5 := 1_32][5_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 134221951_32
  S1: state_counter = 1_10
  S1: val1 = 1619263488_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 1623195648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 134221951_32
  S3: state_counter = 3_10
  S3: val1 = 8388608_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268439679_32
  S4: state_counter = 4_10
  S4: val1 = 268435456_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 536875135_32
  S5: state_counter = 5_10
  S5: val1 = 134217728_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 83001747_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 79_32
  S8: rd_copy = 3_5
  S8: state_counter = 8_10
  S8: val1 = 1207959552_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073807360_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 3238002688_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 29360767_32
  S11: state_counter = 11_10
  S11: val1 = 1090519040_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2127563647_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 32895_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 4194431_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1073873023_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 3221487743_32
  S17: state_counter = 17_10
  S17: val1 = 67108864_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 3221524607_32
  S18: state_counter = 18_10
  S18: val1 = 1073741824_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1107300479_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 536875135_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 127_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for ADDI.vcd
[runlim] sample:		131.8 time, 310.1 real, 2558.6 MB
  Test for ADDI using testing-workflow/bug-injection-patches/alu-bug-injected_2_ADDI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction ADDI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_ADDI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..8288320 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -16,7 +16,7 @@ module alu(
 
    always @(*) begin
       case (op)
-        `ALU_OP_ADD : out = in1 + in2;
+        `ALU_OP_ADD : out = in1 << in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		4.6 time, 320.1 real, 191.5 MB
[runlim] sample:		14.6 time, 330.1 real, 201.9 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ADDI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		5.2 time, 340.1 real, 282.5 MB
__[runlim] sample:		15.2 time, 350.1 real, 530.2 MB
__[runlim] sample:		25.2 time, 360.1 real, 746.2 MB
___[runlim] sample:		35.2 time, 370.1 real, 979.2 MB
__[runlim] sample:		45.1 time, 380.1 real, 1168.8 MB
___[runlim] sample:		55.1 time, 390.1 real, 1466.1 MB
_[runlim] sample:		65.1 time, 400.1 real, 1646.1 MB
__[runlim] sample:		75.1 time, 410.1 real, 1835.6 MB
_[runlim] sample:		85.1 time, 420.1 real, 1985.5 MB
_[runlim] sample:		95.1 time, 430.1 real, 2137.7 MB
__[runlim] sample:		105.1 time, 440.1 real, 2240.6 MB
_.[runlim] sample:		115.1 time, 450.1 real, 2379.1 MB
.[runlim] sample:		125.1 time, 460.1 real, 2512.2 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for ADDI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 134217855_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 8388640_32][17_5 := 1073741856_32][1_5 := 2_32][24_5 := 32_32][2_5 := 2147483648_32][8_5 := 1073741856_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 67113087_32
  S1: state_counter = 1_10

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 268435456_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134221951_32
  S4: state_counter = 4_10
  S4: val1 = 134217728_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554483_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 2165049491_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 4294965264_32
  S8: rd_copy = 17_5
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3221250048_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 40959_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1091568767_32
  S11: state_counter = 11_10
  S11: val1 = 1073758208_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 4279796607_32
  S12: state_counter = 12_10
  S12: val1 = 48892_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073743487_32
  S13: state_counter = 13_10
  S13: val1 = 3221225472_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 4262560639_32
  S14: state_counter = 14_10
  S14: val1 = 0_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1644168447_32
  S15: state_counter = 15_10
  S15: val1 = 1073758208_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4228907135_32
  S16: state_counter = 16_10
  S16: val1 = 1074003968_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 819327_32
  S18: state_counter = 18_10
  S18: val1 = 0_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1073741856_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 16777343_32
  S20: state_counter = 20_10
  S20: val1 = 32_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 127_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 8388640_32][1_5 := 2_32][24_5 := 32_32][2_5 := 2147483648_32][8_5 := 1073741856_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for ADDI.vcd
[runlim] sample:		135.1 time, 470.1 real, 2006.4 MB
  Test for ADDI using testing-workflow/bug-injection-patches/alu-bug-injected_1_ADDI.patch succeeded, CoSA found a counterexample as expected.

Operator name: ANDI
  Bug injection patch file for instruction ANDI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_ANDI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..ee4a54e 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -20,7 +20,7 @@ module alu(
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
-        `ALU_OP_AND : out = in1 & in2;
+        `ALU_OP_AND : out = in1 ^ in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		8.3 time, 480.1 real, 202.1 MB
[runlim] sample:		18.3 time, 490.1 real, 257.6 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ANDI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		8.1 time, 500.1 real, 357.4 MB
___[runlim] sample:		18.1 time, 510.1 real, 584.0 MB
__[runlim] sample:		28.1 time, 520.1 real, 784.0 MB
___[runlim] sample:		38.0 time, 530.1 real, 1009.2 MB
__[runlim] sample:		48.0 time, 540.1 real, 1204.1 MB
__[runlim] sample:		58.0 time, 550.1 real, 1462.0 MB
_[runlim] sample:		68.0 time, 560.1 real, 1623.8 MB
__[runlim] sample:		78.0 time, 570.1 real, 1859.7 MB
_[runlim] sample:		88.0 time, 580.1 real, 2058.3 MB
__[runlim] sample:		98.0 time, 590.1 real, 2118.1 MB
_[runlim] sample:		108.0 time, 600.1 real, 2214.1 MB
_.[runlim] sample:		118.0 time, 610.1 real, 2291.1 MB
.[runlim] sample:		128.0 time, 620.1 real, 2520.3 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for ANDI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 402681983_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1073741903_32][15_5 := 1073741824_32][16_5 := 1073741824_32][1_5 := 262144_32][2_5 := 2147483648_32][8_5 := 1_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 268439679_32
  S1: state_counter = 1_10

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 1074266239_32
  S2: state_counter = 2_10
  S2: val1 = 67108864_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536875135_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147487871_32
  S4: state_counter = 4_10
  S4: val1 = 1140850688_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 134221951_32
  S5: state_counter = 5_10
  S5: val1 = 134217728_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 83194387_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 79_32
  S8: rd_copy = 4_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1207959552_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741888_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 16777343_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 264063_32
  S12: state_counter = 12_10
  S12: val1 = 1073741888_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 4194431_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 21233791_32
  S14: state_counter = 14_10
  S14: val1 = 1073741896_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 33554559_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1074299007_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 2148012159_32
  S18: state_counter = 18_10
  S18: val1 = 2147483648_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 268439679_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 2147487871_32
  S20: state_counter = 20_10
  S20: val1 = 1073741903_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 67137663_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1073741903_32][15_5 := 1073741824_32][16_5 := 1073741824_32][1_5 := 262144_32][2_5 := 2147483648_32][4_5 := 1073741824_32][8_5 := 1_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for ANDI.vcd
[runlim] sample:		138.0 time, 630.1 real, 2437.7 MB
  Test for ANDI using testing-workflow/bug-injection-patches/alu-bug-injected_0_ANDI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction ANDI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_ANDI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..ec3f314 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -20,7 +20,7 @@ module alu(
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
-        `ALU_OP_AND : out = in1 & in2;
+        `ALU_OP_AND : out = in1 + in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		6.6 time, 640.1 real, 202.1 MB
[runlim] sample:		16.6 time, 650.1 real, 202.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ANDI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		7.0 time, 660.1 real, 357.8 MB
__[runlim] sample:		17.0 time, 670.1 real, 533.2 MB
___[runlim] sample:		27.0 time, 680.1 real, 757.4 MB
__[runlim] sample:		37.0 time, 690.1 real, 1002.5 MB
___[runlim] sample:		47.0 time, 700.1 real, 1231.4 MB
__[runlim] sample:		57.0 time, 710.1 real, 1447.9 MB
_[runlim] sample:		67.0 time, 720.1 real, 1605.4 MB
__[runlim] sample:		77.0 time, 730.1 real, 1872.2 MB
_[runlim] sample:		87.0 time, 740.1 real, 2050.2 MB
_[runlim] sample:		97.0 time, 750.1 real, 2066.8 MB
_[runlim] sample:		107.0 time, 760.1 real, 2166.1 MB
_[runlim] sample:		116.9 time, 770.1 real, 2404.8 MB
_..[runlim] sample:		126.9 time, 780.1 real, 2551.8 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for ANDI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 2684358783_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 134217728_32][15_5 := 2147483648_32][1_5 := 524288_32][30_5 := 2_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 536870913_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 134221951_32
  S2: state_counter = 2_10
  S2: val1 = 1107296256_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536875135_32
  S3: state_counter = 3_10
  S3: val1 = 3221225472_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147487871_32
  S4: state_counter = 4_10
  S4: val1 = 134217728_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1082131583_32
  S5: state_counter = 5_10
  S5: val1 = 1149239296_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 360083_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 536870912_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 29_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 134217728_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1342177280_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 491647_32
  S11: state_counter = 11_10
  S11: val1 = 134217730_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2124908671_32
  S12: state_counter = 12_10
  S12: val1 = 134217728_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 2097279_32
  S13: state_counter = 13_10
  S13: val1 = 1610612736_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2158952575_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 134217984_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4280189055_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 134217728_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 8388735_32
  S18: state_counter = 18_10
  S18: val1 = 1207959552_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1073741824_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 134217728_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 67137663_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 134217728_32][15_5 := 2147483648_32][1_5 := 524288_32][29_5 := 134217728_32][30_5 := 2_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for ANDI.vcd
[runlim] sample:		136.9 time, 790.1 real, 2080.7 MB
  Test for ANDI using testing-workflow/bug-injection-patches/alu-bug-injected_1_ANDI.patch succeeded, CoSA found a counterexample as expected.

Operator name: ORI
  Bug injection patch file for instruction ORI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_ORI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..8b912a8 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -19,7 +19,7 @@ module alu(
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
-        `ALU_OP_OR : out = in1 | in2;
+        `ALU_OP_OR : out = in1 ^ in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		8.3 time, 800.1 real, 202.2 MB
[runlim] sample:		18.3 time, 810.1 real, 275.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction For ORI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		9.1 time, 820.1 real, 366.1 MB
___[runlim] sample:		19.1 time, 830.1 real, 624.9 MB
___[runlim] sample:		29.1 time, 840.1 real, 873.1 MB
__[runlim] sample:		39.1 time, 850.1 real, 1083.9 MB
__[runlim] sample:		49.1 time, 860.1 real, 1316.8 MB
__[runlim] sample:		59.1 time, 870.1 real, 1511.1 MB
__[runlim] sample:		69.1 time, 880.1 real, 1788.5 MB
__[runlim] sample:		79.1 time, 890.1 real, 1954.2 MB
_[runlim] sample:		89.1 time, 900.1 real, 2120.9 MB
_[runlim] sample:		99.1 time, 910.1 real, 2182.5 MB
_[runlim] sample:		109.1 time, 920.1 real, 2385.9 MB
_..[runlim] sample:		119.1 time, 930.1 real, 2488.1 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction For ORI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 536899711_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 262144_32][17_5 := 4_32][1_5 := 16384_32][4_5 := 8209_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 134221951_32
  S1: state_counter = 1_10
  S1: val1 = 536879104_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 1073741824_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 100663296_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1610613887_32
  S4: state_counter = 4_10
  S4: val1 = 1073872896_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554995_32
  S6: state_counter = 6_10
  S6: val1 = 536870912_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1207955_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1342177280_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 1_32
  S8: rd_copy = 29_5
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073741824_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 276824064_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1075872895_32
  S11: state_counter = 11_10
  S11: val1 = 1073741824_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 10522239_32
  S12: state_counter = 12_10
  S12: val1 = 8208_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 536872575_32
  S13: state_counter = 13_10
  S13: val1 = 1073741824_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 1141407871_32
  S14: state_counter = 14_10
  S14: val1 = 0_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073747071_32
  S15: state_counter = 15_10
  S15: val1 = 1610612736_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262363263_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 2097279_32
  S18: state_counter = 18_10
  S18: val1 = 0_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1073750033_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 16777343_32
  S20: state_counter = 20_10
  S20: val1 = 8209_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 24703_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1073746047_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 262144_32][17_5 := 4_32][1_5 := 16384_32][29_5 := 8208_32][4_5 := 8209_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction For ORI.vcd
[runlim] sample:		129.1 time, 940.1 real, 2432.8 MB
  Test for ORI using testing-workflow/bug-injection-patches/alu-bug-injected_1_ORI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction ORI:  testing-workflow/bug-injection-patches/alu-bug-injected_2_ORI.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..286657b 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -198,7 +198,7 @@ module decoder(
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
-        `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
+        `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_AND;
         default : alu_op_arith = `ALU_OP_ADD;
       endcase // case (funct3)
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		6.7 time, 950.1 real, 202.3 MB
[runlim] sample:		16.7 time, 960.1 real, 202.3 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction For ORI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		7.4 time, 970.1 real, 357.9 MB
___[runlim] sample:		17.4 time, 980.1 real, 583.3 MB
__[runlim] sample:		27.4 time, 990.1 real, 772.2 MB
___[runlim] sample:		37.4 time, 1000.1 real, 1017.7 MB
__[runlim] sample:		47.4 time, 1010.1 real, 1195.0 MB
__[runlim] sample:		57.3 time, 1020.1 real, 1462.5 MB
__[runlim] sample:		67.3 time, 1030.1 real, 1626.5 MB
_[runlim] sample:		77.3 time, 1040.1 real, 1862.8 MB
__[runlim] sample:		87.3 time, 1050.1 real, 2052.6 MB
_[runlim] sample:		97.3 time, 1060.1 real, 2165.1 MB
_[runlim] sample:		107.3 time, 1070.1 real, 2345.6 MB
_..[runlim] sample:		117.3 time, 1080.1 real, 2447.3 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction For ORI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 136315007_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[30_5 := 2147483648_32][5_5 := 1073742398_32][8_5 := 16_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 134221951_32
  S1: state_counter = 1_10

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 536870912_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 553652351_32
  S3: state_counter = 3_10
  S3: val1 = 2281701376_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1075840127_32
  S4: state_counter = 4_10
  S4: val1 = 268435456_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1140851839_32
  S5: state_counter = 5_10
  S5: val1 = 0_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 602073747_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 574_32
  S8: rd_copy = 21_5
  S8: state_counter = 8_10
  S8: val1 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073742399_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1090519040_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 127_32
  S11: state_counter = 11_10
  S11: val1 = 1207959552_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2122320767_32
  S12: state_counter = 12_10
  S12: val1 = 1073742392_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2151710847_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 2097279_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4261412991_32
  S16: state_counter = 16_10
  S16: val1 = 1073742386_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 8388735_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 721023_32
  S18: state_counter = 18_10
  S18: val1 = 536870912_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 32_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073742398_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 16801919_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[21_5 := 1073741824_32][30_5 := 2147483648_32][5_5 := 1073742398_32][8_5 := 16_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction For ORI.vcd
[runlim] sample:		127.3 time, 1090.1 real, 2570.9 MB
  Test for ORI using testing-workflow/bug-injection-patches/alu-bug-injected_2_ORI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction ORI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_ORI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..9893173 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -19,7 +19,7 @@ module alu(
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
-        `ALU_OP_OR : out = in1 | in2;
+        `ALU_OP_OR : out = in1 & in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		4.7 time, 1100.1 real, 191.7 MB
[runlim] sample:		14.7 time, 1110.1 real, 201.8 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction For ORI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		5.6 time, 1120.1 real, 305.5 MB
__[runlim] sample:		15.5 time, 1130.1 real, 535.6 MB
___[runlim] sample:		25.5 time, 1140.1 real, 750.8 MB
__[runlim] sample:		35.5 time, 1150.1 real, 1037.1 MB
___[runlim] sample:		45.5 time, 1160.1 real, 1227.8 MB
__[runlim] sample:		55.5 time, 1170.1 real, 1448.4 MB
_[runlim] sample:		65.5 time, 1180.1 real, 1604.9 MB
__[runlim] sample:		75.5 time, 1190.1 real, 1868.3 MB
__[runlim] sample:		85.5 time, 1200.1 real, 2079.8 MB
_[runlim] sample:		95.5 time, 1210.1 real, 2163.4 MB
_[runlim] sample:		105.5 time, 1220.1 real, 2268.2 MB
_..[runlim] sample:		115.5 time, 1230.1 real, 2448.1 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction For ORI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 134242431_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[24_5 := 1073741824_32][29_5 := 2097152_32][3_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 67113087_32
  S1: state_counter = 1_10
  S1: val1 = 33554432_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 1073746047_32
  S2: state_counter = 2_10
  S2: val1 = 1073741824_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536875135_32
  S3: state_counter = 3_10
  S3: val1 = 1082130432_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268439679_32
  S4: state_counter = 4_10
  S4: val1 = 67108864_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 536871039_32
  S5: state_counter = 5_10
  S5: val1 = 536870912_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 601645203_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 573_32
  S8: rd_copy = 1_5
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073872896_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741840_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 13107327_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 12583039_32
  S12: state_counter = 12_10
  S12: val1 = 1073741856_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 17301631_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 524415_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1073741951_32
  S16: state_counter = 16_10
  S16: val1 = 1073742080_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 2148536575_32
  S18: state_counter = 18_10
  S18: val1 = 1082130432_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 2155876479_32
  S19: state_counter = 19_10
  S19: val1 = 536870912_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 536875135_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 24703_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction For ORI.vcd
[runlim] sample:		125.5 time, 1240.1 real, 2551.2 MB
  Test for ORI using testing-workflow/bug-injection-patches/alu-bug-injected_0_ORI.patch succeeded, CoSA found a counterexample as expected.

Operator name: XORI
  Bug injection patch file for instruction XORI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_XORI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..b1154a3 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -18,7 +18,7 @@ module alu(
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
-        `ALU_OP_XOR : out = in1 ^ in2;
+        `ALU_OP_XOR : out = in1 | in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		5.2 time, 1250.1 real, 209.9 MB
[runlim] sample:		15.2 time, 1260.1 real, 202.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for XORI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.1 time, 1270.1 real, 353.4 MB
__[runlim] sample:		16.1 time, 1280.1 real, 545.4 MB
___[runlim] sample:		26.1 time, 1290.1 real, 751.2 MB
__[runlim] sample:		36.0 time, 1300.1 real, 1002.0 MB
__[runlim] sample:		46.0 time, 1310.1 real, 1137.2 MB
__[runlim] sample:		56.0 time, 1320.1 real, 1423.8 MB
__[runlim] sample:		66.1 time, 1330.1 real, 1605.7 MB
__[runlim] sample:		76.0 time, 1340.1 real, 1860.7 MB
_[runlim] sample:		86.0 time, 1350.1 real, 2030.6 MB
_[runlim] sample:		96.0 time, 1360.1 real, 2065.1 MB
_[runlim] sample:		106.0 time, 1370.1 real, 2216.7 MB
_[runlim] sample:		116.0 time, 1380.1 real, 2299.7 MB
_..[runlim] sample:		126.0 time, 1390.1 real, 2508.8 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for XORI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 134234239_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 2147483648_32][19_5 := 1073741824_32][1_5 := 2147483648_32][29_5 := 1073742336_32][2_5 := 512_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 67113087_32
  S1: state_counter = 1_10
  S1: val1 = 536870913_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 268439679_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 67113087_32
  S3: state_counter = 3_10
  S3: val1 = 536870912_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 67108864_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073874047_32
  S5: state_counter = 5_10
  S5: val1 = 1107296256_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 537837971_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 512_32
  S8: rd_copy = 3_5
  S8: state_counter = 8_10
  S8: val1 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073742341_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 3221225472_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 28311679_32
  S11: state_counter = 11_10
  S11: val1 = 1073742354_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2125465599_32
  S12: state_counter = 12_10
  S12: val1 = 1073741856_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 127_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 25198719_32
  S14: state_counter = 14_10
  S14: val1 = 1610612736_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 135266431_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 2130047_32
  S16: state_counter = 16_10
  S16: val1 = 1073742336_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 134217855_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1094091903_32
  S18: state_counter = 18_10
  S18: val1 = 1073742336_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 127_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 536875135_32
  S20: state_counter = 20_10
  S20: val1 = 1073742336_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 67125375_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 2147483648_32][19_5 := 1073741824_32][1_5 := 2147483648_32][29_5 := 1073742336_32][2_5 := 512_32][3_5 := 1073742336_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for XORI.vcd
[runlim] sample:		136.0 time, 1400.1 real, 2550.3 MB
  Test for XORI using testing-workflow/bug-injection-patches/alu-bug-injected_1_XORI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction XORI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_XORI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..82173e1 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -18,7 +18,7 @@ module alu(
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
-        `ALU_OP_XOR : out = in1 ^ in2;
+        `ALU_OP_XOR : out = in1 + in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		5.5 time, 1410.1 real, 213.7 MB
[runlim] sample:		15.5 time, 1420.1 real, 202.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for XORI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.2 time, 1430.1 real, 353.5 MB
__[runlim] sample:		16.2 time, 1440.1 real, 534.5 MB
___[runlim] sample:		26.2 time, 1450.1 real, 756.6 MB
__[runlim] sample:		36.2 time, 1460.1 real, 1055.8 MB
___[runlim] sample:		46.2 time, 1470.1 real, 1269.8 MB
__[runlim] sample:		56.2 time, 1480.1 real, 1463.3 MB
__[runlim] sample:		66.2 time, 1490.1 real, 1689.6 MB
_[runlim] sample:		76.2 time, 1500.1 real, 1849.8 MB
_[runlim] sample:		86.2 time, 1510.1 real, 1990.1 MB
__[runlim] sample:		96.2 time, 1520.1 real, 2166.9 MB
_[runlim] sample:		106.1 time, 1530.1 real, 2217.6 MB
_..[runlim] sample:		116.1 time, 1540.1 real, 2461.8 MB
[runlim] sample:		126.1 time, 1550.1 real, 2542.0 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for XORI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 2147500159_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 536870912_32][1_5 := 16777216_32][24_5 := 67108864_32][3_5 := 16777216_32][4_5 := 2147483679_32][5_5 := 4_32][7_5 := 16777216_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 134221951_32
  S1: state_counter = 1_10
  S1: val1 = 8192_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 536870912_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 67113087_32
  S3: state_counter = 3_10
  S3: val1 = 268435456_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134221951_32
  S4: state_counter = 4_10
  S4: val1 = 1342177280_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554611_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 3188869139_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 4294966241_32
  S8: rd_copy = 16_5
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1090519040_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 2147483653_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1098941567_32
  S11: state_counter = 11_10
  S11: val1 = 1073741824_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 25267839_32
  S12: state_counter = 12_10
  S12: val1 = 2147483678_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073743487_32
  S13: state_counter = 13_10
  S13: val1 = 1073741824_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 3193439103_32
  S14: state_counter = 14_10
  S14: val1 = 2147483672_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073742975_32
  S15: state_counter = 15_10
  S15: val1 = 1073741824_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4278190207_32
  S16: state_counter = 16_10
  S16: val1 = 0_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1628438655_32
  S18: state_counter = 18_10
  S18: val1 = 0_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 3221225503_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 2147483679_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 536887423_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 538968191_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 2147482624_32][1_5 := 16777216_32][24_5 := 67108864_32][3_5 := 16777216_32][4_5 := 2147483679_32][5_5 := 4_32][7_5 := 16777216_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for XORI.vcd
  Test for XORI using testing-workflow/bug-injection-patches/alu-bug-injected_0_XORI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction XORI:  testing-workflow/bug-injection-patches/alu-bug-injected_2_XORI.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..572eac7 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -196,7 +196,7 @@ module decoder(
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
-        `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
+        `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_OR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
         `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
         `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_AND;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		1.9 time, 1560.1 real, 135.1 MB
[runlim] sample:		11.8 time, 1570.1 real, 202.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for XORI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		2.8 time, 1580.1 real, 112.7 MB
_[runlim] sample:		12.8 time, 1590.1 real, 483.9 MB
___[runlim] sample:		22.8 time, 1600.1 real, 683.6 MB
__[runlim] sample:		32.8 time, 1610.1 real, 899.1 MB
__[runlim] sample:		42.8 time, 1620.1 real, 1075.5 MB
___[runlim] sample:		52.8 time, 1630.1 real, 1323.4 MB
_[runlim] sample:		62.8 time, 1640.1 real, 1526.1 MB
__[runlim] sample:		72.8 time, 1650.1 real, 1791.9 MB
__[runlim] sample:		82.8 time, 1660.1 real, 1961.1 MB
_[runlim] sample:		92.8 time, 1670.1 real, 2160.4 MB
_[runlim] sample:		102.8 time, 1680.1 real, 2206.0 MB
__.[runlim] sample:		112.8 time, 1690.1 real, 2350.7 MB
.[runlim] sample:		122.8 time, 1700.1 real, 2554.4 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for XORI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 136323199_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 131072_32][24_5 := 1073741840_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 134221951_32
  S1: state_counter = 1_10
  S1: val1 = 1048577_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 268439679_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268439679_32
  S4: state_counter = 4_10
  S4: val1 = 1610612736_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554483_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 17580179_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1140850688_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 16_32
  S8: rd_copy = 1_5
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1077936128_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1342242816_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1074267263_32
  S11: state_counter = 11_10
  S11: val1 = 1342177280_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2115502975_32
  S12: state_counter = 12_10
  S12: val1 = 1073741840_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073743743_32
  S13: state_counter = 13_10
  S13: val1 = 1207959552_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2164260991_32
  S14: state_counter = 14_10
  S14: val1 = 1074790400_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073742975_32
  S15: state_counter = 15_10
  S15: val1 = 1073741824_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262985855_32
  S16: state_counter = 16_10
  S16: val1 = 0_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1073742336_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 9437311_32
  S18: state_counter = 18_10
  S18: val1 = 268435456_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 4194431_32
  S20: state_counter = 20_10
  S20: val1 = 1073741840_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 16511_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1073746047_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 131072_32][1_5 := 1073741840_32][24_5 := 1073741840_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for XORI.vcd
[runlim] sample:		132.8 time, 1710.1 real, 2047.7 MB
  Test for XORI using testing-workflow/bug-injection-patches/alu-bug-injected_2_XORI.patch succeeded, CoSA found a counterexample as expected.

Operator name: SLLI
  Bug injection patch file for instruction SLLI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SLLI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..65dc0d2 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -17,7 +17,7 @@ module alu(
    always @(*) begin
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
-        `ALU_OP_SLL : out = in1 << shamt;
+        `ALU_OP_SLL : out = in1 + shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		8.3 time, 1720.1 real, 202.3 MB
[runlim] sample:		18.3 time, 1730.1 real, 275.6 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLLI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		9.0 time, 1740.1 real, 353.8 MB
___[runlim] sample:		19.0 time, 1750.1 real, 622.0 MB
__[runlim] sample:		29.0 time, 1760.1 real, 803.4 MB
___[runlim] sample:		39.0 time, 1770.1 real, 1027.6 MB
__[runlim] sample:		48.9 time, 1780.1 real, 1287.5 MB
__[runlim] sample:		58.9 time, 1790.1 real, 1536.7 MB
__[runlim] sample:		68.9 time, 1800.1 real, 1625.5 MB
_[runlim] sample:		78.9 time, 1810.1 real, 1811.1 MB
__[runlim] sample:		88.9 time, 1820.1 real, 2119.5 MB
_[runlim] sample:		98.9 time, 1830.1 real, 2178.5 MB
_[runlim] sample:		108.9 time, 1840.1 real, 2342.8 MB
_..[runlim] sample:		118.9 time, 1850.1 real, 2550.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLLI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 135270527_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 32_32][13_5 := 16_32][16_5 := 1073741824_32][21_5 := 512_32][27_5 := 1073741824_32][4_5 := 268435452_32][9_5 := 256_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 134222463_32
  S1: state_counter = 1_10
  S1: val1 = 2181038080_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 1073746559_32
  S2: state_counter = 2_10
  S2: val1 = 8388608_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 67113599_32
  S3: state_counter = 3_10
  S3: val1 = 536870912_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147488383_32
  S4: state_counter = 4_10
  S4: val1 = 1073741824_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 268439679_32
  S5: state_counter = 5_10
  S5: val1 = 1610612736_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25302163_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 9_5
  S8: shimm_copy = 24_32
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 268435448_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 14254207_32
  S11: state_counter = 11_10
  S11: val1 = 268435448_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 4241852543_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 268435456_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 1474687_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 8388735_32
  S15: state_counter = 15_10
  S15: val1 = 2147483648_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4283727999_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 16777343_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 20250751_32
  S18: state_counter = 18_10
  S18: val1 = 1073741824_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 2147483640_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 33554559_32
  S20: state_counter = 20_10
  S20: val1 = 268435452_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 4223_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 134221951_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 32_32][13_5 := 16_32][16_5 := 1073741824_32][21_5 := 512_32][27_5 := 1073741824_32][4_5 := 268435452_32][9_5 := 268435476_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLLI.vcd
[runlim] sample:		128.8 time, 1860.1 real, 2602.4 MB
  Test for SLLI using testing-workflow/bug-injection-patches/alu-bug-injected_0_SLLI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLLI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SLLI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..c887d05 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -17,7 +17,7 @@ module alu(
    always @(*) begin
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
-        `ALU_OP_SLL : out = in1 << shamt;
+        `ALU_OP_SLL : out = in1 ^ shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		4.5 time, 1870.1 real, 192.4 MB
[runlim] sample:		14.5 time, 1880.1 real, 202.5 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLLI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		5.4 time, 1890.1 real, 291.9 MB
__[runlim] sample:		15.3 time, 1900.1 real, 535.3 MB
___[runlim] sample:		25.4 time, 1910.1 real, 807.0 MB
__[runlim] sample:		35.3 time, 1920.1 real, 1004.8 MB
__[runlim] sample:		45.3 time, 1930.1 real, 1140.0 MB
__[runlim] sample:		55.3 time, 1940.1 real, 1428.8 MB
__[runlim] sample:		65.3 time, 1950.1 real, 1547.3 MB
__[runlim] sample:		75.3 time, 1960.1 real, 1869.2 MB
__[runlim] sample:		85.3 time, 1970.1 real, 2086.0 MB
_[runlim] sample:		95.3 time, 1980.1 real, 2128.8 MB
_[runlim] sample:		105.3 time, 1990.1 real, 2281.2 MB
_..[runlim] sample:		115.3 time, 2000.1 real, 2434.7 MB
[runlim] sample:		125.3 time, 2010.1 real, 2560.8 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLLI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2151682175_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 14_32][13_5 := 1_32][14_5 := 2147483648_32][18_5 := 2048_32][1_5 := 536870912_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 151003136_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 67113087_32
  S2: state_counter = 2_10
  S2: val1 = 16777216_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 3489660928_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1073742975_32
  S4: state_counter = 4_10
  S4: val1 = 1073741824_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 127_32
  S5: state_counter = 5_10
  S5: val1 = 0_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 3221226515_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 15013907_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 16_5
  S8: shimm_copy = 14_32
  S8: state_counter = 8_10
  S8: val1 = 1207959552_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 524288_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073807360_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 2261119_32
  S11: state_counter = 11_10
  S11: val1 = 33554432_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 428927_32
  S12: state_counter = 12_10
  S12: val1 = 8_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 8388735_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 557183_32
  S14: state_counter = 14_10
  S14: val1 = 14_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 4194431_32
  S15: state_counter = 15_10
  S15: val1 = 2147483648_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1092616319_32
  S16: state_counter = 16_10
  S16: val1 = 0_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 2147483648_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 269750399_32
  S18: state_counter = 18_10
  S18: val1 = 134217728_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 2147487871_32
  S19: state_counter = 19_10
  S19: val1 = 2097152_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 536875135_32
  S20: state_counter = 20_10
  S20: val1 = 14_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 127_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 134226047_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLLI.vcd
  Test for SLLI using testing-workflow/bug-injection-patches/alu-bug-injected_1_SLLI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLLI:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SLLI.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..84297bb 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -193,7 +193,7 @@ module decoder(
    always @(*) begin
       case (funct3)
         `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
-        `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
+        `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		2.5 time, 2020.1 real, 191.0 MB
[runlim] sample:		12.5 time, 2030.1 real, 202.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLLI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		3.3 time, 2040.1 real, 220.8 MB
_[runlim] sample:		13.3 time, 2050.1 real, 525.3 MB
___[runlim] sample:		23.3 time, 2060.1 real, 687.3 MB
__[runlim] sample:		33.3 time, 2070.1 real, 953.0 MB
___[runlim] sample:		43.3 time, 2080.1 real, 1103.2 MB
__[runlim] sample:		53.3 time, 2090.1 real, 1366.8 MB
__[runlim] sample:		63.3 time, 2100.1 real, 1527.9 MB
_[runlim] sample:		73.3 time, 2110.1 real, 1786.1 MB
__[runlim] sample:		83.3 time, 2120.1 real, 1984.3 MB
_[runlim] sample:		93.3 time, 2130.1 real, 2158.2 MB
_[runlim] sample:		103.3 time, 2140.1 real, 2208.3 MB
__.[runlim] sample:		113.3 time, 2150.1 real, 2365.9 MB
.[runlim] sample:		123.2 time, 2160.1 real, 2558.2 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLLI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2164265087_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[17_5 := 8388608_32][1_5 := 1073750016_32][5_5 := 1073750033_32][9_5 := 8192_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 2147483648_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2148536447_32
  S2: state_counter = 2_10
  S2: val1 = 67108864_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 68161663_32
  S3: state_counter = 3_10
  S3: val1 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1073874047_32
  S4: state_counter = 4_10
  S4: val1 = 1207959552_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 278579_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 17993875_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 1_5
  S8: shimm_copy = 17_32
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1610612736_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073807360_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1074267263_32
  S11: state_counter = 11_10
  S11: val1 = 1073750024_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 1573759_32
  S12: state_counter = 12_10
  S12: val1 = 0_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073742975_32
  S13: state_counter = 13_10
  S13: val1 = 1073750034_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 17825919_32
  S14: state_counter = 14_10
  S14: val1 = 0_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073742975_32
  S15: state_counter = 15_10
  S15: val1 = 1073750032_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262985855_32
  S16: state_counter = 16_10
  S16: val1 = 1073774592_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1073750032_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 9437311_32
  S18: state_counter = 18_10
  S18: val1 = 8_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 17_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073750033_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 135295_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1073746047_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLLI.vcd
[runlim] sample:		133.2 time, 2170.1 real, 2485.2 MB
  Test for SLLI using testing-workflow/bug-injection-patches/alu-bug-injected_2_SLLI.patch succeeded, CoSA found a counterexample as expected.

Operator name: SRLI
  Bug injection patch file for instruction SRLI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SRLI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..e8e3c76 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -21,7 +21,7 @@ module alu(
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
-        `ALU_OP_SRL : out = in1 >> shamt;
+        `ALU_OP_SRL : out = in1 << shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		7.0 time, 2180.1 real, 202.4 MB
[runlim] sample:		17.0 time, 2190.1 real, 202.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRLI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		7.8 time, 2200.1 real, 357.6 MB
__[runlim] sample:		17.8 time, 2210.1 real, 589.8 MB
___[runlim] sample:		27.8 time, 2220.1 real, 795.6 MB
___[runlim] sample:		37.8 time, 2230.1 real, 1046.0 MB
__[runlim] sample:		47.8 time, 2240.1 real, 1272.5 MB
__[runlim] sample:		57.8 time, 2250.1 real, 1466.9 MB
__[runlim] sample:		67.8 time, 2260.1 real, 1690.7 MB
_[runlim] sample:		77.8 time, 2270.1 real, 1903.7 MB
__[runlim] sample:		87.8 time, 2280.1 real, 2032.2 MB
_[runlim] sample:		97.8 time, 2290.1 real, 2168.0 MB
_[runlim] sample:		107.7 time, 2300.1 real, 2350.4 MB
_..[runlim] sample:		117.7 time, 2310.1 real, 2539.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRLI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 67113087_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[1_5 := 262144_32][26_5 := 262144_32][2_5 := 262144_32][4_5 := 2097152_32][6_5 := 16777216_32][9_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 3355443201_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 3221229695_32
  S2: state_counter = 2_10
  S2: val1 = 2281701377_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 1_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1074005119_32
  S4: state_counter = 4_10
  S4: val1 = 1207959552_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554611_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1200403_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 2_5
  S8: shimm_copy = 1_32
  S8: state_counter = 8_10
  S8: val1 = 268435456_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1074003968_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1077938176_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1090718847_32
  S11: state_counter = 11_10
  S11: val1 = 1077936128_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 19074687_32
  S12: state_counter = 12_10
  S12: val1 = 2097152_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073742975_32
  S13: state_counter = 13_10
  S13: val1 = 3221225472_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2114978687_32
  S14: state_counter = 14_10
  S14: val1 = 1073774592_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073742975_32
  S15: state_counter = 15_10
  S15: val1 = 1073741824_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4261412991_32
  S16: state_counter = 16_10
  S16: val1 = 2097152_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 3221226623_32
  S17: state_counter = 17_10
  S17: val1 = 1610612736_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 262271_32
  S18: state_counter = 18_10
  S18: val1 = 1074790400_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1075838976_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 8388735_32
  S20: state_counter = 20_10
  S20: val1 = 2097152_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 20607_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[1_5 := 262144_32][26_5 := 262144_32][2_5 := 4194304_32][4_5 := 2097152_32][6_5 := 16777216_32][9_5 := 1073741824_32]
[runlim] sample:		127.7 time, 2320.1 real, 2587.8 MB
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRLI.vcd
  Test for SRLI using testing-workflow/bug-injection-patches/alu-bug-injected_0_SRLI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SRLI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SRLI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..0f3e333 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -21,7 +21,7 @@ module alu(
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
-        `ALU_OP_SRL : out = in1 >> shamt;
+        `ALU_OP_SRL : out = in1 | shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		4.5 time, 2330.1 real, 192.0 MB
[runlim] sample:		14.5 time, 2340.1 real, 202.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRLI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		5.3 time, 2350.1 real, 285.8 MB
__[runlim] sample:		15.3 time, 2360.1 real, 545.4 MB
___[runlim] sample:		25.3 time, 2370.1 real, 735.5 MB
__[runlim] sample:		35.3 time, 2380.1 real, 987.5 MB
___[runlim] sample:		45.3 time, 2390.1 real, 1266.2 MB
__[runlim] sample:		55.3 time, 2400.1 real, 1462.1 MB
__[runlim] sample:		65.3 time, 2410.1 real, 1689.3 MB
_[runlim] sample:		75.3 time, 2420.1 real, 1818.9 MB
__[runlim] sample:		85.3 time, 2430.1 real, 2044.2 MB
_[runlim] sample:		95.3 time, 2440.1 real, 2184.3 MB
_[runlim] sample:		105.3 time, 2450.1 real, 2353.5 MB
_..[runlim] sample:		115.3 time, 2460.1 real, 2484.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRLI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 553652351_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[1_5 := 134217729_32][5_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 536875135_32
  S1: state_counter = 1_10
  S1: val1 = 536870912_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 67113087_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536875135_32
  S3: state_counter = 3_10
  S3: val1 = 3221225472_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1074267263_32
  S4: state_counter = 4_10
  S4: val1 = 1342177280_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554483_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1233043_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 1_5
  S8: shimm_copy = 1_32
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1610612736_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1074266112_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1074823295_32
  S11: state_counter = 11_10
  S11: val1 = 1073741824_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2148568703_32
  S12: state_counter = 12_10
  S12: val1 = 0_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073742975_32
  S13: state_counter = 13_10
  S13: val1 = 1074135032_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 1048703_32
  S14: state_counter = 14_10
  S14: val1 = 2048_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1107301503_32
  S15: state_counter = 15_10
  S15: val1 = 3221616636_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262985855_32
  S16: state_counter = 16_10
  S16: val1 = 1073741952_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 127_32
  S18: state_counter = 18_10
  S18: val1 = 67108864_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 20607_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[1_5 := 1073741825_32][5_5 := 1073741824_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRLI.vcd
[runlim] sample:		125.3 time, 2470.1 real, 2564.8 MB
  Test for SRLI using testing-workflow/bug-injection-patches/alu-bug-injected_1_SRLI.patch succeeded, CoSA found a counterexample as expected.

Operator name: SRAI
  Bug injection patch file for instruction SRAI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SRAI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..75c5655 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -25,7 +25,7 @@ module alu(
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
-        `ALU_OP_SRA : out = $signed(in1) >>> shamt;
+        `ALU_OP_SRA : out = $signed(in1) << shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		4.6 time, 2480.1 real, 192.0 MB
[runlim] sample:		14.6 time, 2490.1 real, 202.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRAI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		5.4 time, 2500.1 real, 287.0 MB
__[runlim] sample:		15.4 time, 2510.1 real, 535.0 MB
___[runlim] sample:		25.4 time, 2520.1 real, 805.6 MB
__[runlim] sample:		35.4 time, 2530.1 real, 1002.0 MB
__[runlim] sample:		45.4 time, 2540.1 real, 1146.2 MB
___[runlim] sample:		55.4 time, 2550.1 real, 1453.6 MB
_[runlim] sample:		65.3 time, 2560.1 real, 1607.7 MB
__[runlim] sample:		75.3 time, 2570.1 real, 1866.8 MB
__[runlim] sample:		85.3 time, 2580.1 real, 2091.8 MB
_[runlim] sample:		95.3 time, 2590.1 real, 2235.9 MB
_[runlim] sample:		105.3 time, 2600.1 real, 2304.7 MB
_..[runlim] sample:		115.3 time, 2610.1 real, 2434.7 MB
[runlim] sample:		125.3 time, 2620.1 real, 2574.4 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRAI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 1073746047_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[13_5 := 32_32][15_5 := 4128_32][25_5 := 1073741824_32][5_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 33554432_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 1073746047_32
  S2: state_counter = 2_10
  S2: val1 = 1082130432_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 0_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134218879_32
  S4: state_counter = 4_10
  S4: val1 = 1073741824_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 127_32
  S5: state_counter = 5_10
  S5: val1 = 0_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1090520115_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1089655187_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 3_5
  S8: shimm_copy = 15_32
  S8: state_counter = 8_10
  S8: val1 = 3221225472_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073741824_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 134217760_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 16941183_32
  S11: state_counter = 11_10
  S11: val1 = 1073741856_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2080802943_32
  S12: state_counter = 12_10
  S12: val1 = 1073741828_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 4194431_32
  S13: state_counter = 13_10
  S13: val1 = 2097152_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 262271_32
  S14: state_counter = 14_10
  S14: val1 = 0_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 1073774592_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 26083455_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1048703_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1073742975_32
  S18: state_counter = 18_10
  S18: val1 = 1073741824_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 3221225599_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073762431_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1077940351_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRAI.vcd
  Test for SRAI using testing-workflow/bug-injection-patches/alu-bug-injected_1_SRAI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SRAI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SRAI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..75c5655 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -25,7 +25,7 @@ module alu(
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
-        `ALU_OP_SRA : out = $signed(in1) >>> shamt;
+        `ALU_OP_SRA : out = $signed(in1) << shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		4.0 time, 2630.1 real, 191.9 MB
[runlim] sample:		14.0 time, 2640.1 real, 201.9 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRAI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		4.9 time, 2650.1 real, 270.5 MB
__[runlim] sample:		14.8 time, 2660.1 real, 519.7 MB
__[runlim] sample:		24.8 time, 2670.1 real, 747.1 MB
___[runlim] sample:		34.8 time, 2680.1 real, 978.3 MB
__[runlim] sample:		44.8 time, 2690.1 real, 1091.6 MB
__[runlim] sample:		54.8 time, 2700.1 real, 1446.2 MB
__[runlim] sample:		64.8 time, 2710.1 real, 1626.6 MB
__[runlim] sample:		74.8 time, 2720.1 real, 1828.3 MB
_[runlim] sample:		84.8 time, 2730.1 real, 1983.3 MB
__[runlim] sample:		94.8 time, 2740.1 real, 2186.3 MB
_[runlim] sample:		104.8 time, 2750.1 real, 2229.6 MB
_.[runlim] sample:		114.7 time, 2760.1 real, 2416.8 MB
.[runlim] sample:		124.7 time, 2770.1 real, 2549.5 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRAI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 1073762431_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[1_5 := 4194304_32][31_5 := 134217728_32][5_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 301989888_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 67113087_32
  S2: state_counter = 2_10
  S2: val1 = 1140850688_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536875135_32
  S3: state_counter = 3_10
  S3: val1 = 0_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147487871_32
  S4: state_counter = 4_10
  S4: val1 = 268435456_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554483_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1074974867_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 1_5
  S8: shimm_copy = 1_32
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1074790400_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1090519040_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1102087295_32
  S11: state_counter = 11_10
  S11: val1 = 1073741824_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 4293952383_32
  S12: state_counter = 12_10
  S12: val1 = 0_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1342178943_32
  S13: state_counter = 13_10
  S13: val1 = 1073741824_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 16777343_32
  S14: state_counter = 14_10
  S14: val1 = 0_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 3254977663_32
  S15: state_counter = 15_10
  S15: val1 = 1073741952_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 16842879_32
  S16: state_counter = 16_10
  S16: val1 = 1073741825_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073939583_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 295039_32
  S18: state_counter = 18_10
  S18: val1 = 67108864_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073762431_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[1_5 := 2147483648_32][31_5 := 134217728_32][5_5 := 1073741824_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRAI.vcd
  Test for SRAI using testing-workflow/bug-injection-patches/alu-bug-injected_0_SRAI.patch succeeded, CoSA found a counterexample as expected.

Operator name: SLTIU
  Bug injection patch file for instruction SLTIU:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SLTIU.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..3d6e5bd 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -28,7 +28,7 @@ module alu(
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
-        `ALU_OP_SLTU : out = {31'b0, in1 < in2};
+        `ALU_OP_SLTU : out = {31'b0, in1 > in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
         default : out = 0;
       endcase // case op
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		1.1 time, 2780.1 real, 116.3 MB
[runlim] sample:		11.1 time, 2790.1 real, 201.9 MB
[runlim] sample:		2.1 time, 2800.1 real, 85.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTIU" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		12.0 time, 2810.1 real, 474.3 MB
___[runlim] sample:		22.0 time, 2820.1 real, 680.9 MB
__[runlim] sample:		32.0 time, 2830.1 real, 832.6 MB
___[runlim] sample:		42.0 time, 2840.1 real, 1093.2 MB
__[runlim] sample:		52.0 time, 2850.1 real, 1392.9 MB
__[runlim] sample:		62.0 time, 2860.1 real, 1571.7 MB
_[runlim] sample:		72.0 time, 2870.1 real, 1819.8 MB
__[runlim] sample:		82.0 time, 2880.1 real, 1916.4 MB
_[runlim] sample:		92.0 time, 2890.1 real, 2090.3 MB
__[runlim] sample:		102.0 time, 2900.1 real, 2257.6 MB
_.[runlim] sample:		112.0 time, 2910.1 real, 2404.9 MB
.[runlim] sample:		122.0 time, 2920.1 real, 2546.2 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTIU **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 134230143_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 1046528_32][13_5 := 1074767872_32][14_5 := 4096_32][15_5 := 16_32][1_5 := 4194304_32][4_5 := 1038337_32][5_5 := 1047055_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 536875135_32
  S1: state_counter = 1_10
  S1: val1 = 1073750016_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 1073746047_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 2415919104_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 1048576_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 671088767_32
  S5: state_counter = 5_10
  S5: val1 = 2147483648_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 2699211283_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 4294965774_32
  S8: rd_copy = 4_5
  S8: state_counter = 8_10
  S8: val1 = 1107296256_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 134217728_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1207959552_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 17268863_32
  S11: state_counter = 11_10
  S11: val1 = 1047040_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2114423935_32
  S12: state_counter = 12_10
  S12: val1 = 1047042_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1082130559_32
  S13: state_counter = 13_10
  S13: val1 = 1090519040_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2160066687_32
  S14: state_counter = 14_10
  S14: val1 = 1207959552_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 1075838976_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4265738367_32
  S16: state_counter = 16_10
  S16: val1 = 1073745920_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 16777343_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 426111_32
  S18: state_counter = 18_10
  S18: val1 = 1040512_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 268439553_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1047055_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073754239_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 1046528_32][13_5 := 1074767872_32][14_5 := 4096_32][15_5 := 16_32][1_5 := 4194304_32][5_5 := 1047055_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTIU.vcd
[runlim] sample:		132.0 time, 2930.1 real, 4.1 MB
  Test for SLTIU using testing-workflow/bug-injection-patches/alu-bug-injected_0_SLTIU.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLTIU:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SLTIU.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..0b6c2e8 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -195,7 +195,7 @@ module decoder(
         `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
-        `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
+        `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
         `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		9.9 time, 2940.1 real, 202.1 MB
[runlim] sample:		0.6 time, 2950.1 real, 61.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTIU" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		10.6 time, 2960.1 real, 466.2 MB
__[runlim] sample:		20.6 time, 2970.1 real, 682.6 MB
___[runlim] sample:		30.6 time, 2980.1 real, 844.9 MB
__[runlim] sample:		40.6 time, 2990.1 real, 1079.2 MB
___[runlim] sample:		50.6 time, 3000.1 real, 1342.1 MB
_[runlim] sample:		60.6 time, 3010.1 real, 1543.7 MB
__[runlim] sample:		70.6 time, 3020.1 real, 1756.9 MB
_[runlim] sample:		80.6 time, 3030.1 real, 1871.5 MB
__[runlim] sample:		90.6 time, 3040.1 real, 2066.6 MB
_[runlim] sample:		100.6 time, 3050.1 real, 2168.5 MB
_[runlim] sample:		110.6 time, 3060.1 real, 2274.8 MB
_..[runlim] sample:		120.6 time, 3070.1 real, 2509.3 MB
[runlim] sample:		130.6 time, 3080.1 real, 2573.7 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTIU **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 2181042303_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2147483648_32][11_5 := 1073870863_32][15_5 := 2147483648_32][1_5 := 2147483648_32][8_5 := 256_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 268439679_32
  S1: state_counter = 1_10
  S1: val1 = 268435456_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 16777216_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 134221951_32
  S3: state_counter = 3_10
  S3: val1 = 268435456_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134746239_32
  S4: state_counter = 4_10
  S4: val1 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1342177280_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1082131507_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 2163585171_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1610612736_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 4294965263_32
  S8: rd_copy = 1_5
  S8: state_counter = 8_10
  S8: val1 = 131072_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073823744_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1074266112_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 2228351_32
  S11: state_counter = 11_10
  S11: val1 = 1074790400_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2124808319_32
  S12: state_counter = 12_10
  S12: val1 = 1073870860_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 9764991_32
  S14: state_counter = 14_10
  S14: val1 = 1073870856_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 268435583_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1073774719_32
  S16: state_counter = 16_10
  S16: val1 = 1073870862_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 69210239_32
  S18: state_counter = 18_10
  S18: val1 = 8388608_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 2147487871_32
  S19: state_counter = 19_10
  S19: val1 = 268435456_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 268439679_32
  S20: state_counter = 20_10
  S20: val1 = 1073870863_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 12415_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1073746047_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2147483648_32][11_5 := 1073870863_32][15_5 := 2147483648_32][1_5 := 3221094400_32][8_5 := 256_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTIU.vcd
  Test for SLTIU using testing-workflow/bug-injection-patches/alu-bug-injected_2_SLTIU.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLTIU:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SLTIU.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..06606f2 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -28,7 +28,7 @@ module alu(
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
-        `ALU_OP_SLTU : out = {31'b0, in1 < in2};
+        `ALU_OP_SLTU : out = {31'b0, in1 == in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
         default : out = 0;
       endcase // case op
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		4.0 time, 3090.1 real, 192.4 MB
[runlim] sample:		14.0 time, 3100.1 real, 202.5 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTIU" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		4.9 time, 3110.1 real, 271.4 MB
__[runlim] sample:		14.9 time, 3120.1 real, 527.2 MB
__[runlim] sample:		24.9 time, 3130.1 real, 745.0 MB
___[runlim] sample:		34.9 time, 3140.1 real, 994.8 MB
__[runlim] sample:		44.9 time, 3150.1 real, 1143.6 MB
__[runlim] sample:		54.9 time, 3160.1 real, 1445.0 MB
__[runlim] sample:		64.9 time, 3170.1 real, 1604.3 MB
__[runlim] sample:		74.9 time, 3180.1 real, 1840.3 MB
__[runlim] sample:		84.9 time, 3190.1 real, 2064.8 MB
_[runlim] sample:		94.9 time, 3200.1 real, 2149.7 MB
_[runlim] sample:		104.9 time, 3210.1 real, 2318.3 MB
_.[runlim] sample:		114.9 time, 3220.1 real, 2326.8 MB
.[runlim] sample:		124.8 time, 3230.1 real, 2508.1 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTIU **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 134230143_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 16_32][14_5 := 1073741840_32][15_5 := 16384_32][1_5 := 131072_32][29_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 536875135_32
  S1: state_counter = 1_10
  S1: val1 = 1073750016_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 268439679_32
  S2: state_counter = 2_10
  S2: val1 = 536870912_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2148532607_32
  S4: state_counter = 4_10
  S4: val1 = 4194304_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1090520191_32
  S5: state_counter = 5_10
  S5: val1 = 1082130432_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 552746515_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 527_32
  S8: rd_copy = 28_5
  S8: state_counter = 8_10
  S8: val1 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 0_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 29393023_32
  S11: state_counter = 11_10
  S11: val1 = 2_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2126546815_32
  S12: state_counter = 12_10
  S12: val1 = 0_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 17301631_32
  S13: state_counter = 13_10
  S13: val1 = 1082130432_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 458879_32
  S14: state_counter = 14_10
  S14: val1 = 1207959552_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 536871039_32
  S15: state_counter = 15_10
  S15: val1 = 8_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 950399_32
  S16: state_counter = 16_10
  S16: val1 = 1140850688_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 2097279_32
  S17: state_counter = 17_10
  S17: val1 = 512_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1074431103_32
  S18: state_counter = 18_10
  S18: val1 = 1073741824_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 127_32
  S19: state_counter = 19_10
  S19: val1 = 4194304_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 268439679_32
  S20: state_counter = 20_10
  S20: val1 = 0_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 12415_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1073746047_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTIU.vcd
  Test for SLTIU using testing-workflow/bug-injection-patches/alu-bug-injected_1_SLTIU.patch succeeded, CoSA found a counterexample as expected.

Operator name: SLTI
  Bug injection patch file for instruction SLTI:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SLTI.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..388d8ff 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -194,7 +194,7 @@ module decoder(
       case (funct3)
         `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
-        `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
+        `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		0.4 time, 3240.1 real, 67.8 MB
[runlim] sample:		10.4 time, 3250.1 real, 202.5 MB
[runlim] sample:		1.1 time, 3260.1 real, 74.6 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		11.1 time, 3270.1 real, 476.6 MB
___[runlim] sample:		21.1 time, 3280.1 real, 678.9 MB
__[runlim] sample:		31.1 time, 3290.1 real, 834.2 MB
___[runlim] sample:		41.1 time, 3300.1 real, 1093.1 MB
__[runlim] sample:		51.1 time, 3310.1 real, 1351.4 MB
__[runlim] sample:		61.1 time, 3320.1 real, 1582.2 MB
_[runlim] sample:		71.1 time, 3330.1 real, 1807.9 MB
__[runlim] sample:		81.1 time, 3340.1 real, 1908.8 MB
_[runlim] sample:		91.1 time, 3350.1 real, 2074.2 MB
_[runlim] sample:		101.1 time, 3360.1 real, 2211.9 MB
_[runlim] sample:		111.1 time, 3370.1 real, 2279.7 MB
_..[runlim] sample:		121.1 time, 3380.1 real, 2396.0 MB
[runlim] sample:		131.1 time, 3390.1 real, 2509.3 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 536879231_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1073741824_32][15_5 := 2147483648_32][16_5 := 33554432_32][17_5 := 32768_32][1_5 := 1073741824_32][2_5 := 3221225472_32][8_5 := 33554432_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 134221951_32
  S1: state_counter = 1_10
  S1: val1 = 536870913_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 1073741824_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 134221951_32
  S3: state_counter = 3_10
  S3: val1 = 1074266112_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147487871_32
  S4: state_counter = 4_10
  S4: val1 = 67108864_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1207960703_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742899_32
  S6: state_counter = 6_10
  S6: val1 = 536870912_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 2331058451_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 4294965423_32
  S8: rd_copy = 2_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3223242768_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1207959552_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 25298047_32
  S11: state_counter = 11_10
  S11: val1 = 1107296256_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 8521087_32
  S12: state_counter = 12_10
  S12: val1 = 1073741826_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 131455_32
  S14: state_counter = 14_10
  S14: val1 = 1610612736_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 17334399_32
  S16: state_counter = 16_10
  S16: val1 = 3221225504_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 2097279_32
  S17: state_counter = 17_10
  S17: val1 = 1610612736_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1074857087_32
  S18: state_counter = 18_10
  S18: val1 = 3221225600_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 127_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 2147487871_32
  S20: state_counter = 20_10
  S20: val1 = 3221225472_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 8319_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1073741824_32][15_5 := 2147483648_32][16_5 := 33554432_32][17_5 := 32768_32][1_5 := 1073741824_32][2_5 := 1073739951_32][8_5 := 33554432_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTI.vcd
  Test for SLTI using testing-workflow/bug-injection-patches/alu-bug-injected_2_SLTI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLTI:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SLTI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..74aeaef 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -26,7 +26,7 @@ module alu(
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
-        `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
+        `ALU_OP_SLT : out = {31'b0, $signed(in1) > $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		0.5 time, 3400.1 real, 71.5 MB
[runlim] sample:		10.5 time, 3410.1 real, 202.1 MB
[runlim] sample:		1.3 time, 3420.1 real, 81.8 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		11.3 time, 3430.1 real, 475.8 MB
___[runlim] sample:		21.3 time, 3440.1 real, 671.6 MB
__[runlim] sample:		31.3 time, 3450.1 real, 833.2 MB
__[runlim] sample:		41.3 time, 3460.1 real, 1095.7 MB
___[runlim] sample:		51.3 time, 3470.1 real, 1350.4 MB
__[runlim] sample:		61.3 time, 3480.1 real, 1572.7 MB
_[runlim] sample:		71.3 time, 3490.1 real, 1809.0 MB
__[runlim] sample:		81.3 time, 3500.1 real, 1940.4 MB
_[runlim] sample:		91.3 time, 3510.1 real, 2074.5 MB
_[runlim] sample:		101.3 time, 3520.1 real, 2146.9 MB
_[runlim] sample:		111.3 time, 3530.1 real, 2336.7 MB
_..[runlim] sample:		121.3 time, 3540.1 real, 2481.9 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 134226047_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 65536_32][18_5 := 1073741824_32][1_5 := 67108864_32][4_5 := 2097152_32][5_5 := 2147745792_32][8_5 := 54_32][9_5 := 8_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2155876479_32
  S2: state_counter = 2_10
  S2: val1 = 1082130432_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 16777216_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 67113087_32
  S4: state_counter = 4_10
  S4: val1 = 1140850688_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 536875135_32
  S5: state_counter = 5_10
  S5: val1 = 2148532224_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1090520115_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 709011731_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 676_32
  S8: rd_copy = 18_5
  S8: state_counter = 8_10
  S8: val1 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 2147745794_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1610612736_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 14942335_32
  S11: state_counter = 11_10
  S11: val1 = 2147745824_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 1352925311_32
  S12: state_counter = 12_10
  S12: val1 = 262144_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 150995071_32
  S13: state_counter = 13_10
  S13: val1 = 67108864_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2150137983_32
  S14: state_counter = 14_10
  S14: val1 = 75497472_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1048703_32
  S15: state_counter = 15_10
  S15: val1 = 2147483664_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4284776575_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073741951_32
  S17: state_counter = 17_10
  S17: val1 = 8388608_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 127_32
  S18: state_counter = 18_10
  S18: val1 = 1610612736_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1074003968_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 2097279_32
  S20: state_counter = 20_10
  S20: val1 = 2147745792_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 8319_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 65536_32][1_5 := 67108864_32][4_5 := 2097152_32][5_5 := 2147745792_32][8_5 := 54_32][9_5 := 8_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTI.vcd
[runlim] sample:		131.2 time, 3550.1 real, 2557.2 MB
  Test for SLTI using testing-workflow/bug-injection-patches/alu-bug-injected_0_SLTI.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLTI:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SLTI.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..5991408 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -26,7 +26,7 @@ module alu(
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
-        `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
+        `ALU_OP_SLT : out = {31'b0, $signed(in1) == $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		4.9 time, 3560.1 real, 191.7 MB
[runlim] sample:		14.9 time, 3570.1 real, 202.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTI" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		5.7 time, 3580.1 real, 330.9 MB
__[runlim] sample:		15.7 time, 3590.1 real, 533.4 MB
___[runlim] sample:		25.7 time, 3600.1 real, 751.1 MB
__[runlim] sample:		35.7 time, 3610.1 real, 1006.0 MB
___[runlim] sample:		45.7 time, 3620.1 real, 1196.8 MB
__[runlim] sample:		55.7 time, 3630.1 real, 1454.8 MB
__[runlim] sample:		65.7 time, 3640.1 real, 1629.1 MB
_[runlim] sample:		75.7 time, 3650.1 real, 1870.9 MB
_[runlim] sample:		85.7 time, 3660.1 real, 2024.7 MB
__[runlim] sample:		95.7 time, 3670.1 real, 2120.9 MB
_[runlim] sample:		105.7 time, 3680.1 real, 2273.7 MB
_.[runlim] sample:		115.7 time, 3690.1 real, 2419.5 MB
.[runlim] sample:		125.7 time, 3700.1 real, 2583.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTI **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: imm_copy = 0_32
  I: instruction = 536879231_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[1_5 := 2147483648_32][5_5 := 268435456_32][7_5 := 524288_32][8_5 := 67108864_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 67113087_32
  S1: state_counter = 1_10
  S1: val1 = 1879048224_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147487871_32
  S2: state_counter = 2_10
  S2: val1 = 3489660928_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536875135_32
  S3: state_counter = 3_10
  S3: val1 = 1090519040_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268439679_32
  S4: state_counter = 4_10
  S4: val1 = 16777216_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 268701823_32
  S5: state_counter = 5_10
  S5: val1 = 536870912_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1090520115_32
  S6: state_counter = 6_10
  S6: val1 = 1077936128_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 7743891_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 67108864_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: imm_copy = 7_32
  S8: rd_copy = 19_5
  S8: state_counter = 8_10
  S8: val1 = 3223322624_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1140850816_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1140850688_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 25297023_32
  S11: state_counter = 11_10
  S11: val1 = 1074266112_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2122483839_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 536871039_32
  S13: state_counter = 13_10
  S13: val1 = 4096_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2167570559_32
  S14: state_counter = 14_10
  S14: val1 = 0_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 127_32
  S15: state_counter = 15_10
  S15: val1 = 33554432_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4280909951_32
  S16: state_counter = 16_10
  S16: val1 = 0_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 16777343_32
  S17: state_counter = 17_10
  S17: val1 = 536870912_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 32895_32
  S18: state_counter = 18_10
  S18: val1 = 16_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1073741824_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 16777343_32
  S20: state_counter = 20_10
  S20: val1 = 0_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 8319_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTI.vcd
  Test for SLTI using testing-workflow/bug-injection-patches/alu-bug-injected_1_SLTI.patch succeeded, CoSA found a counterexample as expected.

Operator name: ADD
  Bug injection patch file for instruction ADD:  testing-workflow/bug-injection-patches/alu-bug-injected_2_ADD.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..913efef 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -192,7 +192,7 @@ module decoder(
 
    always @(*) begin
       case (funct3)
-        `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
+        `RV32_FUNCT3_ADD_SUB : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		2.3 time, 3710.1 real, 187.3 MB
[runlim] sample:		12.3 time, 3720.1 real, 202.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ADD" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		3.2 time, 3730.1 real, 194.2 MB
_[runlim] sample:		13.1 time, 3740.1 real, 484.9 MB
___[runlim] sample:		23.1 time, 3750.1 real, 692.1 MB
___[runlim] sample:		33.1 time, 3760.1 real, 974.5 MB
__[runlim] sample:		43.1 time, 3770.1 real, 1116.0 MB
__[runlim] sample:		53.1 time, 3780.1 real, 1425.0 MB
__[runlim] sample:		63.1 time, 3790.1 real, 1614.8 MB
__[runlim] sample:		73.1 time, 3800.1 real, 1865.3 MB
_[runlim] sample:		83.1 time, 3810.1 real, 2065.9 MB
__[runlim] sample:		93.1 time, 3820.1 real, 2124.2 MB
_[runlim] sample:		103.1 time, 3830.1 real, 2215.4 MB
_[runlim] sample:		113.1 time, 3840.1 real, 2317.4 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for ADD **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2149580927_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 32_32][14_5 := 1_32][3_5 := 1124073472_32][4_5 := 117440513_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147496063_32
  S1: state_counter = 1_10
  S1: val2 = 1082130432_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 1048576_32
  S2: val2 = 272629760_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 1073746047_32
  S3: state_counter = 3_10
  S3: val1 = 536870912_32
  S3: val2 = 2415919104_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268439679_32
  S4: state_counter = 4_10
  S4: val1 = 2147483648_32
  S4: val2 = 268435456_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 67113087_32
  S5: state_counter = 5_10
  S5: val1 = 2048_32
  S5: val2 = 67108864_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 4293043_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 3_5
  S8: state_counter = 8_10
  S8: val1 = 1074266112_32
  S8: val2 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3221225474_32
  S9: val2 = 65536_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 3221225472_32
  S10: val2 = 134217728_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 11534463_32
  S11: state_counter = 11_10
  S11: val1 = 0_32
  S11: val2 = 1073742848_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2124873855_32
  S12: state_counter = 12_10
  S12: val1 = 1342177280_32
  S12: val2 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 18874495_32
  S13: state_counter = 13_10
  S13: val1 = 4194304_32
  S13: val2 = 117440528_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 360575_32
  S14: state_counter = 14_10
  S14: val1 = 0_32
  S14: val2 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 8388735_32
  S15: state_counter = 15_10
  S15: val1 = 1610612736_32
  S15: val2 = 117440512_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1077118079_32
  S16: state_counter = 16_10
  S16: val1 = 1124073480_32
  S16: val2 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 2147487871_32
  S18: state_counter = 18_10
  S18: val1 = 536870912_32
  S18: val2 = 2147483648_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 268439679_32
  S19: state_counter = 19_10
  S19: val1 = 0_32
  S19: val2 = 134217728_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 134221951_32
  S20: state_counter = 20_10
  S20: val1 = 1124073472_32
  S20: val2 = 117440513_32
Counterexamples: [1], [2]
Traces (max) length: 21

*** TRACES ***

[1]:	trace[1]-Single Instruction for ADD.vcd
  Test for ADD using testing-workflow/bug-injection-patches/alu-bug-injected_2_ADD.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction ADD:  testing-workflow/bug-injection-patches/alu-bug-injected_1_ADD.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..9131742 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -16,7 +16,7 @@ module alu(
 
    always @(*) begin
       case (op)
-        `ALU_OP_ADD : out = in1 + in2;
+        `ALU_OP_ADD : out = in1 ^ in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		3.9 time, 3850.1 real, 192.0 MB
[runlim] sample:		13.9 time, 3860.1 real, 202.0 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ADD" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		4.3 time, 3870.1 real, 263.5 MB
__[runlim] sample:		14.3 time, 3880.1 real, 530.5 MB
__[runlim] sample:		24.3 time, 3890.1 real, 747.8 MB
___[runlim] sample:		34.3 time, 3900.1 real, 971.5 MB
__[runlim] sample:		44.3 time, 3910.1 real, 1110.8 MB
__[runlim] sample:		54.3 time, 3920.1 real, 1378.3 MB
__[runlim] sample:		64.3 time, 3930.1 real, 1565.6 MB
_[runlim] sample:		74.3 time, 3940.1 real, 1780.3 MB
__[runlim] sample:		84.3 time, 3950.1 real, 1905.6 MB
_[runlim] sample:		94.2 time, 3960.1 real, 2055.4 MB
_[runlim] sample:		104.2 time, 3970.1 real, 2106.2 MB
_[runlim] sample:		114.2 time, 3980.1 real, 2270.2 MB
_ FALSE

*** SUMMARY ***

** Problem Single Instruction for ADD **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268451967_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 3221225472_32][16_5 := 2147516416_32][20_5 := 2147483648_32][24_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 536875135_32
  S1: state_counter = 1_10
  S1: val1 = 1090519040_32
  S1: val2 = 2164260865_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 67113087_32
  S2: state_counter = 2_10
  S2: val1 = 1073741824_32
  S2: val2 = 268435456_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 1073746047_32
  S3: state_counter = 3_10
  S3: val1 = 2147483648_32
  S3: val2 = 1073741824_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268439679_32
  S4: state_counter = 4_10
  S4: val1 = 268435456_32
  S4: val2 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 2147483775_32
  S5: state_counter = 5_10
  S5: val1 = 33554432_32
  S5: val2 = 3221225472_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073744915_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25496627_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 24_5
  S8: state_counter = 8_10
  S8: val1 = 1074003968_32
  S8: val2 = 1074266112_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3221225476_32
  S9: val2 = 131072_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 0_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 6947455_32
  S11: state_counter = 11_10
  S11: val1 = 3221225472_32
  S11: val2 = 2147483664_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2129265663_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32
  S12: val2 = 2147483648_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 0_32
  S13: val2 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 786559_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 2164260864_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1082328319_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 2684354560_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 65663_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 2147553407_32
  S18: state_counter = 18_10
  S18: val1 = 1073741824_32
  S18: val2 = 536870912_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 2214662271_32
  S19: state_counter = 19_10
  S19: val1 = 2684354560_32
  S19: val2 = 2147500040_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 67178623_32
  S20: state_counter = 20_10
  S20: val1 = 3221225472_32
  S20: val2 = 2147483648_32
Counterexamples: [1], [2]
Traces (max) length: 21

*** TRACES ***

[1]:	trace[1]-Single Instruction for ADD.vcd
[runlim] sample:		124.2 time, 3990.1 real, 2178.3 MB
  Test for ADD using testing-workflow/bug-injection-patches/alu-bug-injected_1_ADD.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction ADD:  testing-workflow/bug-injection-patches/alu-bug-injected_0_ADD.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..30dfdb1 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -16,7 +16,7 @@ module alu(
 
    always @(*) begin
       case (op)
-        `ALU_OP_ADD : out = in1 + in2;
+        `ALU_OP_ADD : out = in1 - in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		6.9 time, 4000.1 real, 202.0 MB
[runlim] sample:		16.9 time, 4010.1 real, 202.0 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for ADD" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.2 time, 4020.1 real, 349.2 MB
__[runlim] sample:		16.2 time, 4030.1 real, 525.6 MB
__[runlim] sample:		26.2 time, 4040.1 real, 695.9 MB
___[runlim] sample:		36.2 time, 4050.1 real, 979.3 MB
__[runlim] sample:		46.2 time, 4060.1 real, 1128.1 MB
__[runlim] sample:		56.2 time, 4070.1 real, 1375.6 MB
__[runlim] sample:		66.2 time, 4080.1 real, 1553.9 MB
__[runlim] sample:		76.2 time, 4090.1 real, 1860.2 MB
_[runlim] sample:		86.2 time, 4100.1 real, 2027.4 MB
_[runlim] sample:		96.1 time, 4110.1 real, 2066.0 MB
_[runlim] sample:		106.1 time, 4120.1 real, 2153.5 MB
_[runlim] sample:		116.1 time, 4130.1 real, 2280.1 MB
_ FALSE

*** SUMMARY ***

** Problem Single Instruction for ADD **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268435583_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 536870912_32][16_5 := 3193971338_32][17_5 := 2048_32][24_5 := 3160420508_32][8_5 := 32_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 335548543_32
  S1: state_counter = 1_10
  S1: val1 = 2147483712_32
  S1: val2 = 1140850704_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 537133183_32
  S2: state_counter = 2_10
  S2: val1 = 1610612736_32
  S2: val2 = 67108864_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268701823_32
  S3: state_counter = 3_10
  S3: val1 = 536870912_32
  S3: val2 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1074008191_32
  S4: state_counter = 4_10
  S4: val1 = 268435456_32
  S4: val2 = 2415919104_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 134484095_32
  S5: state_counter = 5_10
  S5: val1 = 1140850688_32
  S5: val2 = 131072_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 17563827_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 1_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32
  S8: val2 = 1610776576_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1544486912_32
  S9: val2 = 1347059712_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1543634944_32
  S10: val2 = 1342828170_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 17334399_32
  S11: state_counter = 11_10
  S11: val1 = 1679998976_32
  S11: val2 = 268943360_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2124972927_32
  S12: state_counter = 12_10
  S12: val1 = 1074774016_32
  S12: val2 = 1380827136_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073751167_32
  S13: state_counter = 13_10
  S13: val1 = 491520_32
  S13: val2 = 3192897536_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 262271_32
  S14: state_counter = 14_10
  S14: val1 = 3161309184_32
  S14: val2 = 3564093440_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 2097279_32
  S15: state_counter = 15_10
  S15: val1 = 942653440_32
  S15: val2 = 2490056704_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 529663_32
  S16: state_counter = 16_10
  S16: val1 = 673349632_32
  S16: val2 = 3194699776_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073755263_32
  S17: state_counter = 17_10
  S17: val1 = 136314880_32
  S17: val2 = 1852309504_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 4223_32
  S18: state_counter = 18_10
  S18: val1 = 0_32
  S18: val2 = 0_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073746047_32
  S19: state_counter = 19_10
  S19: val1 = 2147483648_32
  S19: val2 = 8388608_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 2147487871_32
  S20: state_counter = 20_10
  S20: val1 = 3160420508_32
  S20: val2 = 3193971338_32
Counterexamples: [1], [2]
Traces (max) length: 21

*** TRACES ***

[1]:	trace[1]-Single Instruction for ADD.vcd
  Test for ADD using testing-workflow/bug-injection-patches/alu-bug-injected_0_ADD.patch succeeded, CoSA found a counterexample as expected.

Operator name: SUB
  Bug injection patch file for instruction SUB:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SUB.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..71d9d6e 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -24,7 +24,7 @@ module alu(
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
-        `ALU_OP_SUB : out = in1 - in2;
+        `ALU_OP_SUB : out = in1 & in2;
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
[runlim] sample:		0.3 time, 4140.1 real, 37.9 MB
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		10.2 time, 4150.1 real, 202.1 MB
[runlim] sample:		0.7 time, 4160.1 real, 61.3 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SUB" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		10.7 time, 4170.1 real, 522.9 MB
___[runlim] sample:		20.7 time, 4180.1 real, 625.2 MB
___[runlim] sample:		30.7 time, 4190.1 real, 808.7 MB
__[runlim] sample:		40.7 time, 4200.1 real, 1013.2 MB
__[runlim] sample:		50.7 time, 4210.1 real, 1309.3 MB
__[runlim] sample:		60.6 time, 4220.1 real, 1524.6 MB
__[runlim] sample:		70.6 time, 4230.1 real, 1754.1 MB
__[runlim] sample:		80.6 time, 4240.1 real, 1916.2 MB
_[runlim] sample:		90.6 time, 4250.1 real, 2097.2 MB
_[runlim] sample:		100.6 time, 4260.1 real, 2149.7 MB
__[runlim] sample:		110.6 time, 4270.1 real, 2397.3 MB
..[runlim] sample:		120.6 time, 4280.1 real, 2513.8 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SUB **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 1073741951_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 1_32][16_5 := 20_32][19_5 := 4_32][1_5 := 33554432_32][24_5 := 131092_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 268439679_32
  S1: state_counter = 1_10
  S1: val2 = 570425856_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 1073746047_32
  S2: state_counter = 2_10
  S2: val1 = 268435456_32
  S2: val2 = 37748736_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536875135_32
  S3: state_counter = 3_10
  S3: val1 = 2181038080_32
  S3: val2 = 1115684864_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268439679_32
  S4: state_counter = 4_10
  S4: val1 = 536870912_32
  S4: val2 = 16777216_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 536875135_32
  S5: state_counter = 5_10
  S5: val1 = 8388608_32
  S5: val2 = 536870912_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1099434419_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 19_5
  S8: state_counter = 8_10
  S8: val1 = 1610612736_32
  S8: val2 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 17_32
  S9: val2 = 131094_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 20_32
  S10: val2 = 1342177280_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 16777343_32
  S11: state_counter = 11_10
  S11: val1 = 16777216_32
  S11: val2 = 1074266112_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2139459199_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32
  S12: val2 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 2126520447_32
  S13: state_counter = 13_10
  S13: val1 = 268435456_32
  S13: val2 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 20258943_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 147456_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 24703_32
  S15: state_counter = 15_10
  S15: val1 = 20_32
  S15: val2 = 2147483648_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4261568639_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1342177280_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 16806015_32
  S17: state_counter = 17_10
  S17: val1 = 20_32
  S17: val2 = 268435456_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 114815_32
  S18: state_counter = 18_10
  S18: val1 = 268435456_32
  S18: val2 = 0_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073751167_32
  S19: state_counter = 19_10
  S19: val1 = 1073741828_32
  S19: val2 = 1073872896_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 20_32
  S20: val2 = 131092_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 3221225599_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 127_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 1_32][16_5 := 20_32][19_5 := 20_32][1_5 := 33554432_32][24_5 := 131092_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SUB.vcd
[runlim] sample:		130.6 time, 4290.1 real, 2436.9 MB
  Test for SUB using testing-workflow/bug-injection-patches/alu-bug-injected_1_SUB.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SUB:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SUB.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..913efef 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -192,7 +192,7 @@ module decoder(
 
    always @(*) begin
       case (funct3)
-        `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
+        `RV32_FUNCT3_ADD_SUB : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		7.4 time, 4300.1 real, 202.6 MB
[runlim] sample:		17.4 time, 4310.1 real, 202.6 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SUB" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		7.8 time, 4320.1 real, 357.7 MB
__[runlim] sample:		17.8 time, 4330.1 real, 537.1 MB
___[runlim] sample:		27.8 time, 4340.1 real, 749.2 MB
__[runlim] sample:		37.7 time, 4350.1 real, 1009.8 MB
__[runlim] sample:		47.7 time, 4360.1 real, 1135.8 MB
___[runlim] sample:		57.7 time, 4370.1 real, 1445.4 MB
_[runlim] sample:		67.7 time, 4380.1 real, 1606.2 MB
__[runlim] sample:		77.7 time, 4390.1 real, 1861.7 MB
__[runlim] sample:		87.7 time, 4400.1 real, 2057.6 MB
_[runlim] sample:		97.7 time, 4410.1 real, 2157.0 MB
_[runlim] sample:		107.7 time, 4420.1 real, 2353.3 MB
_..[runlim] sample:		117.7 time, 4430.1 real, 2481.8 MB
[runlim] sample:		127.7 time, 4440.1 real, 2578.2 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SUB **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 67125375_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 3221278720_32][13_5 := 3221278462_32][1_5 := 32768_32][3_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 1140863103_32
  S1: state_counter = 1_10
  S1: val1 = 2147485696_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 68161663_32
  S2: state_counter = 2_10
  S2: val1 = 1074266112_32
  S2: val2 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 3221225472_32
  S3: val2 = 4096_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2684358783_32
  S4: state_counter = 4_10
  S4: val1 = 1090519040_32
  S4: val2 = 536870912_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1082131583_32
  S5: state_counter = 5_10
  S5: val1 = 0_32
  S5: val2 = 0_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1090520083_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1085702323_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 1_5
  S8: state_counter = 8_10
  S8: val1 = 1207959552_32
  S8: val2 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3222274048_32
  S9: val2 = 3221258368_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 3221278462_32
  S10: val2 = 1342177280_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 29360255_32
  S11: state_counter = 11_10
  S11: val1 = 2147483648_32
  S11: val2 = 1082130432_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2126512255_32
  S12: state_counter = 12_10
  S12: val1 = 3221278436_32
  S12: val2 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 32768_32
  S13: val2 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 6291583_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 536871039_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4261707903_32
  S16: state_counter = 16_10
  S16: val1 = 3221225472_32
  S16: val2 = 3221225472_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1151_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 2147582079_32
  S18: state_counter = 18_10
  S18: val1 = 536870912_32
  S18: val2 = 1140850688_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 3221226623_32
  S19: state_counter = 19_10
  S19: val1 = 53232_32
  S19: val2 = 53252_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 3221278462_32
  S20: val2 = 3221278720_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073741951_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 3221278720_32][13_5 := 3221278462_32][1_5 := 3221278462_32][3_5 := 2147483648_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SUB.vcd
  Test for SUB using testing-workflow/bug-injection-patches/alu-bug-injected_2_SUB.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SUB:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SUB.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..e0b03b5 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -24,7 +24,7 @@ module alu(
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
-        `ALU_OP_SUB : out = in1 - in2;
+        `ALU_OP_SUB : out = in1 + in2;
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		2.2 time, 4450.1 real, 172.8 MB
[runlim] sample:		12.2 time, 4460.1 real, 202.3 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SUB" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		2.8 time, 4470.1 real, 112.8 MB
_[runlim] sample:		12.8 time, 4480.1 real, 483.9 MB
___[runlim] sample:		22.8 time, 4490.1 real, 697.6 MB
__[runlim] sample:		32.8 time, 4500.1 real, 965.6 MB
___[runlim] sample:		42.8 time, 4510.1 real, 1112.8 MB
__[runlim] sample:		52.8 time, 4520.1 real, 1341.1 MB
__[runlim] sample:		62.8 time, 4530.1 real, 1561.6 MB
__[runlim] sample:		72.8 time, 4540.1 real, 1856.7 MB
_[runlim] sample:		82.8 time, 4550.1 real, 1934.6 MB
__[runlim] sample:		92.8 time, 4560.1 real, 2132.7 MB
_[runlim] sample:		102.8 time, 4570.1 real, 2254.9 MB
[runlim] sample:		112.8 time, 4580.1 real, 2386.7 MB
_..[runlim] sample:		122.8 time, 4590.1 real, 2549.7 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SUB **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 1073741951_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 112984063_32][13_5 := 4456449_32][15_5 := 16_32][1_5 := 8_32][3_5 := 1577058304_32][5_5 := 1078198273_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 268439679_32
  S1: state_counter = 1_10
  S1: val1 = 2147483712_32
  S1: val2 = 1073741840_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147487871_32
  S2: state_counter = 2_10
  S2: val1 = 3221225472_32
  S2: val2 = 33554432_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 67113087_32
  S3: state_counter = 3_10
  S3: val1 = 2147483648_32
  S3: val2 = 2097152_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 268439679_32
  S4: state_counter = 4_10
  S4: val1 = 134217728_32
  S4: val2 = 2415919104_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1090520191_32
  S5: state_counter = 5_10
  S5: val1 = 3221225472_32
  S5: val2 = 1140850688_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1082131475_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1087770291_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 29_5
  S8: state_counter = 8_10
  S8: val1 = 1610612736_32
  S8: val2 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1577058312_32
  S9: val2 = 4456448_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 112984049_32
  S10: val2 = 2113929216_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1441919_32
  S11: state_counter = 11_10
  S11: val1 = 1577058304_32
  S11: val2 = 1040187392_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2114421503_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32
  S12: val2 = 1207959552_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 1207959552_32
  S13: val2 = 4456480_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 1540223_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 4456448_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 2147483648_32
  S15: val2 = 268435456_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4263149695_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 4456448_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 67108991_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 536870912_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 917631_32
  S18: state_counter = 18_10
  S18: val1 = 3221225472_32
  S18: val2 = 8388608_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1186725887_32
  S19: val2 = 1078198273_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 112984063_32
  S20: val2 = 4456449_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073741951_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 112984063_32][13_5 := 4456449_32][15_5 := 16_32][1_5 := 8_32][29_5 := 117440512_32][3_5 := 1577058304_32][5_5 := 1078198273_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SUB.vcd
[runlim] sample:		132.8 time, 4600.1 real, 2477.0 MB
  Test for SUB using testing-workflow/bug-injection-patches/alu-bug-injected_0_SUB.patch succeeded, CoSA found a counterexample as expected.

Operator name: AND
  Bug injection patch file for instruction AND:  testing-workflow/bug-injection-patches/alu-bug-injected_0_AND.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..ee4a54e 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -20,7 +20,7 @@ module alu(
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
-        `ALU_OP_AND : out = in1 & in2;
+        `ALU_OP_AND : out = in1 ^ in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		6.2 time, 4610.1 real, 202.3 MB
[runlim] sample:		16.2 time, 4620.1 real, 202.3 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for AND" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.8 time, 4630.1 real, 357.3 MB
__[runlim] sample:		16.8 time, 4640.1 real, 540.4 MB
___[runlim] sample:		26.8 time, 4650.1 real, 752.6 MB
__[runlim] sample:		36.7 time, 4660.1 real, 1029.3 MB
__[runlim] sample:		46.7 time, 4670.1 real, 1090.7 MB
__[runlim] sample:		56.7 time, 4680.1 real, 1425.9 MB
__[runlim] sample:		66.7 time, 4690.1 real, 1557.1 MB
__[runlim] sample:		76.7 time, 4700.1 real, 1865.8 MB
__[runlim] sample:		86.7 time, 4710.1 real, 2081.2 MB
_[runlim] sample:		96.7 time, 4720.1 real, 2107.0 MB
_[runlim] sample:		106.7 time, 4730.1 real, 2277.9 MB
_..[runlim] sample:		116.7 time, 4740.1 real, 2434.9 MB
[runlim] sample:		126.7 time, 4750.1 real, 2574.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for AND **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 276844671_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2147483648_32][16_5 := 32_32][24_5 := 1073741856_32][8_5 := 256_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 268435583_32
  S1: state_counter = 1_10
  S1: val1 = 2149580800_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147487871_32
  S2: state_counter = 2_10
  S2: val1 = 8388608_32
  S2: val2 = 1207959552_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2164265087_32
  S3: state_counter = 3_10
  S3: val1 = 536870912_32
  S3: val2 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 1048576_32
  S4: val2 = 805306368_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1610613887_32
  S5: state_counter = 5_10
  S5: val1 = 3221225472_32
  S5: val2 = 1610612736_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25722419_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 28_5
  S8: state_counter = 8_10
  S8: val1 = 1342177280_32
  S8: val2 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1610743808_32
  S9: val2 = 4294966928_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1610612736_32
  S10: val2 = 1610612736_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 25493887_32
  S11: state_counter = 11_10
  S11: val1 = 8_32
  S11: val2 = 1073741857_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2122648959_32
  S12: state_counter = 12_10
  S12: val1 = 3221225472_32
  S12: val2 = 1073741856_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 32895_32
  S13: state_counter = 13_10
  S13: val1 = 134217728_32
  S13: val2 = 8454144_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 26083455_32
  S14: state_counter = 14_10
  S14: val1 = 201326592_32
  S14: val2 = 1082063360_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 127_32
  S15: state_counter = 15_10
  S15: val1 = 32_32
  S15: val2 = 65536_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1254196351_32
  S16: state_counter = 16_10
  S16: val1 = 1073741856_32
  S16: val2 = 1082064768_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1107301503_32
  S17: state_counter = 17_10
  S17: val1 = 31_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 33558655_32
  S18: state_counter = 18_10
  S18: val1 = 262144_32
  S18: val2 = 3221225472_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 33685631_32
  S19: state_counter = 19_10
  S19: val1 = 33554432_32
  S19: val2 = 1145044992_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 134353023_32
  S20: state_counter = 20_10
  S20: val1 = 32_32
  S20: val2 = 1073741856_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 536899711_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 4223_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2147483648_32][16_5 := 32_32][24_5 := 1073741856_32][28_5 := 1073741824_32][8_5 := 256_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for AND.vcd
  Test for AND using testing-workflow/bug-injection-patches/alu-bug-injected_0_AND.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction AND:  testing-workflow/bug-injection-patches/alu-bug-injected_2_AND.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..7b21326 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -199,7 +199,7 @@ module decoder(
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
         `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
-        `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_AND;
+        `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_XOR;
         default : alu_op_arith = `ALU_OP_ADD;
       endcase // case (funct3)
    end // always @ begin
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		4.0 time, 4760.1 real, 192.0 MB
[runlim] sample:		14.0 time, 4770.1 real, 202.0 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for AND" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		4.7 time, 4780.1 real, 263.5 MB
_[runlim] sample:		14.8 time, 4790.1 real, 525.4 MB
___[runlim] sample:		24.7 time, 4800.1 real, 696.6 MB
___[runlim] sample:		34.7 time, 4810.1 real, 957.8 MB
__[runlim] sample:		44.7 time, 4820.1 real, 1095.7 MB
__[runlim] sample:		54.7 time, 4830.1 real, 1373.7 MB
__[runlim] sample:		64.7 time, 4840.1 real, 1532.8 MB
_[runlim] sample:		74.7 time, 4850.1 real, 1743.0 MB
__[runlim] sample:		84.7 time, 4860.1 real, 1945.3 MB
_[runlim] sample:		94.7 time, 4870.1 real, 2198.5 MB
__[runlim] sample:		104.7 time, 4880.1 real, 2231.5 MB
_.[runlim] sample:		114.7 time, 4890.1 real, 2384.9 MB
.[runlim] sample:		124.7 time, 4900.1 real, 2512.5 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for AND **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268464255_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 1073741824_32][1_5 := 1073741824_32][24_5 := 3221225472_32][26_5 := 3558866944_32][2_5 := 262144_32][3_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 134221951_32
  S1: state_counter = 1_10
  S1: val1 = 536936448_32
  S1: val2 = 537395200_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147487871_32
  S2: state_counter = 2_10
  S2: val1 = 1610612736_32
  S2: val2 = 536870912_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2164265087_32
  S3: state_counter = 3_10
  S3: val1 = 134217728_32
  S3: val2 = 33554432_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 3238006911_32
  S4: state_counter = 4_10
  S4: val1 = 536870912_32
  S4: val2 = 1107296256_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32
  S5: val2 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33556531_32
  S6: state_counter = 6_10
  S6: val1 = 0_32
  S6: val2 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 27817011_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32
  S7: val2 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 8_5
  S8: state_counter = 8_10
  S8: val1 = 0_32
  S8: val2 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 3221225472_32
  S9: val2 = 1207959552_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741825_32
  S10: val2 = 1409288192_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1074857599_32
  S11: state_counter = 11_10
  S11: val1 = 16777216_32
  S11: val2 = 1342177280_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 3214975_32
  S12: state_counter = 12_10
  S12: val1 = 0_32
  S12: val2 = 0_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073743487_32
  S13: state_counter = 13_10
  S13: val1 = 1208090624_32
  S13: val2 = 3558866944_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2147517567_32
  S14: state_counter = 14_10
  S14: val1 = 1074266112_32
  S14: val2 = 1090519040_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073742975_32
  S15: state_counter = 15_10
  S15: val1 = 1073741824_32
  S15: val2 = 3558866944_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4261412991_32
  S16: state_counter = 16_10
  S16: val1 = 0_32
  S16: val2 = 262144_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073747071_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32
  S17: val2 = 3559129088_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1343615_32
  S18: state_counter = 18_10
  S18: val1 = 100663296_32
  S18: val2 = 1144258560_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 0_32
  S19: val2 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32
  S20: val2 = 3558866944_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 28799_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 1073741824_32][1_5 := 1073741824_32][24_5 := 3221225472_32][26_5 := 3558866944_32][2_5 := 262144_32][3_5 := 2147483648_32][8_5 := 2485125120_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for AND.vcd
[runlim] sample:		134.7 time, 4910.1 real, 2442.4 MB
  Test for AND using testing-workflow/bug-injection-patches/alu-bug-injected_2_AND.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction AND:  testing-workflow/bug-injection-patches/alu-bug-injected_1_AND.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..ae1b07a 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -20,7 +20,7 @@ module alu(
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
-        `ALU_OP_AND : out = in1 & in2;
+        `ALU_OP_AND : out = in1 << in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		7.2 time, 4920.1 real, 202.5 MB
[runlim] sample:		17.2 time, 4930.1 real, 202.5 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for AND" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		7.7 time, 4940.1 real, 357.5 MB
___[runlim] sample:		17.7 time, 4950.1 real, 584.4 MB
__[runlim] sample:		27.7 time, 4960.1 real, 782.1 MB
___[runlim] sample:		37.7 time, 4970.1 real, 1002.4 MB
__[runlim] sample:		47.7 time, 4980.1 real, 1246.8 MB
__[runlim] sample:		57.7 time, 4990.1 real, 1459.8 MB
__[runlim] sample:		67.7 time, 5000.1 real, 1639.2 MB
_[runlim] sample:		77.7 time, 5010.1 real, 1866.1 MB
__[runlim] sample:		87.6 time, 5020.1 real, 2056.3 MB
_[runlim] sample:		97.7 time, 5030.1 real, 2146.1 MB
_[runlim] sample:		107.6 time, 5040.1 real, 2280.5 MB
_..[runlim] sample:		117.6 time, 5050.1 real, 2496.6 MB
[runlim] sample:		127.6 time, 5060.1 real, 2495.1 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for AND **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268456063_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1074003968_32][12_5 := 65536_32][16_5 := 2147483648_32][17_5 := 2147483648_32][24_5 := 3221225472_32][29_5 := 1074003968_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 536875135_32
  S1: state_counter = 1_10
  S1: val2 = 2147483776_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 134221951_32
  S2: state_counter = 2_10
  S2: val1 = 1344274432_32
  S2: val2 = 536870912_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 1073741824_32
  S3: val2 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2155876479_32
  S4: state_counter = 4_10
  S4: val1 = 16777216_32
  S4: val2 = 4194304_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 545263743_32
  S5: state_counter = 5_10
  S5: val1 = 3221225472_32
  S5: val2 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 2147483648_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 30767155_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 16_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32
  S8: val2 = 16777216_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1090519040_32
  S9: val2 = 1074003970_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1074003968_32
  S10: val2 = 1073741824_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 25166463_32
  S11: state_counter = 11_10
  S11: val1 = 0_32
  S11: val2 = 1075838976_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2126515839_32
  S12: state_counter = 12_10
  S12: val1 = 1074003968_32
  S12: val2 = 1074003968_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 0_32
  S13: val2 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 1098940543_32
  S14: state_counter = 14_10
  S14: val1 = 1074003968_32
  S14: val2 = 1074003968_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 1091076223_32
  S16: state_counter = 16_10
  S16: val1 = 1074003968_32
  S16: val2 = 1074003968_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 537399423_32
  S18: state_counter = 18_10
  S18: val1 = 1342177280_32
  S18: val2 = 33554432_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 268439679_32
  S19: state_counter = 19_10
  S19: val1 = 0_32
  S19: val2 = 33554448_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 335548543_32
  S20: state_counter = 20_10
  S20: val1 = 1074003968_32
  S20: val2 = 1074003968_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 28799_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 268439679_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1074003968_32][12_5 := 65536_32][17_5 := 2147483648_32][24_5 := 3221225472_32][29_5 := 1074003968_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for AND.vcd
  Test for AND using testing-workflow/bug-injection-patches/alu-bug-injected_1_AND.patch succeeded, CoSA found a counterexample as expected.

Operator name: OR
  Bug injection patch file for instruction OR:  testing-workflow/bug-injection-patches/alu-bug-injected_1_OR.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..8b912a8 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -19,7 +19,7 @@ module alu(
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
-        `ALU_OP_OR : out = in1 | in2;
+        `ALU_OP_OR : out = in1 ^ in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		1.3 time, 5070.1 real, 116.6 MB
[runlim] sample:		11.3 time, 5080.1 real, 202.2 MB
[runlim] sample:		2.1 time, 5090.1 real, 86.9 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction For OR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		12.1 time, 5100.1 real, 482.9 MB
___[runlim] sample:		22.1 time, 5110.1 real, 681.4 MB
__[runlim] sample:		32.1 time, 5120.1 real, 882.9 MB
__[runlim] sample:		42.1 time, 5130.1 real, 1083.6 MB
___[runlim] sample:		52.0 time, 5140.1 real, 1308.2 MB
__[runlim] sample:		62.0 time, 5150.1 real, 1536.3 MB
_[runlim] sample:		72.0 time, 5160.1 real, 1791.6 MB
_[runlim] sample:		82.0 time, 5170.1 real, 1952.7 MB
__[runlim] sample:		92.0 time, 5180.1 real, 2055.8 MB
_[runlim] sample:		102.0 time, 5190.1 real, 2171.6 MB
_[runlim] sample:		112.0 time, 5200.1 real, 2372.5 MB
_..[runlim] sample:		122.0 time, 5210.1 real, 2638.6 MB
[runlim] sample:		132.0 time, 5220.1 real, 2555.4 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction For OR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 536887423_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 32_32][21_5 := 30_32][24_5 := 3221225478_32][7_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 268439679_32
  S1: state_counter = 1_10
  S1: val1 = 2147549184_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147745919_32
  S2: state_counter = 2_10
  S2: val1 = 134217728_32
  S2: val2 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 537137279_32
  S3: state_counter = 3_10
  S3: val1 = 268435456_32
  S3: val2 = 33554432_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 553914495_32
  S4: state_counter = 4_10
  S4: val1 = 262144_32
  S4: val2 = 536870912_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32
  S5: val2 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554483_32
  S6: state_counter = 6_10
  S6: val1 = 0_32
  S6: val2 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25878835_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32
  S7: val2 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 2_5
  S8: state_counter = 8_10
  S8: val1 = 0_32
  S8: val2 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073741824_32
  S9: val2 = 1073741824_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 30_32
  S10: val2 = 3221225488_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1094747263_32
  S11: state_counter = 11_10
  S11: val1 = 1073741824_32
  S11: val2 = 1610612736_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2169539839_32
  S12: state_counter = 12_10
  S12: val1 = 30_32
  S12: val2 = 0_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073742975_32
  S13: state_counter = 13_10
  S13: val1 = 1073741824_32
  S13: val2 = 3221225476_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2164260991_32
  S14: state_counter = 14_10
  S14: val1 = 30_32
  S14: val2 = 0_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073742975_32
  S15: state_counter = 15_10
  S15: val1 = 1073741824_32
  S15: val2 = 1342177280_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4285007231_32
  S16: state_counter = 16_10
  S16: val1 = 24_32
  S16: val2 = 3221225488_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073743615_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32
  S17: val2 = 3221225476_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 98431_32
  S18: state_counter = 18_10
  S18: val1 = 0_32
  S18: val2 = 0_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1073741854_32
  S19: val2 = 33554438_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 30_32
  S20: val2 = 3221225478_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 16801919_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 32_32][21_5 := 30_32][24_5 := 3221225478_32][2_5 := 3221225496_32][7_5 := 2147483648_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction For OR.vcd
  Test for OR using testing-workflow/bug-injection-patches/alu-bug-injected_1_OR.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction OR:  testing-workflow/bug-injection-patches/alu-bug-injected_0_OR.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..9893173 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -19,7 +19,7 @@ module alu(
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
-        `ALU_OP_OR : out = in1 | in2;
+        `ALU_OP_OR : out = in1 & in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		1.4 time, 5230.1 real, 125.9 MB
[runlim] sample:		11.4 time, 5240.1 real, 202.0 MB
[runlim] sample:		2.0 time, 5250.1 real, 85.2 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction For OR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		12.0 time, 5260.1 real, 482.9 MB
___[runlim] sample:		22.0 time, 5270.1 real, 688.9 MB
__[runlim] sample:		32.0 time, 5280.1 real, 844.0 MB
___[runlim] sample:		42.0 time, 5290.1 real, 1118.5 MB
__[runlim] sample:		52.0 time, 5300.1 real, 1366.9 MB
__[runlim] sample:		61.9 time, 5310.1 real, 1571.7 MB
_[runlim] sample:		71.9 time, 5320.1 real, 1743.2 MB
__[runlim] sample:		81.9 time, 5330.1 real, 2018.8 MB
_[runlim] sample:		91.9 time, 5340.1 real, 2171.4 MB
_[runlim] sample:		101.9 time, 5350.1 real, 2196.4 MB
_[runlim] sample:		111.9 time, 5360.1 real, 2410.5 MB
_..[runlim] sample:		121.9 time, 5370.1 real, 2570.5 MB
[runlim] sample:		131.9 time, 5380.1 real, 2633.0 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction For OR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2147508351_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 262144_32][16_5 := 262152_32][20_5 := 131072_32][2_5 := 8_32][4_5 := 1073741824_32][7_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2684354687_32
  S1: state_counter = 1_10
  S1: val1 = 1075838981_32
  S1: val2 = 2147614725_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 67108991_32
  S2: state_counter = 2_10
  S2: val1 = 536870912_32
  S2: val2 = 67108864_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 536875135_32
  S3: state_counter = 3_10
  S3: val1 = 2281701376_32
  S3: val2 = 268435456_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1073746047_32
  S4: state_counter = 4_10
  S4: val1 = 1073741825_32
  S4: val2 = 64_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 2147487871_32
  S5: state_counter = 5_10
  S5: val1 = 4096_32
  S5: val2 = 268435456_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1140850688_32
  S6: val2 = 1140850688_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 21226035_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 4_5
  S8: state_counter = 8_10
  S8: val1 = 1610612736_32
  S8: val2 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073741824_32
  S9: val2 = 131080_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1342177280_32
  S10: val2 = 1140850688_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 65663_32
  S11: state_counter = 11_10
  S11: val1 = 1073741824_32
  S11: val2 = 132096_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 16844927_32
  S12: state_counter = 12_10
  S12: val1 = 3489660928_32
  S12: val2 = 16777216_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 2149385343_32
  S13: state_counter = 13_10
  S13: val1 = 2415919104_32
  S13: val2 = 131072_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 1074922367_32
  S14: state_counter = 14_10
  S14: val1 = 2147483648_32
  S14: val2 = 1610612736_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 536872063_32
  S15: state_counter = 15_10
  S15: val1 = 536870912_32
  S15: val2 = 1073741824_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4279271551_32
  S16: state_counter = 16_10
  S16: val1 = 1610612736_32
  S16: val2 = 2147483776_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1342177280_32
  S17: val2 = 2147483648_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 8388735_32
  S18: state_counter = 18_10
  S18: val1 = 4096_32
  S18: val2 = 1073872897_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 0_32
  S19: val2 = 1073872896_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 16777343_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32
  S20: val2 = 131072_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 24703_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 134221951_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 262144_32][16_5 := 262152_32][20_5 := 131072_32][2_5 := 8_32][7_5 := 1073741824_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction For OR.vcd
  Test for OR using testing-workflow/bug-injection-patches/alu-bug-injected_0_OR.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction OR:  testing-workflow/bug-injection-patches/alu-bug-injected_2_OR.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..286657b 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -198,7 +198,7 @@ module decoder(
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
-        `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
+        `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_AND;
         default : alu_op_arith = `ALU_OP_ADD;
       endcase // case (funct3)
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		4.3 time, 5390.1 real, 192.3 MB
[runlim] sample:		14.3 time, 5400.1 real, 202.3 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction For OR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		5.1 time, 5410.1 real, 271.7 MB
__[runlim] sample:		15.1 time, 5420.1 real, 523.9 MB
__[runlim] sample:		25.1 time, 5430.1 real, 747.8 MB
___[runlim] sample:		35.1 time, 5440.1 real, 994.1 MB
__[runlim] sample:		45.1 time, 5450.1 real, 1107.5 MB
__[runlim] sample:		55.1 time, 5460.1 real, 1425.8 MB
__[runlim] sample:		65.1 time, 5470.1 real, 1607.6 MB
__[runlim] sample:		75.1 time, 5480.1 real, 1852.7 MB
__[runlim] sample:		85.1 time, 5490.1 real, 2073.8 MB
_[runlim] sample:		95.1 time, 5500.1 real, 2106.7 MB
_[runlim] sample:		105.1 time, 5510.1 real, 2217.5 MB
_.[runlim] sample:		115.0 time, 5520.1 real, 2352.4 MB
.[runlim] sample:		125.0 time, 5530.1 real, 2505.3 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction For OR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2147508351_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 16_32][16_5 := 1073741857_32][17_5 := 1073741824_32][19_5 := 2147483712_32][24_5 := 1073741856_32][8_5 := 1073741825_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2281713791_32
  S1: state_counter = 1_10
  S1: val2 = 2147483776_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 135266431_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32
  S2: val2 = 536870912_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2148536447_32
  S3: state_counter = 3_10
  S3: val1 = 4194304_32
  S3: val2 = 134217728_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 135268479_32
  S4: state_counter = 4_10
  S4: val1 = 536870912_32
  S4: val2 = 1074003968_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 3221226623_32
  S5: state_counter = 5_10
  S5: val1 = 3221225472_32
  S5: val2 = 1610612736_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25454643_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 16_5
  S8: state_counter = 8_10
  S8: val1 = 1342177280_32
  S8: val2 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1075838976_32
  S9: val2 = 1207959584_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741826_32
  S10: val2 = 1073741860_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 4819327_32
  S11: state_counter = 11_10
  S11: val1 = 0_32
  S11: val2 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 4274621311_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32
  S12: val2 = 1073741856_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 4456575_32
  S13: state_counter = 13_10
  S13: val1 = 0_32
  S13: val2 = 8_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 18481279_32
  S14: state_counter = 14_10
  S14: val1 = 1073741952_32
  S14: val2 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 262271_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4270325887_32
  S16: state_counter = 16_10
  S16: val1 = 1073741828_32
  S16: val2 = 1073741856_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 4194431_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1048703_32
  S18: state_counter = 18_10
  S18: val1 = 268435456_32
  S18: val2 = 536870912_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 8_32
  S19: val2 = 8_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073741825_32
  S20: val2 = 1073741856_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 2147508351_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 67113087_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[12_5 := 16_32][16_5 := 33_32][17_5 := 1073741824_32][19_5 := 2147483712_32][24_5 := 1073741856_32][8_5 := 1073741825_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction For OR.vcd
[runlim] sample:		135.0 time, 5540.1 real, 2034.0 MB
  Test for OR using testing-workflow/bug-injection-patches/alu-bug-injected_2_OR.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction OR:  testing-workflow/bug-injection-patches/alu-bug-injected_00_OR.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..9893173 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -19,7 +19,7 @@ module alu(
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
-        `ALU_OP_OR : out = in1 | in2;
+        `ALU_OP_OR : out = in1 & in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		9.1 time, 5550.1 real, 202.1 MB
[runlim] sample:		19.1 time, 5560.1 real, 279.3 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction For OR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		9.4 time, 5570.1 real, 357.3 MB
___[runlim] sample:		19.4 time, 5580.1 real, 617.6 MB
__[runlim] sample:		29.4 time, 5590.1 real, 785.4 MB
___[runlim] sample:		39.4 time, 5600.1 real, 1079.2 MB
__[runlim] sample:		49.4 time, 5610.1 real, 1268.7 MB
__[runlim] sample:		59.4 time, 5620.1 real, 1466.9 MB
__[runlim] sample:		69.4 time, 5630.1 real, 1671.5 MB
__[runlim] sample:		79.4 time, 5640.1 real, 1947.8 MB
_[runlim] sample:		89.4 time, 5650.1 real, 2140.7 MB
_[runlim] sample:		99.4 time, 5660.1 real, 2177.8 MB
_[runlim] sample:		109.4 time, 5670.1 real, 2333.0 MB
_..[runlim] sample:		119.4 time, 5680.1 real, 2496.2 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction For OR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2147508351_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 257_32][1_5 := 1_32][24_5 := 1073741825_32][8_5 := 1073742081_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2684354687_32
  S1: state_counter = 1_10
  S1: val1 = 1075838981_32
  S1: val2 = 2281701376_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 134217728_32
  S2: val2 = 1073741824_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 553652351_32
  S3: state_counter = 3_10
  S3: val1 = 2147483648_32
  S3: val2 = 1140850688_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2164265087_32
  S4: state_counter = 4_10
  S4: val1 = 536870912_32
  S4: val2 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32
  S5: val2 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554483_32
  S6: state_counter = 6_10
  S6: val1 = 0_32
  S6: val2 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25715763_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32
  S7: val2 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 8_5
  S8: state_counter = 8_10
  S8: val1 = 0_32
  S8: val2 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073741824_32
  S9: val2 = 1612709888_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 256_32
  S10: val2 = 1073741832_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1073742975_32
  S11: state_counter = 11_10
  S11: val1 = 1073741824_32
  S11: val2 = 1073741826_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 1081471_32
  S12: state_counter = 12_10
  S12: val1 = 256_32
  S12: val2 = 0_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073742975_32
  S13: state_counter = 13_10
  S13: val1 = 1073741824_32
  S13: val2 = 1073741826_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 4262494335_32
  S14: state_counter = 14_10
  S14: val1 = 256_32
  S14: val2 = 0_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073742975_32
  S15: state_counter = 15_10
  S15: val1 = 1073741824_32
  S15: val2 = 1073741824_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4267966591_32
  S16: state_counter = 16_10
  S16: val1 = 0_32
  S16: val2 = 0_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32
  S17: val2 = 1073741825_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 327807_32
  S18: state_counter = 18_10
  S18: val1 = 0_32
  S18: val2 = 33554432_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1073742081_32
  S19: val2 = 1_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 16777343_32
  S20: state_counter = 20_10
  S20: val1 = 257_32
  S20: val2 = 1073741825_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 24703_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1073746047_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 257_32][1_5 := 1_32][24_5 := 1073741825_32][8_5 := 1_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction For OR.vcd
[runlim] sample:		129.4 time, 5690.1 real, 2556.8 MB
  Test for OR using testing-workflow/bug-injection-patches/alu-bug-injected_00_OR.patch succeeded, CoSA found a counterexample as expected.

Operator name: XOR
  Bug injection patch file for instruction XOR:  testing-workflow/bug-injection-patches/alu-bug-injected_2_XOR.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..572eac7 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -196,7 +196,7 @@ module decoder(
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
-        `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
+        `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_OR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
         `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
         `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_AND;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		5.7 time, 5700.1 real, 201.9 MB
[runlim] sample:		15.7 time, 5710.1 real, 201.9 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for XOR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.5 time, 5720.1 real, 353.0 MB
__[runlim] sample:		16.4 time, 5730.1 real, 534.3 MB
__[runlim] sample:		26.4 time, 5740.1 real, 744.6 MB
___[runlim] sample:		36.4 time, 5750.1 real, 977.3 MB
__[runlim] sample:		46.4 time, 5760.1 real, 1108.9 MB
__[runlim] sample:		56.4 time, 5770.1 real, 1380.8 MB
__[runlim] sample:		66.4 time, 5780.1 real, 1567.8 MB
__[runlim] sample:		76.4 time, 5790.1 real, 1819.2 MB
_[runlim] sample:		86.4 time, 5800.1 real, 2020.8 MB
_[runlim] sample:		96.4 time, 5810.1 real, 2077.1 MB
__[runlim] sample:		106.4 time, 5820.1 real, 2310.9 MB
[runlim] sample:		116.4 time, 5830.1 real, 2285.3 MB
_..[runlim] sample:		126.4 time, 5840.1 real, 2501.9 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for XOR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2147500159_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 128_32][1_5 := 8_32][20_5 := 1073741824_32][24_5 := 1073741824_32][29_5 := 1073741856_32][4_5 := 1073741824_32][8_5 := 16_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 536883327_32
  S1: state_counter = 1_10
  S1: val1 = 2281701376_32
  S1: val2 = 1073741825_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 1610612863_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32
  S2: val2 = 536870912_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 268435456_32
  S3: val2 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134221951_32
  S4: state_counter = 4_10
  S4: val1 = 1075838976_32
  S4: val2 = 268435456_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1610613887_32
  S5: state_counter = 5_10
  S5: val1 = 3221225472_32
  S5: val2 = 1342177280_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 30559283_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 24_5
  S8: state_counter = 8_10
  S8: val1 = 1610612736_32
  S8: val2 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073745920_32
  S9: val2 = 1073745920_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 1073741856_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 10485887_32
  S11: state_counter = 11_10
  S11: val1 = 0_32
  S11: val2 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2122353791_32
  S12: state_counter = 12_10
  S12: val1 = 1073743872_32
  S12: val2 = 1073741856_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 0_32
  S13: val2 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 4161273983_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1107296256_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 0_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4283302015_32
  S16: state_counter = 16_10
  S16: val1 = 1073741828_32
  S16: val2 = 1073741856_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 8388735_32
  S17: state_counter = 17_10
  S17: val1 = 2147483648_32
  S17: val2 = 33554432_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 127_32
  S18: state_counter = 18_10
  S18: val1 = 0_32
  S18: val2 = 0_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1207959552_32
  S19: val2 = 1073741824_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32
  S20: val2 = 1073741856_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 16793727_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 128_32][1_5 := 8_32][20_5 := 1073741824_32][24_5 := 1073741856_32][29_5 := 1073741856_32][4_5 := 1073741824_32][8_5 := 16_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for XOR.vcd
[runlim] sample:		136.3 time, 5850.1 real, 2438.3 MB
  Test for XOR using testing-workflow/bug-injection-patches/alu-bug-injected_2_XOR.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction XOR:  testing-workflow/bug-injection-patches/alu-bug-injected_00_XOR.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..b1154a3 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -18,7 +18,7 @@ module alu(
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
-        `ALU_OP_XOR : out = in1 ^ in2;
+        `ALU_OP_XOR : out = in1 | in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		7.0 time, 5860.1 real, 202.6 MB
[runlim] sample:		17.0 time, 5870.1 real, 202.6 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for XOR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		7.6 time, 5880.1 real, 357.9 MB
__[runlim] sample:		17.6 time, 5890.1 real, 607.3 MB
___[runlim] sample:		27.6 time, 5900.1 real, 761.2 MB
__[runlim] sample:		37.6 time, 5910.1 real, 1015.3 MB
___[runlim] sample:		47.6 time, 5920.1 real, 1238.1 MB
__[runlim] sample:		57.6 time, 5930.1 real, 1451.4 MB
_[runlim] sample:		67.6 time, 5940.1 real, 1607.5 MB
__[runlim] sample:		77.6 time, 5950.1 real, 1865.2 MB
_[runlim] sample:		87.6 time, 5960.1 real, 2050.7 MB
__[runlim] sample:		97.6 time, 5970.1 real, 2127.9 MB
_[runlim] sample:		107.6 time, 5980.1 real, 2285.5 MB
_[runlim] sample:		117.6 time, 5990.1 real, 2283.6 MB
..[runlim] sample:		127.5 time, 6000.1 real, 2532.6 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for XOR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268435583_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1048576_32][12_5 := 3752836807_32][13_5 := 3752836823_32][15_5 := 3752836823_32][25_5 := 1073741824_32][2_5 := 65536_32][4_5 := 531611350_32][5_5 := 2679094999_32][8_5 := 524400_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 67108991_32
  S1: state_counter = 1_10
  S1: val1 = 536872960_32
  S1: val2 = 2147483652_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147483775_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32
  S2: val2 = 67108864_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2214596735_32
  S3: state_counter = 3_10
  S3: val1 = 2097152_32
  S3: val2 = 0_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 136319103_32
  S4: state_counter = 4_10
  S4: val1 = 268435456_32
  S4: val2 = 268435456_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 538968447_32
  S5: state_counter = 5_10
  S5: val1 = 1090519040_32
  S5: val2 = 67108864_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 12862003_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 4_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32
  S8: val2 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 524352_32
  S9: val2 = 3751804964_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 1946157056_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 2490495_32
  S11: state_counter = 11_10
  S11: val1 = 528384_32
  S11: val2 = 3556804624_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 279347967_32
  S12: state_counter = 12_10
  S12: val1 = 32832_32
  S12: val2 = 1140883472_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 127_32
  S13: state_counter = 13_10
  S13: val1 = 1074003968_32
  S13: val2 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 340230271_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 127_32
  S15: state_counter = 15_10
  S15: val1 = 524400_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4264624255_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1610612736_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 6324351_32
  S17: state_counter = 17_10
  S17: val1 = 131072_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: state_counter = 18_10
  S18: val1 = 1207959552_32
  S18: val2 = 3752830976_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1073774624_32
  S19: val2 = 2679094983_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 8388735_32
  S20: state_counter = 20_10
  S20: val1 = 524400_32
  S20: val2 = 3752836807_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 16511_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1048576_32][12_5 := 3752836807_32][13_5 := 3752836823_32][15_5 := 3752836823_32][25_5 := 1073741824_32][2_5 := 65536_32][4_5 := 3752836855_32][5_5 := 2679094999_32][8_5 := 524400_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for XOR.vcd
[runlim] sample:		137.5 time, 6010.1 real, 2454.3 MB
  Test for XOR using testing-workflow/bug-injection-patches/alu-bug-injected_00_XOR.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction XOR:  testing-workflow/bug-injection-patches/alu-bug-injected_1_XOR.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..b92b56c 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -18,7 +18,7 @@ module alu(
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
-        `ALU_OP_XOR : out = in1 ^ in2;
+        `ALU_OP_XOR : out = in1 & in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		7.1 time, 6020.1 real, 201.9 MB
[runlim] sample:		17.1 time, 6030.1 real, 201.9 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for XOR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		7.8 time, 6040.1 real, 357.2 MB
__[runlim] sample:		17.8 time, 6050.1 real, 582.8 MB
___[runlim] sample:		27.8 time, 6060.1 real, 769.1 MB
___[runlim] sample:		37.8 time, 6070.1 real, 1018.7 MB
__[runlim] sample:		47.8 time, 6080.1 real, 1244.1 MB
__[runlim] sample:		57.8 time, 6090.1 real, 1459.4 MB
__[runlim] sample:		67.8 time, 6100.1 real, 1635.1 MB
_[runlim] sample:		77.8 time, 6110.1 real, 1871.2 MB
__[runlim] sample:		87.8 time, 6120.1 real, 2067.5 MB
_[runlim] sample:		97.8 time, 6130.1 real, 2238.1 MB
_[runlim] sample:		107.8 time, 6140.1 real, 2352.7 MB
_..[runlim] sample:		117.8 time, 6150.1 real, 2488.6 MB
[runlim] sample:		127.8 time, 6160.1 real, 2556.8 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for XOR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2147500159_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 134217728_32][12_5 := 512_32][13_5 := 1074003968_32][17_5 := 262144_32][1_5 := 524288_32][24_5 := 512_32][28_5 := 536870912_32][4_5 := 1073742336_32][5_5 := 262144_32][8_5 := 32_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2684354687_32
  S1: state_counter = 1_10
  S1: val1 = 1075838981_32
  S1: val2 = 2281701376_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 134217728_32
  S2: val2 = 1073741824_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 553652351_32
  S3: state_counter = 3_10
  S3: val1 = 2147483648_32
  S3: val2 = 1140850688_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 268435456_32
  S4: val2 = 268435456_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 67371135_32
  S5: state_counter = 5_10
  S5: val1 = 524288_32
  S5: val2 = 16777216_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 12862003_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 4_5
  S8: state_counter = 8_10
  S8: val1 = 1610612736_32
  S8: val2 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 32_32
  S9: val2 = 514_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 3221225472_32
  S10: val2 = 1610612992_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 8454271_32
  S11: state_counter = 11_10
  S11: val1 = 32_32
  S11: val2 = 524544_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2139424511_32
  S12: state_counter = 12_10
  S12: val1 = 3221225472_32
  S12: val2 = 524288_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 8388735_32
  S13: state_counter = 13_10
  S13: val1 = 4194304_32
  S13: val2 = 2147483648_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 14844031_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 512_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 17825919_32
  S15: state_counter = 15_10
  S15: val1 = 32_32
  S15: val2 = 2147483648_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4262330495_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1074790400_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1077937279_32
  S17: state_counter = 17_10
  S17: val1 = 32_32
  S17: val2 = 128_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 32895_32
  S18: state_counter = 18_10
  S18: val1 = 3221225472_32
  S18: val2 = 1610612736_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1073741824_32
  S19: val2 = 33554432_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 32_32
  S20: val2 = 512_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 16511_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 134221951_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 134217728_32][12_5 := 512_32][13_5 := 1074003968_32][17_5 := 262144_32][1_5 := 524288_32][24_5 := 512_32][28_5 := 536870912_32][5_5 := 262144_32][8_5 := 32_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for XOR.vcd
[runlim] sample:		137.8 time, 6170.1 real, 2084.1 MB
  Test for XOR using testing-workflow/bug-injection-patches/alu-bug-injected_1_XOR.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction XOR:  testing-workflow/bug-injection-patches/alu-bug-injected_0_XOR.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..82173e1 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -18,7 +18,7 @@ module alu(
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
         `ALU_OP_SLL : out = in1 << shamt;
-        `ALU_OP_XOR : out = in1 ^ in2;
+        `ALU_OP_XOR : out = in1 + in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
         `ALU_OP_SRL : out = in1 >> shamt;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		9.2 time, 6180.1 real, 202.4 MB
[runlim] sample:		19.2 time, 6190.1 real, 283.2 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for XOR" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		9.8 time, 6200.1 real, 449.9 MB
___[runlim] sample:		19.8 time, 6210.1 real, 626.2 MB
__[runlim] sample:		29.8 time, 6220.1 real, 770.5 MB
___[runlim] sample:		39.7 time, 6230.1 real, 1022.1 MB
__[runlim] sample:		49.7 time, 6240.1 real, 1243.9 MB
__[runlim] sample:		59.7 time, 6250.1 real, 1462.5 MB
__[runlim] sample:		69.7 time, 6260.1 real, 1653.5 MB
_[runlim] sample:		79.7 time, 6270.1 real, 1864.5 MB
__[runlim] sample:		89.7 time, 6280.1 real, 2064.9 MB
_[runlim] sample:		99.7 time, 6290.1 real, 2241.6 MB
_[runlim] sample:		109.7 time, 6300.1 real, 2309.7 MB
_..[runlim] sample:		119.7 time, 6310.1 real, 2432.6 MB
[runlim] sample:		129.7 time, 6320.1 real, 2525.8 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for XOR **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268451967_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 1342177344_32][16_5 := 268828732_32][17_5 := 268435456_32][1_5 := 1073741824_32][24_5 := 131072_32][27_5 := 2147483648_32][9_5 := 1342177280_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 335548543_32
  S1: state_counter = 1_10
  S1: val1 = 2181038144_32
  S1: val2 = 1342177296_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 2147483648_32
  S2: val2 = 268435456_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 134217728_32
  S3: val2 = 1082130432_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 134217855_32
  S4: state_counter = 4_10
  S4: val1 = 262144_32
  S4: val2 = 536870912_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1082131583_32
  S5: state_counter = 5_10
  S5: val1 = 1342177280_32
  S5: val2 = 3221225472_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25708595_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 16_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32
  S8: val2 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 268828732_32
  S9: val2 = 139264_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 1610612992_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 11042943_32
  S11: state_counter = 11_10
  S11: val1 = 268828728_32
  S11: val2 = 131328_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 12092671_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32
  S12: val2 = 131104_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 17301631_32
  S13: state_counter = 13_10
  S13: val1 = 268828732_32
  S13: val2 = 536870912_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2176614527_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 131072_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 8388735_32
  S15: state_counter = 15_10
  S15: val1 = 268828704_32
  S15: val2 = 2147483664_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4281729151_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 524415_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 2147483648_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 22020223_32
  S18: state_counter = 18_10
  S18: val1 = 301989888_32
  S18: val2 = 0_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1073741824_32
  S19: val2 = 1073741824_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 268828732_32
  S20: val2 = 131072_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 16793727_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2164265087_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 1342177344_32][16_5 := 268959804_32][17_5 := 268435456_32][1_5 := 1073741824_32][24_5 := 131072_32][27_5 := 2147483648_32][9_5 := 1342177280_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for XOR.vcd
  Test for XOR using testing-workflow/bug-injection-patches/alu-bug-injected_0_XOR.patch succeeded, CoSA found a counterexample as expected.

Operator name: SLL
  Bug injection patch file for instruction SLL:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SLL.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..65dc0d2 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -17,7 +17,7 @@ module alu(
    always @(*) begin
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
-        `ALU_OP_SLL : out = in1 << shamt;
+        `ALU_OP_SLL : out = in1 + shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		1.4 time, 6330.1 real, 127.6 MB
[runlim] sample:		11.4 time, 6340.1 real, 201.7 MB
[runlim] sample:		2.2 time, 6350.1 real, 87.6 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLL" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		12.2 time, 6360.1 real, 474.0 MB
___[runlim] sample:		22.2 time, 6370.1 real, 682.9 MB
__[runlim] sample:		32.2 time, 6380.1 real, 955.3 MB
___[runlim] sample:		42.2 time, 6390.1 real, 1112.0 MB
__[runlim] sample:		52.2 time, 6400.1 real, 1374.4 MB
__[runlim] sample:		62.2 time, 6410.1 real, 1565.8 MB
__[runlim] sample:		72.2 time, 6420.1 real, 1856.1 MB
_[runlim] sample:		82.2 time, 6430.1 real, 1966.4 MB
_[runlim] sample:		92.2 time, 6440.1 real, 2093.8 MB
__[runlim] sample:		102.2 time, 6450.1 real, 2221.8 MB
_.[runlim] sample:		112.2 time, 6460.1 real, 2375.3 MB
.[runlim] sample:		122.1 time, 6470.1 real, 2550.2 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLL **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268439679_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1073807376_32][29_5 := 1074266096_32][2_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 536875135_32
  S1: state_counter = 1_10

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147487871_32
  S2: state_counter = 2_10
  S2: val1 = 201326592_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 268439679_32
  S3: state_counter = 3_10
  S3: val1 = 1048576_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 33554432_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 2147487871_32
  S5: state_counter = 5_10
  S5: val1 = 16777216_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 11442227_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 16_5
  S8: state_counter = 8_10
  S8: val1 = 268435456_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1075838976_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1074266096_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 17170559_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2114326143_32
  S12: state_counter = 12_10
  S12: val1 = 1073872896_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 16777343_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 27295871_32
  S14: state_counter = 14_10
  S14: val1 = 1074266088_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 127_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4261544063_32
  S16: state_counter = 16_10
  S16: val1 = 1074266097_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 268435583_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 786559_32
  S18: state_counter = 18_10
  S18: val1 = 603979776_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 1048703_32
  S20: state_counter = 20_10
  S20: val1 = 1074266096_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 4223_32
  S21: shimm2_copy = 16_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 1073807376_32][16_5 := 1074266112_32][29_5 := 1074266096_32][2_5 := 2147483648_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLL.vcd
  Test for SLL using testing-workflow/bug-injection-patches/alu-bug-injected_0_SLL.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLL:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SLL.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..84297bb 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -193,7 +193,7 @@ module decoder(
    always @(*) begin
       case (funct3)
         `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
-        `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
+        `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		0.5 time, 6480.1 real, 67.7 MB
[runlim] sample:		10.5 time, 6490.1 real, 202.1 MB
[runlim] sample:		1.1 time, 6500.1 real, 71.0 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLL" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
_[runlim] sample:		11.1 time, 6510.1 real, 459.2 MB
__[runlim] sample:		21.0 time, 6520.1 real, 626.6 MB
___[runlim] sample:		31.0 time, 6530.1 real, 802.3 MB
__[runlim] sample:		41.0 time, 6540.1 real, 1041.4 MB
__[runlim] sample:		51.0 time, 6550.1 real, 1300.5 MB
__[runlim] sample:		61.0 time, 6560.1 real, 1482.2 MB
__[runlim] sample:		71.0 time, 6570.1 real, 1626.9 MB
_[runlim] sample:		81.0 time, 6580.1 real, 1865.5 MB
__[runlim] sample:		91.0 time, 6590.1 real, 2085.1 MB
_[runlim] sample:		101.0 time, 6600.1 real, 2239.8 MB
_[runlim] sample:		111.0 time, 6610.1 real, 2295.5 MB
_..[runlim] sample:		121.0 time, 6620.1 real, 2438.6 MB
[runlim] sample:		131.0 time, 6630.1 real, 2582.3 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLL **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 83906687_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[19_5 := 16_32][3_5 := 1073741856_32][5_5 := 1073741824_32][7_5 := 8_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 67118207_32
  S1: state_counter = 1_10
  S1: val1 = 65537_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536876159_32
  S2: state_counter = 2_10
  S2: val1 = 1073741824_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 268435456_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 67113087_32
  S4: state_counter = 4_10
  S4: val1 = 134217728_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1082131583_32
  S5: state_counter = 5_10
  S5: val1 = 2_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 5345715_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 3_5
  S8: state_counter = 8_10
  S8: val1 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073742848_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741858_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 3145855_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 20809855_32
  S12: state_counter = 12_10
  S12: val1 = 1073741856_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 8388735_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 230271_32
  S14: state_counter = 14_10
  S14: val1 = 3221225472_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 50332031_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 9306239_32
  S16: state_counter = 16_10
  S16: val1 = 1073741856_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 2181038463_32
  S17: state_counter = 17_10
  S17: val1 = 1082130432_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 1086063743_32
  S18: state_counter = 18_10
  S18: val1 = 1073741824_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073751167_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073741856_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 4223_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[19_5 := 16_32][3_5 := 32_32][5_5 := 1073741824_32][7_5 := 8_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLL.vcd
  Test for SLL using testing-workflow/bug-injection-patches/alu-bug-injected_2_SLL.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLL:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SLL.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..656cf18 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -17,7 +17,7 @@ module alu(
    always @(*) begin
       case (op)
         `ALU_OP_ADD : out = in1 + in2;
-        `ALU_OP_SLL : out = in1 << shamt;
+        `ALU_OP_SLL : out = in1 | shamt;
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		3.7 time, 6640.1 real, 192.1 MB
[runlim] sample:		13.7 time, 6650.1 real, 202.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLL" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		4.3 time, 6660.1 real, 262.7 MB
__[runlim] sample:		14.3 time, 6670.1 real, 520.5 MB
__[runlim] sample:		24.3 time, 6680.1 real, 731.7 MB
___[runlim] sample:		34.3 time, 6690.1 real, 974.5 MB
__[runlim] sample:		44.3 time, 6700.1 real, 1110.6 MB
__[runlim] sample:		54.3 time, 6710.1 real, 1431.6 MB
__[runlim] sample:		64.3 time, 6720.1 real, 1610.0 MB
__[runlim] sample:		74.3 time, 6730.1 real, 1847.0 MB
__[runlim] sample:		84.2 time, 6740.1 real, 2085.3 MB
_[runlim] sample:		94.2 time, 6750.1 real, 2129.8 MB
_[runlim] sample:		104.2 time, 6760.1 real, 2327.8 MB
_..[runlim] sample:		114.2 time, 6770.1 real, 2428.1 MB
[runlim] sample:		124.2 time, 6780.1 real, 2568.7 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLL **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268439679_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 1073741840_32][12_5 := 8_32][13_5 := 1073741824_32][1_5 := 16_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 134221951_32
  S1: state_counter = 1_10
  S1: val1 = 536936448_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147483775_32
  S2: state_counter = 2_10
  S2: val1 = 1610612736_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2164265087_32
  S3: state_counter = 3_10
  S3: val1 = 134217728_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 553652351_32
  S4: state_counter = 4_10
  S4: val1 = 268435456_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1090520191_32
  S5: state_counter = 5_10
  S5: val1 = 1077936128_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 11966131_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 13_5
  S8: state_counter = 8_10
  S8: val1 = 1610612736_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073741952_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741825_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 4194431_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2126514303_32
  S12: state_counter = 12_10
  S12: val1 = 1073741856_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 8388735_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 7340159_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4278747775_32
  S16: state_counter = 16_10
  S16: val1 = 1610612736_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 8390271_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 262271_32
  S18: state_counter = 18_10
  S18: val1 = 2147483648_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 0_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 1073741824_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 402657407_32
  S21: shimm2_copy = 16_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 268439679_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 1073741840_32][12_5 := 8_32][13_5 := 1073741840_32][1_5 := 16_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLL.vcd
  Test for SLL using testing-workflow/bug-injection-patches/alu-bug-injected_1_SLL.patch succeeded, CoSA found a counterexample as expected.

Operator name: SRL
  Bug injection patch file for instruction SRL:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SRL.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..e8e3c76 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -21,7 +21,7 @@ module alu(
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
-        `ALU_OP_SRL : out = in1 >> shamt;
+        `ALU_OP_SRL : out = in1 << shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		2.9 time, 6790.1 real, 190.8 MB
[runlim] sample:		12.9 time, 6800.1 real, 202.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRL" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		3.5 time, 6810.1 real, 242.6 MB
_[runlim] sample:		13.5 time, 6820.1 real, 483.6 MB
___[runlim] sample:		23.5 time, 6830.1 real, 696.7 MB
__[runlim] sample:		33.5 time, 6840.1 real, 978.4 MB
___[runlim] sample:		43.5 time, 6850.1 real, 1115.4 MB
__[runlim] sample:		53.5 time, 6860.1 real, 1396.7 MB
__[runlim] sample:		63.5 time, 6870.1 real, 1558.8 MB
__[runlim] sample:		73.5 time, 6880.1 real, 1856.8 MB
_[runlim] sample:		83.5 time, 6890.1 real, 2021.5 MB
_[runlim] sample:		93.5 time, 6900.1 real, 2056.6 MB
__[runlim] sample:		103.5 time, 6910.1 real, 2201.8 MB
_.[runlim] sample:		113.5 time, 6920.1 real, 2357.7 MB
.[runlim] sample:		123.5 time, 6930.1 real, 2553.9 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRL **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 67129471_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 268435456_32][11_5 := 1073741825_32][14_5 := 134217728_32][15_5 := 2_32][16_5 := 2147483664_32][1_5 := 2147483648_32][24_5 := 1073741838_32][3_5 := 1_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 2149597312_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 268439935_32
  S2: state_counter = 2_10
  S2: val1 = 4194304_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 2281701376_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 134217728_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 134221951_32
  S5: state_counter = 5_10
  S5: val1 = 2155872256_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25712435_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 14_5
  S8: state_counter = 8_10
  S8: val1 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 2147483668_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 17170559_32
  S11: state_counter = 11_10
  S11: val1 = 2147483666_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2124873855_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 4194431_32
  S13: state_counter = 13_10
  S13: val1 = 2147483664_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 15171711_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 2097279_32
  S15: state_counter = 15_10
  S15: val1 = 2147483650_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4269899903_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1610612863_32
  S17: state_counter = 17_10
  S17: val1 = 4194304_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 21069951_32
  S18: state_counter = 18_10
  S18: val1 = 536870912_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1090519040_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 2147483664_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 268456063_32
  S21: shimm2_copy = 14_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 67113087_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 268435456_32][11_5 := 1073741825_32][14_5 := 262144_32][15_5 := 2_32][16_5 := 2147483664_32][1_5 := 2147483648_32][24_5 := 1073741838_32][3_5 := 1_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRL.vcd
[runlim] sample:		133.5 time, 6940.1 real, 2480.3 MB
  Test for SRL using testing-workflow/bug-injection-patches/alu-bug-injected_0_SRL.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SRL:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SRL.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..6c69a31 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -197,7 +197,7 @@ module decoder(
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
-        `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
+        `RV32_FUNCT3_SRA_SRL : alu_op_arith = add_or_sub;
         `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
         `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_AND;
         default : alu_op_arith = `ALU_OP_ADD;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		6.1 time, 6950.1 real, 202.1 MB
[runlim] sample:		16.1 time, 6960.1 real, 202.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRL" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		7.0 time, 6970.1 real, 357.5 MB
__[runlim] sample:		17.0 time, 6980.1 real, 588.7 MB
___[runlim] sample:		27.0 time, 6990.1 real, 785.0 MB
___[runlim] sample:		37.0 time, 7000.1 real, 1055.7 MB
__[runlim] sample:		46.9 time, 7010.1 real, 1280.4 MB
__[runlim] sample:		56.9 time, 7020.1 real, 1484.3 MB
__[runlim] sample:		66.9 time, 7030.1 real, 1691.8 MB
_[runlim] sample:		76.9 time, 7040.1 real, 1912.1 MB
_[runlim] sample:		86.9 time, 7050.1 real, 2012.1 MB
__[runlim] sample:		96.9 time, 7060.1 real, 2156.7 MB
_[runlim] sample:		106.9 time, 7070.1 real, 2336.5 MB
_..[runlim] sample:		116.9 time, 7080.1 real, 2438.0 MB
[runlim] sample:		126.9 time, 7090.1 real, 2599.3 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRL **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 151523455_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 786432_32][24_5 := 2097152_32][28_5 := 262144_32][2_5 := 1073741824_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147491967_32
  S1: state_counter = 1_10

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 67113087_32
  S2: state_counter = 2_10
  S2: val1 = 536870912_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 33554432_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 134218879_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554483_32
  S6: state_counter = 6_10
  S6: val1 = 0_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 17715507_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 2_5
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073741824_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 512_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1090520191_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 25166719_32
  S12: state_counter = 12_10
  S12: val1 = 1073741952_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073743743_32
  S13: state_counter = 13_10
  S13: val1 = 1073741824_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 19923839_32
  S14: state_counter = 14_10
  S14: val1 = 262208_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073743487_32
  S15: state_counter = 15_10
  S15: val1 = 1073741824_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4261412991_32
  S16: state_counter = 16_10
  S16: val1 = 0_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1073742975_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 10485887_32
  S18: state_counter = 18_10
  S18: val1 = 1074003984_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1074003968_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 262144_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 16797823_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1073746047_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 786432_32][24_5 := 2097152_32][28_5 := 262144_32][2_5 := 1048576_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRL.vcd
  Test for SRL using testing-workflow/bug-injection-patches/alu-bug-injected_2_SRL.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SRL:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SRL.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..5e1bbef 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -21,7 +21,7 @@ module alu(
         `ALU_OP_XOR : out = in1 ^ in2;
         `ALU_OP_OR : out = in1 | in2;
         `ALU_OP_AND : out = in1 & in2;
-        `ALU_OP_SRL : out = in1 >> shamt;
+        `ALU_OP_SRL : out = in1 & shamt;
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		2.4 time, 7100.1 real, 191.1 MB
[runlim] sample:		12.4 time, 7110.1 real, 202.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRL" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		3.2 time, 7120.1 real, 178.0 MB
_[runlim] sample:		13.2 time, 7130.1 real, 474.6 MB
___[runlim] sample:		23.2 time, 7140.1 real, 693.8 MB
__[runlim] sample:		33.2 time, 7150.1 real, 968.5 MB
___[runlim] sample:		43.2 time, 7160.1 real, 1089.3 MB
__[runlim] sample:		53.2 time, 7170.1 real, 1335.2 MB
__[runlim] sample:		63.2 time, 7180.1 real, 1519.9 MB
_[runlim] sample:		73.2 time, 7190.1 real, 1791.9 MB
__[runlim] sample:		83.2 time, 7200.1 real, 1993.4 MB
_[runlim] sample:		93.2 time, 7210.1 real, 2174.3 MB
__[runlim] sample:		103.2 time, 7220.1 real, 2248.6 MB
_.[runlim] sample:		113.2 time, 7230.1 real, 2331.2 MB
.[runlim] sample:		123.1 time, 7240.1 real, 2523.9 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRL **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268456063_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[1_5 := 128_32][24_5 := 2147483648_32][25_5 := 33554432_32][28_5 := 3221225472_32][9_5 := 32_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 134221951_32
  S1: state_counter = 1_10
  S1: val1 = 536936448_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147487871_32
  S2: state_counter = 2_10
  S2: val1 = 1073741824_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 134221951_32
  S3: state_counter = 3_10
  S3: val1 = 268435456_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 1090523263_32
  S4: state_counter = 4_10
  S4: val1 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1073742975_32
  S5: state_counter = 5_10
  S5: val1 = 4_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 33554483_32
  S6: state_counter = 6_10
  S6: val1 = 1073758208_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 26008627_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 1073741824_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 24_5
  S8: state_counter = 8_10
  S8: val1 = 0_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073741824_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 8192_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 1075086463_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2081721983_32
  S12: state_counter = 12_10
  S12: val1 = 3221225472_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 1073742975_32
  S13: state_counter = 13_10
  S13: val1 = 1073741824_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 127_32
  S14: state_counter = 14_10
  S14: val1 = 33554464_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 1073742975_32
  S15: state_counter = 15_10
  S15: val1 = 1073741824_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4261740671_32
  S16: state_counter = 16_10
  S16: val1 = 67108864_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 536872063_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 17039743_32
  S18: state_counter = 18_10
  S18: val1 = 1140850688_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1107296256_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 33554432_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 2147504255_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 4223_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[1_5 := 128_32][25_5 := 33554432_32][28_5 := 3221225472_32][9_5 := 32_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRL.vcd
[runlim] sample:		133.1 time, 7250.1 real, 2439.9 MB
  Test for SRL using testing-workflow/bug-injection-patches/alu-bug-injected_1_SRL.patch succeeded, CoSA found a counterexample as expected.

Operator name: SRA
  Bug injection patch file for instruction SRA:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SRA.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..75c5655 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -25,7 +25,7 @@ module alu(
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
-        `ALU_OP_SRA : out = $signed(in1) >>> shamt;
+        `ALU_OP_SRA : out = $signed(in1) << shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		6.8 time, 7260.1 real, 202.0 MB
[runlim] sample:		16.8 time, 7270.1 real, 202.0 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRA" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		7.5 time, 7280.1 real, 357.5 MB
__[runlim] sample:		17.5 time, 7290.1 real, 584.3 MB
___[runlim] sample:		27.5 time, 7300.1 real, 785.1 MB
__[runlim] sample:		37.5 time, 7310.1 real, 993.2 MB
___[runlim] sample:		47.5 time, 7320.1 real, 1246.8 MB
__[runlim] sample:		57.5 time, 7330.1 real, 1456.1 MB
_[runlim] sample:		67.5 time, 7340.1 real, 1621.4 MB
__[runlim] sample:		77.5 time, 7350.1 real, 1856.9 MB
__[runlim] sample:		87.5 time, 7360.1 real, 2050.4 MB
_[runlim] sample:		97.5 time, 7370.1 real, 2154.1 MB
_[runlim] sample:		107.5 time, 7380.1 real, 2355.0 MB
_..[runlim] sample:		117.5 time, 7390.1 real, 2478.1 MB
[runlim] sample:		127.5 time, 7400.1 real, 2605.7 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRA **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 1073762431_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 2_32][15_5 := 32_32][16_5 := 3758096384_32][1_5 := 1073741824_32][24_5 := 2147483649_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 285216895_32
  S1: state_counter = 1_10
  S1: val1 = 536936448_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2164265087_32
  S2: state_counter = 2_10
  S2: val1 = 1610612736_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147483775_32
  S3: state_counter = 3_10
  S3: val1 = 134217728_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2684358783_32
  S4: state_counter = 4_10
  S4: val1 = 2147483648_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1077937279_32
  S5: state_counter = 5_10
  S5: val1 = 0_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1074791443_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1099455923_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 27_5
  S8: state_counter = 8_10
  S8: val1 = 3221225472_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1073750016_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 11829375_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2130022015_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 4194431_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 127_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 17301631_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4279238783_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 524415_32
  S17: state_counter = 17_10
  S17: val1 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 852095_32
  S18: state_counter = 18_10
  S18: val1 = 4194304_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 2147483648_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 3758096384_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073762431_32
  S21: shimm2_copy = 1_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 2147487871_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 2_32][15_5 := 32_32][16_5 := 3758096384_32][1_5 := 1073741824_32][24_5 := 2147483649_32][27_5 := 3221225472_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRA.vcd
  Test for SRA using testing-workflow/bug-injection-patches/alu-bug-injected_1_SRA.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SRA:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SRA.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..75c5655 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -25,7 +25,7 @@ module alu(
         `ALU_OP_SEQ : out = {31'b0, in1 == in2};
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
-        `ALU_OP_SRA : out = $signed(in1) >>> shamt;
+        `ALU_OP_SRA : out = $signed(in1) << shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		2.8 time, 7410.1 real, 190.7 MB
[runlim] sample:		12.8 time, 7420.1 real, 202.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRA" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		3.4 time, 7430.1 real, 223.6 MB
_[runlim] sample:		13.4 time, 7440.1 real, 510.9 MB
___[runlim] sample:		23.4 time, 7450.1 real, 688.1 MB
__[runlim] sample:		33.4 time, 7460.1 real, 961.9 MB
___[runlim] sample:		43.4 time, 7470.1 real, 1118.9 MB
__[runlim] sample:		53.4 time, 7480.1 real, 1337.1 MB
__[runlim] sample:		63.4 time, 7490.1 real, 1581.3 MB
_[runlim] sample:		73.4 time, 7500.1 real, 1816.4 MB
__[runlim] sample:		83.4 time, 7510.1 real, 1917.0 MB
_[runlim] sample:		93.4 time, 7520.1 real, 2098.1 MB
_[runlim] sample:		103.4 time, 7530.1 real, 2210.8 MB
_[runlim] sample:		113.4 time, 7540.1 real, 2369.1 MB
_..[runlim] sample:		123.3 time, 7550.1 real, 2432.6 MB
[runlim] sample:		133.3 time, 7560.1 real, 2571.9 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRA **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 268456063_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 33554432_32][14_5 := 1_32][16_5 := 2687581991_32][30_5 := 33554432_32][4_5 := 16_32][6_5 := 33554432_32][8_5 := 65552_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 536875135_32
  S1: state_counter = 1_10

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 268439679_32
  S2: state_counter = 2_10
  S2: val1 = 536870912_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 1073746047_32
  S3: state_counter = 3_10
  S3: val1 = 2147483648_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 536875135_32
  S4: state_counter = 4_10
  S4: val1 = 536870912_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 3221226623_32
  S5: state_counter = 5_10
  S5: val1 = 3221225472_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1090520083_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1082679091_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 30_5
  S8: state_counter = 8_10
  S8: val1 = 1090519040_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 2687500292_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 2687501888_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 151453823_32
  S11: state_counter = 11_10
  S11: val1 = 2687500304_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 4656255_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 4325503_32
  S13: state_counter = 13_10
  S13: val1 = 4096_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2147549311_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777343_32
  S15: state_counter = 15_10
  S15: val1 = 2687500304_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 2141519999_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 127_32
  S17: state_counter = 17_10
  S17: val1 = 2686452224_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 18874495_32
  S18: state_counter = 18_10
  S18: val1 = 1073741824_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1077936129_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 2687581991_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 1073762431_32
  S21: shimm2_copy = 16_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 33554432_32][14_5 := 1_32][16_5 := 2687581991_32][30_5 := 1059520512_32][4_5 := 16_32][6_5 := 33554432_32][8_5 := 65552_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRA.vcd
  Test for SRA using testing-workflow/bug-injection-patches/alu-bug-injected_0_SRA.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SRA:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SRA.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..6c69a31 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -197,7 +197,7 @@ module decoder(
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
-        `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
+        `RV32_FUNCT3_SRA_SRL : alu_op_arith = add_or_sub;
         `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
         `RV32_FUNCT3_AND : alu_op_arith = `ALU_OP_AND;
         default : alu_op_arith = `ALU_OP_ADD;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		3.5 time, 7570.1 real, 192.4 MB
[runlim] sample:		13.5 time, 7580.1 real, 202.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SRA" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		4.2 time, 7590.1 real, 263.0 MB
_[runlim] sample:		14.2 time, 7600.1 real, 515.8 MB
___[runlim] sample:		24.2 time, 7610.1 real, 696.8 MB
___[runlim] sample:		34.2 time, 7620.1 real, 979.4 MB
__[runlim] sample:		44.2 time, 7630.1 real, 1119.2 MB
__[runlim] sample:		54.2 time, 7640.1 real, 1391.6 MB
__[runlim] sample:		64.2 time, 7650.1 real, 1625.1 MB
_[runlim] sample:		74.2 time, 7660.1 real, 1867.8 MB
__[runlim] sample:		84.2 time, 7670.1 real, 1900.2 MB
_[runlim] sample:		94.2 time, 7680.1 real, 2079.0 MB
_[runlim] sample:		104.2 time, 7690.1 real, 2179.5 MB
_[runlim] sample:		114.2 time, 7700.1 real, 2348.4 MB
_..[runlim] sample:		124.2 time, 7710.1 real, 2566.3 MB
[runlim] sample:		134.2 time, 7720.1 real, 2605.9 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SRA **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2147487871_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: shimm2_copy = 0_32
  I: state_counter = 0_10
  I: val1 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 268435520_32][1_5 := 131072_32][21_5 := 536870976_32][27_5 := 2147483648_32][29_5 := 268435457_32][4_5 := 1073741824_32][5_5 := 4_32][8_5 := 536870912_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 134230143_32
  S1: state_counter = 1_10
  S1: val1 = 1073741888_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2151680127_32
  S2: state_counter = 2_10
  S2: val1 = 1207959552_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2160072831_32
  S3: state_counter = 3_10
  S3: val1 = 536870912_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 144709759_32
  S4: state_counter = 4_10
  S4: val1 = 4096_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1090520191_32
  S5: state_counter = 5_10
  S5: val1 = 1610612736_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1075840019_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 1085198899_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 4_5
  S8: state_counter = 8_10
  S8: val1 = 3221225472_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 1074921472_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741825_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 688255_32
  S11: state_counter = 11_10
  S11: val1 = 0_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2055900287_32
  S12: state_counter = 12_10
  S12: val1 = 268435456_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 262271_32
  S13: state_counter = 13_10
  S13: val1 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 28475775_32
  S14: state_counter = 14_10
  S14: val1 = 268435457_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 383_32
  S15: state_counter = 15_10
  S15: val1 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 321716351_32
  S16: state_counter = 16_10
  S16: val1 = 268435458_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 639_32
  S17: state_counter = 17_10
  S17: val1 = 302252034_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 13632383_32
  S18: state_counter = 18_10
  S18: val1 = 1344274433_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073743487_32
  S19: state_counter = 19_10
  S19: val1 = 1342177281_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 3221226111_32
  S20: state_counter = 20_10
  S20: val1 = 268435457_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 2147504767_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 1073746559_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 268435520_32][1_5 := 131072_32][21_5 := 536870976_32][27_5 := 2147483648_32][29_5 := 268435457_32][4_5 := 4294967233_32][5_5 := 4_32][8_5 := 536870912_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SRA.vcd
  Test for SRA using testing-workflow/bug-injection-patches/alu-bug-injected_2_SRA.patch succeeded, CoSA found a counterexample as expected.

Operator name: SLTU
  Bug injection patch file for instruction SLTU:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SLTU.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..3d6e5bd 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -28,7 +28,7 @@ module alu(
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
-        `ALU_OP_SLTU : out = {31'b0, in1 < in2};
+        `ALU_OP_SLTU : out = {31'b0, in1 > in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
         default : out = 0;
       endcase // case op
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		3.2 time, 7730.1 real, 190.8 MB
[runlim] sample:		13.2 time, 7740.1 real, 202.1 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTU" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		3.6 time, 7750.1 real, 197.1 MB
_[runlim] sample:		13.6 time, 7760.1 real, 475.9 MB
___[runlim] sample:		23.6 time, 7770.1 real, 695.5 MB
__[runlim] sample:		33.6 time, 7780.1 real, 845.6 MB
___[runlim] sample:		43.6 time, 7790.1 real, 1105.8 MB
__[runlim] sample:		53.5 time, 7800.1 real, 1363.4 MB
__[runlim] sample:		63.5 time, 7810.1 real, 1575.6 MB
_[runlim] sample:		73.5 time, 7820.1 real, 1802.6 MB
__[runlim] sample:		83.5 time, 7830.1 real, 1913.1 MB
_[runlim] sample:		93.5 time, 7840.1 real, 2060.8 MB
_[runlim] sample:		103.5 time, 7850.1 real, 2158.2 MB
_[runlim] sample:		113.5 time, 7860.1 real, 2352.2 MB
_..[runlim] sample:		123.5 time, 7870.1 real, 2550.9 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTU **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 134230143_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2097169_32][12_5 := 1073741824_32][14_5 := 262144_32][16_5 := 266241_32][24_5 := 3853516311_32][25_5 := 3853516295_32][8_5 := 1_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147487871_32
  S1: state_counter = 1_10
  S1: val1 = 268435457_32
  S1: val2 = 1073741856_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536875135_32
  S2: state_counter = 2_10
  S2: val1 = 134217728_32
  S2: val2 = 536870912_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 1073746047_32
  S3: state_counter = 3_10
  S3: val1 = 2147483648_32
  S3: val2 = 268435456_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2147516543_32
  S4: state_counter = 4_10
  S4: val1 = 33554432_32
  S4: val2 = 536870912_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1074791551_32
  S5: state_counter = 5_10
  S5: val1 = 301989888_32
  S5: val2 = 1107296256_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25998899_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 12_5
  S8: state_counter = 8_10
  S8: val1 = 1073741824_32
  S8: val2 = 1073741824_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 16777216_32
  S9: val2 = 16777216_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1342177280_32
  S10: val2 = 3221225472_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 29687935_32
  S11: state_counter = 11_10
  S11: val1 = 1073741856_32
  S11: val2 = 3853516311_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2095383807_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32
  S12: val2 = 1075838976_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 4194431_32
  S13: state_counter = 13_10
  S13: val1 = 3853516294_32
  S13: val2 = 268435456_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 29622399_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 3853516304_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 255_32
  S15: state_counter = 15_10
  S15: val1 = 3853516295_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4278453503_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 3221225472_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1090520191_32
  S17: state_counter = 17_10
  S17: val1 = 0_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 65663_32
  S18: state_counter = 18_10
  S18: val1 = 1090519040_32
  S18: val2 = 33554432_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1074790416_32
  S19: val2 = 536870928_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 3853516295_32
  S20: val2 = 3853516311_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 4206719_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2097169_32][14_5 := 262144_32][16_5 := 266241_32][24_5 := 3853516311_32][25_5 := 3853516295_32][8_5 := 1_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTU.vcd
[runlim] sample:		133.5 time, 7880.1 real, 2589.4 MB
  Test for SLTU using testing-workflow/bug-injection-patches/alu-bug-injected_0_SLTU.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLTU:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SLTU.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..66e351f 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -28,7 +28,7 @@ module alu(
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
         `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
-        `ALU_OP_SLTU : out = {31'b0, in1 < in2};
+        `ALU_OP_SLTU : out = {31'b0, in1 != in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
         default : out = 0;
       endcase // case op
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		6.0 time, 7890.1 real, 202.5 MB
[runlim] sample:		16.0 time, 7900.1 real, 202.5 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTU" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		6.7 time, 7910.1 real, 357.6 MB
__[runlim] sample:		16.7 time, 7920.1 real, 556.2 MB
___[runlim] sample:		26.7 time, 7930.1 real, 762.6 MB
__[runlim] sample:		36.7 time, 7940.1 real, 958.4 MB
___[runlim] sample:		46.7 time, 7950.1 real, 1240.7 MB
__[runlim] sample:		56.7 time, 7960.1 real, 1464.9 MB
_[runlim] sample:		66.7 time, 7970.1 real, 1605.5 MB
__[runlim] sample:		76.7 time, 7980.1 real, 1864.1 MB
__[runlim] sample:		86.7 time, 7990.1 real, 2083.8 MB
_[runlim] sample:		96.7 time, 8000.1 real, 2104.7 MB
_[runlim] sample:		106.7 time, 8010.1 real, 2283.5 MB
_.[runlim] sample:		116.7 time, 8020.1 real, 2349.2 MB
...[runlim] sample:		126.7 time, 8030.1 real, 2657.1 MB
.. UNKNOWN

*** SUMMARY ***

** Problem Single Instruction for SLTU **
Description: "Check for Single Instruction"
Result: UNKNOWN
BMC depth: 25
[runlim] sample:		136.7 time, 8040.1 real, 3147.5 MB
  Test for SLTU using testing-workflow/bug-injection-patches/alu-bug-injected_1_SLTU.patch failed, CoSA proved the property unexpectedly.
  Bug injection patch file for instruction SLTU:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SLTU.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..0b6c2e8 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -195,7 +195,7 @@ module decoder(
         `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
         `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
-        `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
+        `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
         `RV32_FUNCT3_OR : alu_op_arith = `ALU_OP_OR;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		4.5 time, 8050.1 real, 192.3 MB
[runlim] sample:		14.5 time, 8060.1 real, 202.4 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLTU" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		4.9 time, 8070.1 real, 271.9 MB
__[runlim] sample:		14.9 time, 8080.1 real, 535.6 MB
__[runlim] sample:		24.9 time, 8090.1 real, 746.7 MB
___[runlim] sample:		34.9 time, 8100.1 real, 993.0 MB
__[runlim] sample:		44.9 time, 8110.1 real, 1146.3 MB
__[runlim] sample:		54.9 time, 8120.1 real, 1429.7 MB
__[runlim] sample:		64.9 time, 8130.1 real, 1607.6 MB
__[runlim] sample:		74.8 time, 8140.1 real, 1858.1 MB
_[runlim] sample:		84.8 time, 8150.1 real, 2036.9 MB
_[runlim] sample:		94.8 time, 8160.1 real, 2065.9 MB
_[runlim] sample:		104.8 time, 8170.1 real, 2192.6 MB
_[runlim] sample:		114.8 time, 8180.1 real, 2351.4 MB
_..[runlim] sample:		124.8 time, 8190.1 real, 2555.1 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLTU **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 134230143_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2147483648_32][14_5 := 2147483648_32][16_5 := 3221749760_32][1_5 := 16777216_32][2_5 := 2684354560_32][31_5 := 134217728_32][8_5 := 524320_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2281713791_32
  S1: state_counter = 1_10
  S1: val1 = 1075839488_32
  S1: val2 = 2281701408_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 536871039_32
  S2: state_counter = 2_10
  S2: val1 = 3355443200_32
  S2: val2 = 1744830464_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 201326592_32
  S3: val2 = 2281701376_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 2155876735_32
  S4: state_counter = 4_10
  S4: val1 = 402653184_32
  S4: val2 = 16777216_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 75497855_32
  S5: state_counter = 5_10
  S5: val1 = 2281701376_32
  S5: val2 = 150994944_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073745171_32
  S6: state_counter = 6_10
  S6: val1 = 3355443200_32
  S6: val2 = 1476395520_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 17051955_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 536870912_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 2_5
  S8: state_counter = 8_10
  S8: val1 = 1610612736_32
  S8: val2 = 1778450944_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 524288_32
  S9: val2 = 273091073_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 134479872_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 31785087_32
  S11: state_counter = 11_10
  S11: val1 = 524348_32
  S11: val2 = 3221562498_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2128940927_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32
  S12: val2 = 35921920_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 524927_32
  S13: state_counter = 13_10
  S13: val1 = 524340_32
  S13: val2 = 303497216_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 2124480895_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 3221389376_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 537395327_32
  S15: state_counter = 15_10
  S15: val1 = 524320_32
  S15: val2 = 268435520_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4266623103_32
  S16: state_counter = 16_10
  S16: val1 = 1610612736_32
  S16: val2 = 3221790784_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 570949759_32
  S17: state_counter = 17_10
  S17: val1 = 536870912_32
  S17: val2 = 2181046272_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 27263103_32
  S18: state_counter = 18_10
  S18: val1 = 1342177280_32
  S18: val2 = 1610612736_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1074266148_32
  S19: val2 = 2148007940_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 127_32
  S20: state_counter = 20_10
  S20: val1 = 524320_32
  S20: val2 = 3221749760_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 12415_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 268439679_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[10_5 := 2147483648_32][14_5 := 2147483648_32][16_5 := 3221749760_32][1_5 := 16777216_32][2_5 := 3221225504_32][31_5 := 134217728_32][8_5 := 524320_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLTU.vcd
[runlim] sample:		134.8 time, 8200.1 real, 2482.3 MB
  Test for SLTU using testing-workflow/bug-injection-patches/alu-bug-injected_2_SLTU.patch succeeded, CoSA found a counterexample as expected.

Operator name: SLT
  Bug injection patch file for instruction SLT:  testing-workflow/bug-injection-patches/alu-bug-injected_1_SLT.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..e51ec81 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -26,7 +26,7 @@ module alu(
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
-        `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
+        `ALU_OP_SLT : out = {31'b0, $signed(in1) != $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		7.7 time, 8210.1 real, 202.1 MB
[runlim] sample:		17.6 time, 8220.1 real, 255.7 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLT" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		8.3 time, 8230.1 real, 357.2 MB
___[runlim] sample:		18.2 time, 8240.1 real, 596.6 MB
__[runlim] sample:		28.2 time, 8250.1 real, 865.3 MB
___[runlim] sample:		38.2 time, 8260.1 real, 1081.2 MB
__[runlim] sample:		48.2 time, 8270.1 real, 1332.0 MB
__[runlim] sample:		58.2 time, 8280.1 real, 1521.0 MB
__[runlim] sample:		68.2 time, 8290.1 real, 1797.5 MB
__[runlim] sample:		78.2 time, 8300.1 real, 1955.4 MB
_[runlim] sample:		88.2 time, 8310.1 real, 2132.7 MB
_[runlim] sample:		98.2 time, 8320.1 real, 2172.9 MB
__.[runlim] sample:		108.2 time, 8330.1 real, 2346.9 MB
.[runlim] sample:		118.2 time, 8340.1 real, 2510.2 MB
...[runlim] sample:		128.2 time, 8350.1 real, 3004.6 MB
. UNKNOWN

*** SUMMARY ***

** Problem Single Instruction for SLT **
Description: "Check for Single Instruction"
Result: UNKNOWN
BMC depth: 25
[runlim] sample:		138.2 time, 8360.1 real, 2388.0 MB
  Test for SLT using testing-workflow/bug-injection-patches/alu-bug-injected_1_SLT.patch failed, CoSA proved the property unexpectedly.
  Bug injection patch file for instruction SLT:  testing-workflow/bug-injection-patches/alu-bug-injected_0_SLT.patch
  Original Verilog file name: alu.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file alu.v
patching file ridecore-original-src//alu.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/alu.v b/ridecore-original-src/alu.v
index 6a7aa92..74aeaef 100755
--- a/ridecore-original-src/alu.v
+++ b/ridecore-original-src/alu.v
@@ -26,7 +26,7 @@ module alu(
         `ALU_OP_SNE : out = {31'b0, in1 != in2};
         `ALU_OP_SUB : out = in1 - in2;
         `ALU_OP_SRA : out = $signed(in1) >>> shamt;
-        `ALU_OP_SLT : out = {31'b0, $signed(in1) < $signed(in2)};
+        `ALU_OP_SLT : out = {31'b0, $signed(in1) > $signed(in2)};
         `ALU_OP_SGE : out = {31'b0, $signed(in1) >= $signed(in2)};
         `ALU_OP_SLTU : out = {31'b0, in1 < in2};
         `ALU_OP_SGEU : out = {31'b0, in1 >= in2};
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		9.7 time, 8370.1 real, 202.3 MB
[runlim] sample:		19.7 time, 8380.1 real, 284.2 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLT" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		10.3 time, 8390.1 real, 466.8 MB
___[runlim] sample:		20.3 time, 8400.1 real, 625.2 MB
___[runlim] sample:		30.2 time, 8410.1 real, 810.3 MB
__[runlim] sample:		40.2 time, 8420.1 real, 1019.5 MB
__[runlim] sample:		50.2 time, 8430.1 real, 1235.3 MB
__[runlim] sample:		60.2 time, 8440.1 real, 1466.0 MB
__[runlim] sample:		70.2 time, 8450.1 real, 1648.3 MB
_[runlim] sample:		80.2 time, 8460.1 real, 1870.9 MB
__[runlim] sample:		90.2 time, 8470.1 real, 2067.7 MB
_[runlim] sample:		100.2 time, 8480.1 real, 2147.8 MB
_[runlim] sample:		110.2 time, 8490.1 real, 2238.6 MB
_..[runlim] sample:		120.2 time, 8500.1 real, 2432.9 MB
[runlim] sample:		130.2 time, 8510.1 real, 2568.7 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLT **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2147483775_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 2147483715_32][19_5 := 1073741824_32][24_5 := 1073741825_32][2_5 := 2147483648_32][31_5 := 2147483715_32][4_5 := 8388608_32][8_5 := 16_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 3221229695_32
  S1: state_counter = 1_10
  S1: val2 = 268566529_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 2147488127_32
  S2: state_counter = 2_10
  S2: val1 = 1073741824_32
  S2: val2 = 2151677952_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2151682175_32
  S3: state_counter = 3_10
  S3: val1 = 2147483648_32
  S3: val2 = 541065216_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 272635007_32
  S4: state_counter = 4_10
  S4: val1 = 67108864_32
  S4: val2 = 134217728_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1074006143_32
  S5: state_counter = 5_10
  S5: val1 = 1073741824_32
  S5: val2 = 2147483648_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073741843_32
  S6: state_counter = 6_10
  S6: val1 = 1207959552_32
  S6: val2 = 3221225472_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 25702323_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 31_5
  S8: state_counter = 8_10
  S8: val1 = 1090519040_32
  S8: val2 = 1140850688_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 2147484200_32
  S9: val2 = 1610613248_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 1610612736_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 262783_32
  S11: state_counter = 11_10
  S11: val1 = 2147549185_32
  S11: val2 = 1073774592_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 4286844543_32
  S12: state_counter = 12_10
  S12: val1 = 1073741824_32
  S12: val2 = 1073741825_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 5243007_32
  S13: state_counter = 13_10
  S13: val1 = 2147483712_32
  S13: val2 = 0_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 8519807_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1073741953_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 127_32
  S15: state_counter = 15_10
  S15: val1 = 2147483728_32
  S15: val2 = 0_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4278517887_32
  S16: state_counter = 16_10
  S16: val1 = 1207959552_32
  S16: val2 = 1073741840_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 16777343_32
  S17: state_counter = 17_10
  S17: val1 = 1073741824_32
  S17: val2 = 0_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 127_32
  S18: state_counter = 18_10
  S18: val1 = 1090519040_32
  S18: val2 = 1610612736_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1073742975_32
  S19: state_counter = 19_10
  S19: val1 = 1610612769_32
  S19: val2 = 1_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 8388735_32
  S20: state_counter = 20_10
  S20: val1 = 2147483715_32
  S20: val2 = 1073741825_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 8319_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 536875135_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[16_5 := 2147483715_32][19_5 := 1073741824_32][24_5 := 1073741825_32][2_5 := 2147483648_32][4_5 := 8388608_32][8_5 := 16_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLT.vcd
  Test for SLT using testing-workflow/bug-injection-patches/alu-bug-injected_0_SLT.patch succeeded, CoSA found a counterexample as expected.
  Bug injection patch file for instruction SLT:  testing-workflow/bug-injection-patches/alu-bug-injected_2_SLT.patch
  Original Verilog file name: decoder.v
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
  Patching original file decoder.v
patching file ridecore-original-src//decoder.v
  Output of 'git diff' to verify successful bug injection:
diff --git a/ridecore-original-src/decoder.v b/ridecore-original-src/decoder.v
index 6fd9b7a..388d8ff 100755
--- a/ridecore-original-src/decoder.v
+++ b/ridecore-original-src/decoder.v
@@ -12,7 +12,7 @@ module decoder(
 	       output reg [`SRC_A_SEL_WIDTH-1:0]  src_a_sel,
                output reg [`SRC_B_SEL_WIDTH-1:0]  src_b_sel,
 	       output reg 			  wr_reg,
-	       
+
 	       output reg 			  uses_rs1,
 	       output reg 			  uses_rs2,
 	       output reg 			  illegal_instruction,
@@ -21,7 +21,7 @@ module decoder(
 //	       output reg 			  dmem_use,
 //	       output reg 			  dmem_write,
 	       output wire [2:0] 		  dmem_size,
-	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type, 
+	       output wire [`MEM_TYPE_WIDTH-1:0]  dmem_type,
 	       output reg [`MD_OP_WIDTH-1:0] 	  md_req_op,
 	       output reg 			  md_req_in_1_signed,
 	       output reg 			  md_req_in_2_signed,
@@ -32,21 +32,21 @@ module decoder(
    wire [`ALU_OP_WIDTH-1:0] 			  srl_or_sra;
    wire [`ALU_OP_WIDTH-1:0] 			  add_or_sub;
    wire [`RS_ENT_SEL-1:0] 			  rs_ent_md;
-   
+
    wire [6:0] 		    opcode = inst[6:0];
    wire [6:0] 		    funct7 = inst[31:25];
    wire [11:0] 		    funct12 = inst[31:20];
    wire [2:0] 		    funct3 = inst[14:12];
 // reg [`MD_OP_WIDTH-1:0]   md_req_op;
    reg [`ALU_OP_WIDTH-1:0]  alu_op_arith;
-   
+
    assign rd = inst[11:7];
    assign rs1 = inst[19:15];
    assign rs2 = inst[24:20];
 
    assign dmem_size = {1'b0,funct3[1:0]};
    assign dmem_type = funct3;
-   
+
    always @ (*) begin
       imm_type = `IMM_I;
       src_a_sel = `SRC_A_RS1;
@@ -59,7 +59,7 @@ module decoder(
       //     dmem_write = 1'b0;
       rs_ent = `RS_ENT_ALU;
       alu_op = `ALU_OP_ADD;
-      
+
       case (opcode)
 	`RV32_LOAD : begin
 //           dmem_use = 1'b1;
@@ -194,7 +194,7 @@ module decoder(
       case (funct3)
         `RV32_FUNCT3_ADD_SUB : alu_op_arith = add_or_sub;
         `RV32_FUNCT3_SLL : alu_op_arith = `ALU_OP_SLL;
-        `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_SLT;
+        `RV32_FUNCT3_SLT : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SLTU : alu_op_arith = `ALU_OP_SLTU;
         `RV32_FUNCT3_XOR : alu_op_arith = `ALU_OP_XOR;
         `RV32_FUNCT3_SRA_SRL : alu_op_arith = srl_or_sra;
@@ -212,7 +212,7 @@ module decoder(
 		       (funct3 == `RV32_FUNCT3_MULHSU) ||
 		       (funct3 == `RV32_FUNCT3_MULHU)
 		       ) ? `RS_ENT_MUL : `RS_ENT_DIV;
-   
+
    always @(*) begin
       md_req_op = `MD_OP_MUL;
       md_req_in_1_signed = 0;
@@ -254,6 +254,6 @@ module decoder(
       endcase
    end
 
-   
+
 endmodule // decoder
 `default_nettype wire
  Running CoSA --problems cosa/tmpfilebmctest-9370.txt
Parsing file "cosa/ridecore.vlist"... Reading source files from "ridecore.vlist"... [runlim] sample:		3.5 time, 8520.1 real, 192.1 MB
[runlim] sample:		13.5 time, 8530.1 real, 202.2 MB
DONE
Parsing file "cosa/reset_procedure.ets"... DONE
Parsing file "cosa/init.ssts"... DONE
Parsing file "cosa/state_copy.ssts"... DONE
Parsing file "cosa/nop_m.ssts"... DONE
Solving "Single Instruction for SLT" 
WARNING: Using default_initial_value with arrays, but btor does not support constant arrays. Any assumptions on initial array values will have to be done manually
[runlim] sample:		4.2 time, 8540.1 real, 262.7 MB
_[runlim] sample:		14.2 time, 8550.1 real, 526.4 MB
___[runlim] sample:		24.2 time, 8560.1 real, 745.6 MB
___[runlim] sample:		34.2 time, 8570.1 real, 972.1 MB
__[runlim] sample:		44.2 time, 8580.1 real, 1105.6 MB
__[runlim] sample:		54.2 time, 8590.1 real, 1425.2 MB
__[runlim] sample:		64.2 time, 8600.1 real, 1607.7 MB
__[runlim] sample:		74.2 time, 8610.1 real, 1855.5 MB
_[runlim] sample:		84.2 time, 8620.1 real, 1978.2 MB
_[runlim] sample:		94.2 time, 8630.1 real, 2077.9 MB
_[runlim] sample:		104.2 time, 8640.1 real, 2156.1 MB
_[runlim] sample:		114.2 time, 8650.1 real, 2370.5 MB
_..[runlim] sample:		124.2 time, 8660.1 real, 2554.2 MB
[runlim] sample:		134.2 time, 8670.1 real, 2611.5 MB
 FALSE

*** SUMMARY ***

** Problem Single Instruction for SLT **
Description: "Check for Single Instruction"
Result: FALSE
Counterexample:
---> INIT <---
  I: clk = 0_1
  I: instruction = 2149589119_32
  I: rd_copy = 0_5
  I: reset_done = False
  I: reset_x = 0_1
  I: state_counter = 0_10
  I: val1 = 0_32
  I: val2 = 0_32
  I: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 64_32][13_5 := 268435456_32][16_5 := 524288_32][18_5 := 1073741828_32][19_5 := 1073741824_32][2_5 := 1_32][3_5 := 1073741824_32][8_5 := 65536_32][9_5 := 2147483648_32]

---> STATE 1 <---
  S1: clk = 1_1
  S1: instruction = 2147496063_32
  S1: state_counter = 1_10
  S1: val2 = 75497472_32

---> STATE 2 <---
  S2: clk = 0_1
  S2: instruction = 67113087_32
  S2: state_counter = 2_10
  S2: val1 = 2281701376_32
  S2: val2 = 2147483648_32

---> STATE 3 <---
  S3: clk = 1_1
  S3: instruction = 2147487871_32
  S3: state_counter = 3_10
  S3: val1 = 268435456_32
  S3: val2 = 1073741824_32

---> STATE 4 <---
  S4: clk = 0_1
  S4: instruction = 67113087_32
  S4: state_counter = 4_10
  S4: val1 = 16777216_32
  S4: val2 = 16777216_32

---> STATE 5 <---
  S5: clk = 1_1
  S5: instruction = 1090520191_32
  S5: state_counter = 5_10
  S5: val1 = 536870912_32
  S5: val2 = 67108864_32

---> STATE 6 <---
  S6: clk = 0_1
  S6: instruction = 1073742867_32
  S6: state_counter = 6_10
  S6: val1 = 1073741824_32
  S6: val2 = 1073741824_32

---> STATE 7 <---
  S7: clk = 1_1
  S7: instruction = 19177651_32
  S7: reset_done = True
  S7: reset_x = 1_1
  S7: state_counter = 7_10
  S7: val1 = 0_32
  S7: val2 = 0_32

---> STATE 8 <---
  S8: clk = 0_1
  S8: rd_copy = 1_5
  S8: state_counter = 8_10
  S8: val1 = 1342177280_32
  S8: val2 = 1342177280_32

---> STATE 9 <---
  S9: clk = 1_1
  S9: state_counter = 9_10
  S9: val1 = 2147483650_32
  S9: val2 = 1073741825_32

---> STATE 10 <---
  S10: clk = 0_1
  S10: state_counter = 10_10
  S10: val1 = 1073741824_32
  S10: val2 = 1140850688_32

---> STATE 11 <---
  S11: clk = 1_1
  S11: instruction = 14483583_32
  S11: state_counter = 11_10
  S11: val1 = 2147483649_32
  S11: val2 = 1073741825_32

---> STATE 12 <---
  S12: clk = 0_1
  S12: instruction = 2060814847_32
  S12: state_counter = 12_10
  S12: val1 = 1073741828_32
  S12: val2 = 1073741828_32

---> STATE 13 <---
  S13: clk = 1_1
  S13: instruction = 383_32
  S13: state_counter = 13_10
  S13: val1 = 2147483931_32
  S13: val2 = 1048576_32

---> STATE 14 <---
  S14: clk = 0_1
  S14: instruction = 8913151_32
  S14: state_counter = 14_10
  S14: val1 = 1073741824_32
  S14: val2 = 1073741828_32

---> STATE 15 <---
  S15: clk = 1_1
  S15: instruction = 16777599_32
  S15: state_counter = 15_10
  S15: val1 = 69206016_32
  S15: val2 = 33554432_32

---> STATE 16 <---
  S16: clk = 0_1
  S16: instruction = 4287365247_32
  S16: state_counter = 16_10
  S16: val1 = 1073741824_32
  S16: val2 = 1073741824_32

---> STATE 17 <---
  S17: clk = 1_1
  S17: instruction = 1151_32
  S17: state_counter = 17_10
  S17: val1 = 33554432_32
  S17: val2 = 262144_32

---> STATE 18 <---
  S18: clk = 0_1
  S18: instruction = 17924479_32
  S18: state_counter = 18_10
  S18: val1 = 268435456_32
  S18: val2 = 2048_32

---> STATE 19 <---
  S19: clk = 1_1
  S19: instruction = 1107297407_32
  S19: state_counter = 19_10
  S19: val1 = 1073742106_32
  S19: val2 = 286_32

---> STATE 20 <---
  S20: clk = 0_1
  S20: instruction = 255_32
  S20: state_counter = 20_10
  S20: val1 = 2147483648_32
  S20: val2 = 1073741828_32

---> STATE 21 <---
  S21: clk = 1_1
  S21: instruction = 570433663_32
  S21: state_counter = 21_10

---> STATE 22 <---
  S22: clk = 0_1
  S22: instruction = 33558655_32
  S22: state_counter = 22_10
  S22: pipe.aregfile.regfile.mem = Array{BV{5}, BV{32}}(0_32)[11_5 := 64_32][13_5 := 268435456_32][16_5 := 524288_32][18_5 := 1073741828_32][19_5 := 1073741824_32][1_5 := 3221225476_32][2_5 := 1_32][3_5 := 1073741824_32][8_5 := 65536_32][9_5 := 2147483648_32]
Counterexamples: [1], [2]
Traces (max) length: 23

*** TRACES ***

[1]:	trace[1]-Single Instruction for SLT.vcd
  Test for SLT using testing-workflow/bug-injection-patches/alu-bug-injected_2_SLT.patch succeeded, CoSA found a counterexample as expected.

Operator name: LW
  No bug injection patches found for instruction LW, skipping tests.
Operator name: SW
  No bug injection patches found for instruction SW, skipping tests.
Operator name: MUL_V1
  No bug injection patches found for instruction MUL_V1, skipping tests.
Operator name: MUL_V2
  No bug injection patches found for instruction MUL_V2, skipping tests.
Operator name: MUL_V3
  No bug injection patches found for instruction MUL_V3, skipping tests.
Operator name: MUL_V4
  No bug injection patches found for instruction MUL_V4, skipping tests.
Cleaning up temporary files.
  cleanup: resetting any local changes
HEAD is now at 319222e Merge remote-tracking branch 'upstream/master'
[runlim] end:			Tue Apr  9 15:40:07 2019
[runlim] status:		ok
[runlim] result:		0
[runlim] children:		195185
[runlim] real:			8676.09 seconds
[runlim] time:			142.16 seconds
[runlim] space:			3149.9 MB
[runlim] samples:		86759
